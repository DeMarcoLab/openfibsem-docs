{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"OpenFIBSEM","text":"<p>Welcome to the documentation site for OpenFIBSEM.</p> <p>Check out the API documentation, or AutoLamella project in the tabs above.</p> <p>[Under Construction]</p>"},{"location":"autolamella/","title":"AutoLamella","text":""},{"location":"autolamella/#introduction","title":"Introduction","text":"<p>Lamella Preparation</p> <p>Methods</p> <p>Conceptual Overview</p> <p>Implementation</p> <p>Experiment Management</p> <p>Analysis and Results</p>"},{"location":"autolamella/case_study_serial_liftout/","title":"Case Study - Serial Liftout","text":"<p>The following is a walkthrough of implementing the serial liftout method in AutoLamella. It is based on the supplementary of the Serial Liftout paper Step-by-Step Towards Successful Serial Lift-Out</p>"},{"location":"autolamella/case_study_serial_liftout/#autolamella-implementation","title":"AutoLamella Implementation","text":"<p>This is based on our current implementation of Serial Liftout in AutoLamella. This implementation is still in development, but you can try this in the AutoLiftout UI by selecting the autolamella/protocol-serial-liftout.yaml protocol, or selecting the autolamella-serial-liftout method and configuring your protocol in the user interface.</p> <p>The current implementation in AutoLamella is slightly different than this example, due to additional experiment management integrations, logging and user interface interaction. But this should illustrate how you can use openfibsem, and the tools developed for other autolamella methods, to quickly implement a new method.</p> <p>The specific workflow code is located:</p> <ul> <li>Core: autolamella/workflows/core.py</li> <li>Serial Liftout: autolamella/workflows/serial.py</li> </ul> <p>If you want to try out this implementation workflow feel free, and if you would like any assistance please contact Patrick on Github (@patrickcleeve2) or via email.</p>"},{"location":"autolamella/case_study_serial_liftout/#acknowledgement","title":"Acknowledgement","text":"<p>This implementation would not have been possible without discussions and data from Oda and Sven at MPI. </p>"},{"location":"autolamella/case_study_serial_liftout/#getting-started","title":"Getting Started","text":"<p>For information on how to configure your microscope for use with openfibsem, please see Getting Started</p>"},{"location":"autolamella/case_study_serial_liftout/#connecting-to-the-microscope","title":"Connecting to the Microscope","text":"<p>Once you have configured your microscope, you should be able to sucessfully connect using your configuration.</p> <p><pre><code>from fibsem import utils\n\n# connect to microscope\nmicroscope, settings = utils.setup_session(config_path=\"path/to/configuration.yaml\", \n                                            protocol_path=\"path/to/protocol-serial-liftout.yaml\")\n</code></pre> The microscope object is the client connection to the microscope server, and settings is the configured settings of the microscope, for example the default imaging settings are available with settings.image.</p> <p>You can access the protocol dictionary from settings.protocol.</p>"},{"location":"autolamella/case_study_serial_liftout/#terminology","title":"Terminology","text":"<p>We will use the following terminology in this guide. Please see the Concepts Page for additional information.</p>"},{"location":"autolamella/case_study_serial_liftout/#beam-coincidence","title":"Beam Coincidence","text":"<p>Beam coincidence refers to when the same feature is centred in both beams. Practically there will always be a small shift, but we want to minimise this where possible. Eucentric height is also refered to, as the position of the stage such that features stay in the same position when the stage is tilted.</p>"},{"location":"autolamella/case_study_serial_liftout/#flat-to-beam","title":"Flat to Beam","text":"<p>When the stage is flat to a beam (e.g. flat to the electron beam) it is perpendicular to the imaging plane. Based on the microscope configuration (manufactuer, stage, and shuttle pre-tilt), we calculate the orientation required (rotation, and tilt) to move the stage to these positions. In the serial liftout appendix, the positions are given for a 45 deg shuttle-pre-tilt, and the term relative rotation is used. These map to the following flat to beam positions.</p> <ul> <li>Flat to Electron Beam: 0 relative rotation,  shuttle-pre-tilt deg tilt</li> <li>Flat to Ion Beam: 180deg relative rotation, 52 - shuttle-pre-tilt deg tilt</li> </ul>"},{"location":"autolamella/case_study_serial_liftout/#movement-modes","title":"Movement Modes","text":"<p>We use several movement methods in openfibsem, that make automation much easier as they assist with maintaining coincidence, restore coincidence, and correcting for the imaging perspective. These are:</p> <ul> <li>Stable Movement (Stage): Stable movements move along the sample plane, and maintain the coincidence of the beams. They correct for the stage tilt, shuttle pre-tilt and the imaging perspective.</li> <li>Vertical Movement (Stage): Vertical movements move the stage vertically in the chamber, corrected for the stage tilt, pre-tilt and imaging perspective. They are used to realign beam coincidence (i.e. align ion to electron).</li> <li>Corrected Movement (Manipulator): Corrected manipulator movements move only single axes at a time. The axes correspond to the imaging perspectives. Electron beam x and y directions map to the x, y axes and the Ion Beam x and y directions map to the x, and z axes. This allows you to move a single manipulator axes, without moving its position in the other beam.</li> </ul> <p>As these movements all correct for the imaging perspective, they also take the beam type as a parameter. The beam type is where the imaging perspective correction is calculated from. Imaging perspective refers to the distortion when the imaging plane is not parallel to the sample plane. For example, imaging in the ion beam when the sample is flat to the electron beam causes a perspective distortion.</p>"},{"location":"autolamella/case_study_serial_liftout/#microscope-configuration","title":"Microscope Configuration","text":"<p>The microscope configuration refers to how the microscope is initially configured, including specifying metatdata about the manufacturer, hardware and settings used.</p>"},{"location":"autolamella/case_study_serial_liftout/#protocol","title":"Protocol","text":"<p>The protocol refers to method specific parameters that are used to control how workflows are executed, select options, and define milling parameters.</p>"},{"location":"autolamella/case_study_serial_liftout/#serial-liftout-dataset-and-model","title":"Serial Liftout Dataset and Model","text":"<p>The MPI team generously provided a dataset from their serial liftout experiments. From this data we have labelled ~400 images from a workflow, and trained a segmentation model.</p> <p><pre><code>checkpoint: 'autolamella-serial-liftout-20240107.pt'\n</code></pre> You can access both the dataset and model through the huggingface api. For more information on both the dataset and models, please see Machine Learning Page.</p> <p>We will be using examples from the dataset, and model inference throughout this guide.</p>"},{"location":"autolamella/case_study_serial_liftout/#serial-liftout-workflow","title":"Serial Liftout Workflow","text":"<p>We will work through the explanatory protocol document, and demonstrate how we can implement the steps using the openfibsem api. We will start from the section Procedure:Preparatory Steps on page 16. This is the start of the FIBSEM operation, after sample preparation and vitrification.</p> <p>This guide was written for a Thermo Fisher Hydra Plasma FIB, but should be general for other systems. The guide is intened more as an introduction to using openfibsem, rather than a complete automated workflow. For current implementation in the user interface, please see AutoLamella Implementation.</p>"},{"location":"autolamella/case_study_serial_liftout/#preparatory-steps","title":"Preparatory Steps","text":"<p>The goal of the preparatory steps is to prepare the manipulator and grids for the workflow.</p>"},{"location":"autolamella/case_study_serial_liftout/#available-via-user-interface","title":"Available via User Interface","text":"<p>The manipulator preparation is available in AutoLiftout UI in the Tools menu. You will need to connect to the microscope, create / load an experiment and load a serial-liftout protocol before you can access it. You can find the code for preparing the manipulator in autolamella/workflows/autoliftout.py:_prepare_manipulator_serial_liftout</p>"},{"location":"autolamella/case_study_serial_liftout/#step-1-prepare-manipulator","title":"Step 1 - Prepare Manipulator","text":"<p>In this step we have to prepare and calibrate the manipulator.  </p> <p>A. Focus and Link Stage Currently it is recommend to manually focus and link the stage before starting openfibsem. Once you are more confident with the system, you can restore to a saved position to automatically skip this step.</p> <p>B. Beam Coincidence</p> <p>To align the beams coincident, we can use the following steps:</p> <ol> <li>Detect a Feature in Electron Beam</li> <li>Move the Feature the centre of in Electron Beam (Stable Movement)</li> <li>Detect the Feature in the Ion Beam</li> <li>Move the stage vertically to move the Feature to the centre of the Ion Beam. (Vertical Movement)</li> </ol> <p>We support multiple different ways of doing this coincident alignment, including manually via user input, alignment with reference images, and feature detection (ml) based alignment (discussed later). You can also perform this correction manually in the user interface by centred a feature with double click in the electron beam, then centring the same feature with alt + double click in the ion beam (to move vertically).</p> <p>To start, we recommend you manually align the coincidence using the FIBSEM User Interface controls</p> <ol> <li>Double Click to centre feature in Electron Beam</li> <li>Alt + Double Click to centre feature in Ion Beam</li> </ol> <p>The feature should now be centred in both beams, and you are coincident.</p> <p>C. Move the Shuttle Down</p> <p>We move the shuttle down to avoid the manipulator making contact with the stage. All Fibsem stage positions are in the raw coordinate system (z positive is up). This coordinate system is independent of the linked (specimen) coordinate system, which is linked to the SEM working distance.</p> <pre><code>from fibsem.structures import FibsemStagePosition\n\n# move the stage down\nmicroscope.move_stage_relative(FibsemStagePosition(z=-2e-3))\n</code></pre> <p>D. Insert Manipulator</p> <p>We insert the manipulator to examine its condition. Depending on when your system was last used and the manipulator was calibrated, this position may vary a lot. We will calibrate the manipulator in the next few steps.</p> <pre><code># insert manipulator\nmicroscope.insert_manipulator(name=\"PARK\")\n</code></pre> <p>E. Prepare Manipulator Surface</p> <p>We mill the bottom surface of the manipulator flat to prepare for attaching the copper adaptor.</p> <p>We can define our milling protocol as follows:</p> <pre><code>prepare-manipulator:\n    application_file: autolamella\n    hfw: 0.00015\n    milling_current: 28.0e-9\n    milling_voltage: 30000\n    type: Rectangle\n    width: 25.0e-6\n    height: 2.50e-6\n    depth: 10.0e-6  \n</code></pre> <p>We can use the model to detect the manipulator tip, and then place our milling pattern</p> <pre><code># detect points in ion beam at low mag\nsettings.image.hfw = 400e-6\nsettings.image.beam_type = BeamType.ION\nfeatures = [NeedleTip()]\ndet = detection.take_image_and_detect_features(\n    microscope=microscope,\n    settings=settings,\n    features=features,\n)\n\n# offset detection, so we cut into manipulator\npoint = det.features[0].feature_m   # position of feature in metres (microscope image coordinates)\npoint.y -= 5e-6\npoint.x -= 5e-6\n\n# get milling stages from protocol\nstage = get_milling_stages(\"prepare-manipulator\", settings.protocol, point)\n\n# mill stages\nmilling.mill_stages(microscope, stages)\n</code></pre> <p>F. Manipulator Calibration</p> <p>We provide a manipulator calibration tool to assist in calibrating the EasyLift. Due to API limitations, the user still has to activate the calibration procedure in xTUI and then can follow the instructions in the tool to calibrate their EasyLift each day. The tool is available in the AutoLiftout UI via the Tools -&gt; Calibrate Manipulator menu.  The tool uses the machine learning model to calibrate the manipulator.</p> <pre><code>from fibsem import calibration\n\n# manipulator calibration\ncalibration._calibrate_manipulator_thermo(microscope, settings)\n</code></pre> <p>After calibrating, we can confirm our calibration was successful, by re-inserting to the saved positions, and checking the positions.</p> <pre><code>from fibsem.structures import FibsemStagePosition\n\n# make sure you move the stage down first\nmicroscope.move_stage_relative(FibsemStagePosition(z=-1e-3))\n\n# insert to parking position (~180um above stage)\nmicroscope.insert_manipulator(name=\"PARK\")\n\n# insert to eucentric position (centre of both beams)\nmicroscope.insert_manipulator(name=\"EUCENTRIC\")\n\n# retract manipulator\nmicroscope.retract_manipulator()\n</code></pre>"},{"location":"autolamella/case_study_serial_liftout/#step-2-3-clip-and-load-the-receiver-grid","title":"Step 2, 3 - Clip and Load the Receiver Grid","text":"<p>These steps clip and and load the receiver grid into the FIBSEM. This is not something we can help with at the moment :D.</p>"},{"location":"autolamella/case_study_serial_liftout/#step-4-copper-block-attachment","title":"Step 4 - Copper Block Attachment","text":"<p>The steps prepare the copper adaptor block, and attach it to the manipulator. Figures https://www.nature.com/articles/s41592-023-02113-5/figures/7 show the process.</p> <p>A. Mill Copper Bar</p> <p>We move to the milling orientation, and mill the grid bar to be ~20um thick.</p> <pre><code>prepare-copper-grid:\n    stages:\n    -   application_file: autolamella\n        hfw: 0.00015\n        milling_current: 28.0e-9\n        milling_voltage: 30000\n        type: Rectangle\n        width: 100.0e-6\n        height: 5.0e-6\n        depth: 30.0e-6\n</code></pre> <pre><code>import numpy as np\n\n# first move flat to electron\nmicroscope.move_flat_to_beam(BeamType.ELECTRON)\n\n# move to milling angle\nmilling_position = FibsemStagePosition(t=np.deg2rad(18))\nmicroscope.safe_absolute_stage_movement(milling_position)\n\n# get milling stages\nstages = get_milling_stages(\"prepare-copper-grid\", settings.protocol)\n\n# run milling \nmilling.mill_stages(microscope, stages)\n\n# save state for later return\nmilling_state = microscope.get_microscope_state()\n</code></pre> <p>B. Rotate Flat to Ion</p> <p>We rotate around flat to the ion beam.</p> <pre><code># move flat to ion\nmicroscope.move_flat_to_beam(BeamType.ION)\n</code></pre> <p>C. Mill Copper Blocks</p> <p>We mill a series of blocks into the copper bar, leaving them attached to each other on the side.</p> <pre><code>prepare-copper-blocks:\n    stages:\n    -   application_file: autolamella\n        hfw: 150.0e-6\n        milling_current: 28.0e-9\n        milling_voltage: 30000\n        depth: 10.0e-6\n        pitch_horizontal: 30.0e-6\n        height: 20.0e-6\n        width: 10.0e-6\n        type: ArrayPattern\n        passes: null\n        n_columns: 4.0\n        n_rows: 1.0\n        pitch_vertical: 0.0\n        scan_direction: TopToBottom\n    -   application_file: autolamella\n        hfw: 0.00015\n        milling_current: 28.0e-9\n        milling_voltage: 30000\n        type: Rectangle\n        width: 100.0e-6\n        height: 7.50e-6\n        depth: 10.0e-6\n</code></pre> <pre><code>from fibsem import utils, acquire\nfrom fibsem.patterning import get_milling_stages\nfrom fibsem.ui.utils import _draw_milling_stages_on_image \nfrom fibsem.structures import Point\n\n\n# acquire image for visualiation\nsettings.image.hfw = 150e-6\nimage = microscope.acquire_image(settings.image)\n\n# offset for top pattern\nh1 = settings.protocol[\"prepare-copper-blocks\"][\"stages\"][0][\"height\"]\nh2 = settings.protocol[\"prepare-copper-blocks\"][\"stages\"][1][\"height\"]\ndy = h1/2 - h2/2\npts = [Point(0, 0), Point(0, dy)]\n\n# get milling stages form protocol\nstages = get_milling_stages(\"prepare-copper-blocks\", settings.protocol, pts)\n\n# draw stages on image\nfig = _draw_milling_stages_on_image(image, stages)\n\n# run milling\nmilling.mill_stages(microscope, stages)\n</code></pre> <p>TODO: draw patterns</p> <p>D. Move back to Milling Orientation</p> <p>We restore the microscope, back to the milling orientation. If this position was coincident, it should still be coincident. Otherwise, align manually.</p> <pre><code># we restore our previously saved milling state\nmicroscope.set_microscope_state(milling_state)\n</code></pre> <p>E. Insert Maipulator</p> <p>We insert the manipulator, and move it onto one of the blocks. This moving is best done manually at this point.</p> <pre><code># insert manipulator\nmicroscope.insert_manipulator(name=\"PARK\")\n</code></pre> <p>F. Manipulator Contact</p> <p>We make contact with the block face. We can run another milling stage to polish the face to ensure they are flat.</p> <p>G. Attach the Block</p> <pre><code>prepare-copper-weld:\n    stages:\n    -   height: 2.5e-6\n        width: 0.5e-6\n        depth: 4.0e-6\n        pitch_horizontal: 1.0e-6\n        n_columns: 15\n        n_rows: 1\n        pitch_vertical: 0.0e-6\n        rotation: 0.0\n        passes: 1.0\n        milling_voltage: 30.0e+3\n        milling_current: 300.0e-12\n        hfw: 150.0e-6\n        application_file: \"autolamella\"\n        scan_direction: \"TopToBottom\"\n        type: \"ArrayPattern\"\n        preset: \"30 keV; 2.5 nA\"\n</code></pre> <p>H. Release the Block</p> <pre><code>prepare-copper-release:\n    stages:\n    -   application_file: autolamella\n        hfw: 150.0e-6\n        milling_current: 28.0e-9\n        milling_voltage: 30000\n        depth: 10.0e-6\n        pitch_horizontal: 30.0e-6\n        height: 20.0e-6\n        width: 5.0e-6\n        type: ArrayPattern\n        passes: null\n        n_columns: 2.0\n        n_rows: 1.0\n        pitch_vertical: 0.0\n        scan_direction: TopToBottom\n</code></pre> <p>I. Remove Manipulator</p> <pre><code># move manipulator up\nmicroscope.move_manipulator_corrected(dx=0, dy=10e-6, beam_type=BeamType.ION)\n</code></pre> <p>J. Retract Manipulator</p> <pre><code># retract manipulator\nmicroscope.retract_manipulator()\n</code></pre>"},{"location":"autolamella/case_study_serial_liftout/#step-5-prepare-the-receiver-grid","title":"Step 5 - Prepare the Receiver Grid","text":"<p>We prepare for the double sided attachment.</p> <pre><code>grid-lines:\n    cleaning_cross_section: 0\n    depth: 5.0e-05\n    height: 1.0e-6\n    width: 500.0e-06\n    hfw: 900.0e-6\n    milling_voltage: 30.0e+3\n    milling_current: 2.8e-08\n    rotation: 0.0\n    scan_direction: TopToBottom\n    application_file: \"autolamella\"\n    type: \"Rectangle\" # TODO: update to Line\n</code></pre> <pre><code># move flat to ion\nmicroscope.move_flat_to_beam(BeamType.ION)\n\n# get milling stages\nstages = get_milling_stages(\"grid-lines\", settings.protocol)\n\n# mill stages\nmilling.mill_stages(microscope, stages)\n</code></pre> <p>The manipulator and grid are now prepared.</p>"},{"location":"autolamella/case_study_serial_liftout/#trench-milling","title":"Trench Milling","text":""},{"location":"autolamella/case_study_serial_liftout/#steps-1-6-manual-setup","title":"Steps 1 - 6 Manual Setup","text":"<p>Steps 1 through 6 involve setting up the microscope, clearing contamination, platinum deposition and image correlation. At the moment these setup steps (focus and link, decontamination) are best performed manually  or not fully supported yet (correlation).</p>"},{"location":"autolamella/case_study_serial_liftout/#step-7-low-magnification-high-resolution-image-at-sem","title":"Step 7 - Low Magnification, High Resolution Image at SEM","text":"<p>You can use the movement and imaging api to move to the required orientations, and acquire reference images using the following:</p> <pre><code># move to imaging orientation -&gt; flat to electron\nmicroscope.move_flat_to_beam(BeamType.ELECTRON)\n\n# set imaging parameters\nsettings.image.beam_type = BeamType.ELECTRON\nsettings.image.resolution = [6144, 4096]\nsettings.image.dwell_time = 2e-6\nsettings.image.hfw = 2000e-6                            # size of grid\nsettings.image.filename = f\"ref_mapping_high_res_electron\" # filename\nsettings.image.save = True\n\n# acquire the image\nimage = acquire.new_image(microscope, settings.image)\n</code></pre>"},{"location":"autolamella/case_study_serial_liftout/#step-8-platinum-deposition","title":"Step 8 - Platinum Deposition","text":"<p>You can use the deposition api, but it was developed for a system that had a multi-chem, I haven't been able to test it on a regular gis system. You can also access the deposition tool via the AutoLamella UI -&gt; Tools -&gt; Cryo Deposition.</p> <p>Example cryo deposition api.</p> <pre><code>from fibsem import gis\n\n# define gis deposition protocol\ngis_protocol = {\n    \"application_file\": \"cryo_Pt_dep\",\n    \"gas\": \"Pt cryo\",\n    \"position\": \"cryo\",\n    \"hfw\": 3.0e-05 ,\n    \"length\": 7.0e-06,\n    \"beam_current\": 1.0e-8,\n    \"time\": 30.0,\n}\n\n# move to milling orientation -&gt; flat to ion\nmicroscope.move_flat_to_beam(BeamType.ION)\n\n# run cryo deposition at the current stage position\n# the stage will move down by 1mm to avoid collision before sputtering.\ngis.cryo_deposition(microscope, gis_protocol)\n\n# run cryo deposition at the a named stage position\n# You will need to define this named position through the Movement Tab (positions.yaml)\ngis.cryo_deposition(microscope, gis_protocol name=\"cryo-deposition-position\")\n</code></pre>"},{"location":"autolamella/case_study_serial_liftout/#step-9-low-magnification-high-resolution-image-post-platinum-deposition","title":"Step 9 - Low Magnification, High Resolution Image Post platinum deposition","text":"<p>We can also acquire images after platinum deposition.</p> <pre><code># move to imaging orientation -&gt; flat to electron\nmicroscope.move_flat_to_beam(BeamType.ELECTRON)\n\n# set imaging parameters\nsettings.image.beam_type = BeamType.ELECTRON\nsettings.image.resolution = [6144, 4096]\nsettings.image.dwell_time = 2e-6\nsettings.image.hfw = 2000e-6                                # size of grid\nsettings.image.filename = f\"ref_mapping_high_res_electron_pt\"  # filename\nsettings.image.save = True\n\n# acquire the image\nimage = acquire.new_image(microscope, settings.image)\n</code></pre>"},{"location":"autolamella/case_study_serial_liftout/#steps-10-11-correlation","title":"Steps 10 - 11 Correlation","text":"<p>At the moment, correlation is best performed using external software.</p> <p>You can acquire tilesets using the Minimap UI. It is available through the user interface -&gt; Tools -&gt; Open Minimap</p>"},{"location":"autolamella/case_study_serial_liftout/#step-12-move-to-trench-milling-orientation","title":"Step 12 - Move to Trench Milling Orientation","text":"<p>We can move to the trench milling orientation (flat to ion beam), with the following code:</p> <pre><code># move perpendicular to ion beam\nmicroscope.move_flat_to_beam(BeamType.ION)\n</code></pre>"},{"location":"autolamella/case_study_serial_liftout/#step-13-align-reference-image","title":"Step 13 - Align Reference Image","text":"<p>We can align the SEM reference image to the ION image with the following code.</p> <pre><code># load reference image\nref_image = FibsemImage.load(\"path/to/reference_image.tif\")\n\n# rotate the reference \nref_image_electron = image_utils.rotate_image(ref_image_electron)\n\n# acquire ion image using same imaging settings\nsettings.image = ImageSettings.fromFibsemImage(ref_image)\nsettings.image.beam_type = BeamType.ION\nnew_image = acquire.new_image(microscope, settings.image)\n\n# align reference\n# NOTE: there are additional options for masking, and changing filters available\nalignment.align_using_reference_images(microscope, settings, ref_image, new_image)\n</code></pre>"},{"location":"autolamella/case_study_serial_liftout/#step-14-align-features-coincident","title":"Step 14 - Align Features Coincident","text":"<p>To align the beams to the feature of interest is coincident, we can use the following steps:</p> <ol> <li>Detect a Feature in Electron Beam</li> <li>Move the Feature the centre of in Electron Beam (Stable Movement)</li> <li>Detect the Feature in the Ion Beam</li> <li>Move the stage vertically to move the Feature to the centre of the Ion Beam. (Vertical Movement)</li> </ol> <p>We support multiple different ways of doing this coincident alignment, including manually via user input, alignment with reference images, and feature detection (ml) based alignment (discussed later). You can also perform this correction manually in the user interface by centred a feature with double click in the electron beam, then centring the same feature with alt + double click in the ion beam (to move vertically).</p> <pre><code># example: pseudocode\n# we are flat to the ion and want to rotate around 180 to be flat to the electron. then we need to re-align coincidence.\n# assuming the beams were coincident prior to a rotation. We can take reference images before rotation, then cross align them after rotation to restore coincidence. \n# this is just pseudo code, real examples require more tuning and parameters to make it work repeatedly. For this reason, we prefer using the ml version.\n\n# acquire reference images\nref_image_electron, ref_image_ion = acquire.take_reference_images(microscope, settings.image)\n\n# rotate flat to electorn\nmicroscope.move_flat_to_beam(BeamType.ELECTRON)\n\n# acquire new images\nnew_image_electron, new_image_ion = acquire.take_reference_images(microscope, settings.image)\n\n# rotate references\nref_image_electron = image_utils.rotate_image(ref_image_electron)\nref_image_ion = image_utils.rotate_image(ref_image_ion)\n\n# stable movement (step 1, 2)\nalignment.align_using_reference_images(microscope, settings, ref_image_1, new_image_1)\n\n# vertical movement (step 3, 4)\nalignment.align_using_reference_images(microscope, settings, ref_image_2, new_image_2, constrain_vertical=True)\n\n# the beams should now be coincident again. \n</code></pre>"},{"location":"autolamella/case_study_serial_liftout/#step-14-region-of-interest","title":"Step 14 - Region of Interest","text":"<p>The region of interest is determined manually. Once the stage is moved to the correct position, we can save the state of the microscope with the following code:</p> <pre><code># save trench milling position\nmilling_state = microscope.get_microscope_state()\n\n# we can restore back to this position / state at any time using:\nmicroscope.set_microscope_state(milling_state)\n\n# we can also save the state to file, to be reloaded later\nutils.save_yaml(\"path/to/milling_state.yaml\", milling_state.to_dict())\n</code></pre>"},{"location":"autolamella/case_study_serial_liftout/#step-15-trench-milling","title":"Step 15 - Trench Milling","text":"<p>We can define the trench milling protocol as follows, we use a two stage milling protocol. The first stage mills the large trenches at high current, and the second polishes the contact surface.</p> protocol-serial-liftout.yaml<pre><code>trench:\n    stages:\n    -   depth: 25.0e-6\n        hfw: 400e-06\n        height: 180.0e-06\n        width: 4.5e-05\n        milling_voltage: 30.0e+3\n        milling_current: 3.0e-9\n        rotation: 0.0\n        scan_direction: TopToBottom\n        side_trench_width: 5.0e-06\n        top_trench_height: 30.0e-6\n        application_file: \"autolamella\"\n        type: \"HorseshoeVertical\"\n        preset: \"30 keV; 20 nA\"\n    -   depth: 25.0e-6\n        hfw: 8.0e-05\n        height: 2.5e-06\n        width: 4.5e-05\n        milling_voltage: 30.0e+3\n        milling_current: 300.0e-12\n        rotation: 0.0\n        scan_direction: TopToBottom\n        application_file: \"autolamella\"\n        type: \"Rectangle\"\n</code></pre> <p>We can then run the trench milling with the following code.</p> <pre><code>from fibsem import milling\nfrom fibsem.patterning import get_milling_stages\n\n# move the polishing pattern to the top of the volume block\npolishing_offset = Point(0, settings.protocol[\"trench\"][\"stages\"][0][\"height\"] / 2)\n\n# get milling stages from the protocol\nstages = get_milling_stages(\"trench\", settings.protocol, [None, polishing_offset])\n\n# run milling operations\nmilling.mill_stages(microscope, stages)\n</code></pre> <p>We can also draw the milling stages on an image to see them before milling. <pre><code>from fibsem.ui.utils import _draw_milling_stages_on_image\n\n# acquire image\nsettings.image.hfw = 400e-6\nsettings.image.beam_type = BeamType.ION\nimage = acquire.new_image(microscope, settings.image)\n\n# draw milling stages\nfig = _draw_milling_stages_on_image(image, stages)\n</code></pre></p>"},{"location":"autolamella/case_study_serial_liftout/#step-16-acquire-reference-image","title":"Step 16 - Acquire Reference Image","text":"<p>We can acquire the final trench reference images with the following code.</p> <pre><code># move to imaging orientation -&gt; flat to electron\nmicroscope.move_flat_to_beam(BeamType.ELECTRON)\n\n# set imaging parameters\nsettings.image.beam_type = BeamType.ELECTRON\nsettings.image.resolution = [6144, 4096]\nsettings.image.dwell_time = 2e-6\nsettings.image.hfw = 2000e-6                                # size of grid\nsettings.image.filename = f\"ref_trench_milling_final\"          # filename\nsettings.image.save = True\n\n# acquire the image\nimage = acquire.new_image(microscope, settings.image)\n</code></pre>"},{"location":"autolamella/case_study_serial_liftout/#liftout","title":"Liftout","text":"<p>The liftout steps attach the volume block to the manipulator, and extract it from the rest of the sample bulk.</p>"},{"location":"autolamella/case_study_serial_liftout/#steps-1-5-manual-setup","title":"Steps 1 - 5 Manual Setup","text":"<p>Similar to Trench milling, steps 1 to 5 should be completed manually.</p>"},{"location":"autolamella/case_study_serial_liftout/#step-6-restore-milling-state","title":"Step 6 - Restore Milling State","text":"<p>We can restore our previously saved milling position / state.</p> <pre><code># load milling state from disk\nmilling_state = utils.load_yaml(\"path/to/milling_state.yaml\")\n\n# restore microscope state\nmicroscope.set_microscope_state(milling_state)\n</code></pre>"},{"location":"autolamella/case_study_serial_liftout/#step-7-align-coincidence","title":"Step 7 - Align Coincidence","text":"<p>Now that we have a feature the model is trained for, we can use it to detect the feature (Volume Block) and align it in both beams to set the coincidence.</p> <p>We wrapped this up in a helper function, so we can re use it for any feature:</p> <pre><code># select feature\nfeature = VolumeBlockBottomEdge()\n\n# align feature so beams are coincident\nlamella = align_feature_coincident(microscope=microscope, \n                            settings=settings, \n                            hfw=400e-6,\n                            feature=feature)\n</code></pre> <p>The pseudo code for this function is below. The implemented function (with ui integration) is found in autolamella/workflows/core:align_feature_coincident</p> <pre><code>def align_feature_coincident(microscope: FibsemMicroscope, settings: MicroscopeSettings, \n                              hfw: float = fcfg.REFERENCE_HFW_MEDIUM,\n                              feature: Feature = LamellaCentre()) -&gt; Lamella:\n    \"\"\"Align the feature in the electron and ion beams to be coincident.\"\"\"\n\n    # bookkeeping\n    features = [feature]\n\n    # detect and align in electron\n    settings.image.hfw = hfw\n    settings.image.beam_type = BeamType.ELECTRON\n    det = detection.take_image_and_detect_features(\n        microscope=microscope,\n        settings=settings,\n        features=features,\n    )\n    microscope.stable_move(\n        dx=det.features[0].feature_m.x,\n        dy=det.features[0].feature_m.y,\n        beam_type=settings.image.beam_type\n    )\n\n    # Align ion so it is coincident with the electron beam\n    settings.image.beam_type = BeamType.ION\n    settings.image.hfw = hfw\n\n    det = detection.take_image_and_detect_features(\n        microscope=microscope,\n        settings=settings,\n        features=features,\n    )\n    # align vertical\n    microscope.vertical_move(\n        dx=det.features[0].feature_m.x,\n        dy=-det.features[0].feature_m.y,\n    )\n\n    # reference images\n    settings.image.save = True\n    settings.image.hfw = hfw\n    settings.image.filename = f\"ref_{feature.name}_align_coincident_final\"\n    eb_image, ib_image = acquire.take_reference_images(microscope, settings.image)\n\n    return\n</code></pre>"},{"location":"autolamella/case_study_serial_liftout/#step-8-remove-contamination-from-manipulator","title":"Step 8 - Remove contamination from manipulator","text":"<p>It is recommended to mill away any contaminants that would have accumulated during storage.</p>"},{"location":"autolamella/case_study_serial_liftout/#step-9-insert-the-manipulator","title":"Step 9 - Insert the Manipulator","text":"<p>Insert the manipulator to the park position</p> <pre><code>microscope.insert_manipulator(\"PARK\")\n</code></pre>"},{"location":"autolamella/case_study_serial_liftout/#step-10-move-the-manipulator-to-make-contact","title":"Step 10 - Move the manipulator to make contact","text":"<p>We now need to guide the manipulator to make contact with the surface. We first align the features in the electron beam, and then in the ion. We iteratively align the manipulator using the Ion beam to ensure good contact.</p> <p>Note: The current serial liftout dataset doesn't have many images from this part of the workflow, so it will likely perform poorly. If you would like to contribute data for this part (or any part of the workflow), please contact patrick@openfibsem.org.</p> <p>We use the helper function move_based_on_detection to apply the correct transformations to move the desired system (in this case the manipulator) based on the detected features.</p> <pre><code>    settings.image.beam_type = BeamType.ELECTRON\n    settings.image.hfw = 400e-6\n\n    # DETECT COPPER ADAPTER, VOLUME TOP\n    scan_rotation = microscope.get(\"scan_rotation\", beam_type=BeamType.ION)\n    features = [CopperAdapterTopEdge(), VolumeBlockBottomEdge()] if np.isclose(scan_rotation, 0) else [CopperAdapterBottomEdge(), VolumeBlockTopEdge()]\n\n    det = detection.take_image_and_detect_features(\n        microscope=microscope,\n        settings=settings,\n        features=features,\n    )\n    # MOVE TO VOLUME BLOCK TOP\n    detection.move_based_on_detection(\n        microscope, settings, det, beam_type=settings.image.beam_type, move_x=True,\n         _move_system=\"manipulator\"\n    )\n\n    # align manipulator to top of lamella in ion x3\n    HFWS = [400e-6, 150e-6, 80e-6]\n\n    for i, hfw in enumerate(HFWS):\n\n\n        settings.image.beam_type = BeamType.ION\n        settings.image.hfw = hfw\n\n        # DETECT COPPER ADAPTER, LAMELLA TOP\n        scan_rotation = microscope.get(\"scan_rotation\", beam_type=BeamType.ION)\n        features = [CopperAdapterTopEdge(), VolumeBlockBottomEdge()] if np.isclose(scan_rotation, 0) else [CopperAdapterBottomEdge(), VolumeBlockTopEdge()]\n\n        det = detection.take_image_and_detect_features(\n            microscope=microscope,\n            settings=settings,\n            features=features,\n        )\n\n        # MOVE TO VOLUME BLOCK TOP\n        detection.move_based_on_detection(\n            microscope, settings, det, beam_type=settings.image.beam_type, move_x=True, \n            _move_system=\"manipulator\"\n        )\n</code></pre>"},{"location":"autolamella/case_study_serial_liftout/#step-11-attach-the-copper-block-to-the-volume","title":"Step 11 - Attach the Copper Block to the Volume","text":"<p>Once attached, we detect the copper adaptor interface, and mill the weld pattern.</p> <pre><code>liftout-weld:\n    height: 2.5e-6\n    width: 0.5e-6\n    depth: 4.0e-6\n    pitch_horizontal: 0.75e-6\n    n_columns: 10\n    n_rows: 1\n    pitch_vertical: 0.0e-6\n    rotation: 0.0\n    passes: 1.0\n    milling_voltage: 30.0e+3\n    milling_current: 300.0e-12\n    hfw: 150.0e-6\n    application_file: \"autolamella\"\n    scan_direction: \"BottomToTop\"\n    type: \"ArrayPattern\"\n    preset: \"30 keV; 2.5 nA\"\n</code></pre> <pre><code>features = [VolumeBlockBottomEdge() if np.isclose(scan_rotation, 0) else VolumeBlockTopEdge()] \ndet = detection.take_image_and_detect_features(\n    microscope=microscope,\n    settings=settings,\n    features=features,\n)\n\n# move the pattern to the top of the volume (i.e up by half the height of the pattern)\npoint = det.features[0].feature_m \npoint.y += settings.protocol[\"milling\"][\"liftout-weld\"].get(\"height\", 5e-6) / 2 \n\n# get weld milling stages\nstages = milling.get_milling_stages(\"liftout-weld\", settings.protocol[\"milling\"], point)\n\n# mill stages\nmilling.mill_stages(microscope=microscope, stages=stages)\n</code></pre>"},{"location":"autolamella/case_study_serial_liftout/#step-12-14-sever-the-volume-block","title":"Step 12 - 14 - Sever the Volume Block","text":"<p>We mill the severing pattern as follows:</p> <pre><code>liftout-sever:\n    cleaning_cross_section: 0.0\n    depth: 10.0e-06\n    height: 0.5e-06\n    hfw: 400.0e-6\n    milling_voltage: 30.0e+3\n    milling_current: 1.0e-9\n    rotation: 0.0\n    scan_direction: TopToBottom\n    width: 50.0e-06\n    application_file: \"autolamella\"\n    type: \"Rectangle\"\n    preset: \"30 keV; 20 nA\"\n</code></pre> <p>Detect the base of the volume block, and sever it from the sample.</p> <pre><code># detect points in ion beam\nsettings.image.hfw = 400e-6\nsettings.image.beam_type = BeamType.ION\nfeatures = [VolumeBlockTopEdge() if np.isclose(scan_rotation, 0) else VolumeBlockBottomEdge()] \ndet = detection.take_image_and_detect_features(\n    microscope=microscope,\n    settings=settings,\n    features=features,\n)\n\n# get the point\npoint = det.features[0].feature_m \n\n\n# get weld milling stages\nstages = milling.get_milling_stages(\"liftout-sever\", settings.protocol[\"milling\"], point)\n\n# mill stages\nmilling.mill_stages(microscope=microscope, stages=stages)\n</code></pre> <p>It is recommended by the authors to move the volume up slightly to check it is dettached from the sample. If not, repeat the severing.</p>"},{"location":"autolamella/case_study_serial_liftout/#step-15-extract-the-volume-from-the-trench","title":"Step 15 - Extract the Volume from the trench","text":"<p>We slowly retract the volume from the sample plane. We use corrected movements to isolate this movement to the z-plane (dy in Ion)</p> <pre><code># retract slowly at first\nfor i in range(10):\n    microscope.move_manipulator_corrected(dx=0, dy=1e-6, beam_type=BeamType.ION)\n    if i % 3 == 0:\n        settings.image.filename = f\"ref__manipulator_removal_slow_{i:02d}\"\n        eb_image, ib_image = acquire.take_reference_images(microscope, settings.image)\n    time.sleep(1)\n\n# then retract more\nfor i in range(3):\n    microscope.move_manipulator_corrected(dx=0, dy=20e-6, beam_type=BeamType.ION)\n    settings.image.filename = f\"ref__manipulator_removal_{i:02d}\"\n    eb_image, ib_image = acquire.take_reference_images(microscope, settings.image)\n    time.sleep(1)\n</code></pre>"},{"location":"autolamella/case_study_serial_liftout/#step-16-17-retract-the-manipulator","title":"Step 16 - 17 - Retract the manipulator","text":"<pre><code>microscope.retract_manipulator()\n</code></pre>"},{"location":"autolamella/case_study_serial_liftout/#landing","title":"Landing","text":"<p>The landing steps attach the lamella to the landing grid, and sever it from the rest of the volume block.</p>"},{"location":"autolamella/case_study_serial_liftout/#step-1-setup-stage","title":"Step 1 - Setup Stage","text":"<p>\"Move the stage to position the receiver grid in the field of view.\"</p> <p>We can restore to a previously saved position, such a starting position by first saving it, and then restoring it by name.</p> <p>To save and restore a position:</p> <pre><code>## save position\n# get the current stage position\nstage_position = microscope.get_stage_position()\n\n# give your position a name\nstage_position.name = \"my-position-grid-01\"\n\n# save position to positions.yaml\n# default path: fibsem/config/positions.yaml\nutils.save_positions([stage_position])\n\n## restore position\n# you can restore these positions by loading the position by name:\nstage_position = utils._get_position(\"my-position-grid-01\")\n\n# move to position (safely)\nmicroscope.safe_absolute_stage_movement(stage_position)\n</code></pre>"},{"location":"autolamella/case_study_serial_liftout/#step-2-move-to-landing-orientation","title":"Step 2 - Move to Landing Orientation","text":"<p>\"Set the stage to lamella milling orientation (0\u00b0 relative rotation to loading angle, 18\u00b0 stage tilt) and adjust the stage rotation to make sure that the pins or 400 mesh grid bars are aligned vertical.\"</p> <p>We can restore to a previously defined position as shown before. In the autolamella application, the landing orientation is defined in the protocol as options/landing_start_position. You can define this position as shown above, or via the Movement Tab.</p> protocol-serial-liftout.yaml<pre><code>options:\n    landing_start_position: pre-tilt-35-deg-grid-02-landing\n</code></pre>"},{"location":"autolamella/case_study_serial_liftout/#step-3-setup-landing-positions","title":"Step 3 - Setup Landing Positions","text":"<p>\"Set up the coincidence points for all positions to be used for section attachment. Place them in the middle of the field of view and save the positions. If corrections of rotation are necessary to have perfectly vertically running 400-mesh grid bars or pins, perform them during this step and save them with the stage positions. Note: assuming the receiver grid is perfectly loaded, saving a single coincidence point per row may suffice.\"</p> <p>We will break this up into the following steps:</p> <ol> <li>Select initial landing position</li> <li>Generate landing position grid</li> </ol> <p>We will generate a grid of landing positions, based on these protocol values.</p> <pre><code>options:\n    landing_grid:\n        x: 100.0e-6     # grid spacing in x\n        y: 400.0e-6     # grid spacing in y\n        rows: 4         # number of rows to generate\n        cols: 10        # number of columns to generate\n</code></pre> <pre><code>def generate_landing_positions(microscope, settings) -&gt; list[FibsemStagePositions]:\n    \"\"\"Generate a grid of landing positions starting at the top left corner. Positions are \n    generated along the sample plane, based on the current orientation of the stage.\"\"\"\n\n    # base state = top left corner\n    base_state = microscope.get_microscope_state()\n\n    # get the landing grid protocol\n    landing_grid_protocol = settings.protocol[\"options\"][\"landing_grid\"]\n    grid_square = Point(landing_grid_protocol['x'], landing_grid_protocol['y'])\n    n_rows, n_cols = landing_grid_protocol['rows'], landing_grid_protocol['cols']\n\n    positions = []\n\n    for i in range(n_rows):\n        for j in range(n_cols):\n            _new_position = microscope.project_stable_move( \n                dx=grid_square.x*j, \n                dy=-grid_square.y*i, \n                beam_type=BeamType.ION, \n                base_position=base_state.stage_position)            \n\n            # position name is number of position in the grid\n            _new_position.name = f\"Landing Position {i*n_cols + j:02d}\"\n\n            positions.append(_new_position)\n\n    return positions\n</code></pre> <p>TODO: show generated grid</p> <p>Once we have selected our initial landing position, we can generate this grid of landing positions as follows:</p> <pre><code># user moves to initial landing position\ninitial_landing_position = \n\n# generate landing positions\npositions = generate_landing_positions(microscope, settings)\n\n# save landing positions to file\nutils.save_positions(\"path/to/saved-landing-positions.yaml\")\n</code></pre> <p>As these generated positions use the stable movement api (stage moves along the sample plane, coincidence is maintained), the positions should be relatively coincident across the entire grid. However, sample variation and damage to the grid can mean that the sample plane is not completely flat, breaking this assumption.</p>"},{"location":"autolamella/case_study_serial_liftout/#step-4-move-to-landing-position","title":"Step 4 - Move to Landing Position","text":"<p>\"Go back to the first section attachment position\"</p> <p>This is the point we begin the landing workflow. The initial landing position is selected during setup, and then we use the generated landing position.  </p> <pre><code>def create_lamella(microscope, experiment: Experiment, positions: list) -&gt; Lamella:\n    \"\"\"Create a new lamella object, ready for landing at the next available landing position\"\"\"\n\n    # create a new lamella \n    num = max(len(experiment.positions) + 1, 1)\n    lamella = Lamella(experiment.path, num)\n\n    # get the number of previously landed lamella\n    _counter = Counter([p.state.stage.name for p in experiment.positions])\n    land_idx = _counter[AutoLamellaStage.LandLamella.name]\n\n    # set the state of the lamella, ready for landing\n    lamella.state.stage = AutoLamellaStage.LiftoutLamella\n    lamella.state.microscope_state = microscope.get_microscope_state()\n    lamella.state.microscope_state.stage_position = deepcopy(positions[land_idx])\n    lamella.landing_state = deepcopy(lamella.state.microscope_state)\n\n    return lamella\n\ndef landing_workflow(microscope, settings, experiment) -&gt; Experiment:\n\n    # generated positions\n    positions = utils._get_positions(\"path/to/saved-landing-positions.yaml\")\n\n    # continue landing until exhausted\n    continue_landing = True\n\n    while continue_landing:\n\n        # create a new lamella position\n        lamella = create_lamella(microscope, experiment, positions)\n\n        # land lamella\n        lamella = land_lamella(\n            microscope=microscope,\n            settings=settings,\n            lamella=lamella,\n        )\n\n        # continue with landing if user confirms, and enough material\n        continue_landing = (\n            ask_user(f\"Continue Landing?\") and\n            validate_volume_block_size(microscope, settings)\n        )\n</code></pre>"},{"location":"autolamella/case_study_serial_liftout/#step-5-insert-manipulator","title":"Step 5 - Insert Manipulator","text":"<p>\"Re-insert the needle to which the extracted volume is attached.\"</p> <pre><code># insert manipulator to park position (high above landing grid)\nmicroscope.insert_manipulator(name=\"PARK\")\n</code></pre>"},{"location":"autolamella/case_study_serial_liftout/#step-6-","title":"Step 6 -","text":"<p>\"Lower the needle so that the extracted volume is about 10 \u00b5m above the first position.\"</p> <p>We break this down into the following steps:</p> <ol> <li>Detect the bottom of the volume block, and the centre of the landing grid. Landing grid refers to the individual landing grid we intend to land on.</li> <li>Set an offset of 10um between these two points</li> <li>Move the manipulator by the distance between these two points.</li> </ol> <pre><code># detect points in ion beam at low mag\nsettings.image.hfw = 400e-6\nsettings.image.beam_type = BeamType.ION\nfeatures = [VolumeBlockBottomEdge(), LandingGridCentre()]\ndet = detection.take_image_and_detect_features(\n    microscope=microscope,\n    settings=settings,\n    features=features,\n)\n\n# set the offset y=10um\ndet._offset = Point(0, -10e-6)\n\n# move based on detection\ndetection.move_based_on_detection(microscope, settings, det, beam_type=BeamType.ION)\n</code></pre>"},{"location":"autolamella/case_study_serial_liftout/#step-7-position-extraction-volume","title":"Step 7 - Position Extraction Volume","text":"<p>\"Position the extracted volume using the SEM channel. a. For double-sided attachment, adjust y to align the leading edge of the volume with the previously milled line pattern and adjust x to place the volume precisely between the two grid bars. \"</p> <pre><code># detect points in electron beam at low mag\nsettings.image.hfw = 150e-6\nsettings.image.beam_type = BeamType.ELECTRON\nfeatures = [VolumeBlockBottomEdge(), LandingGridCentre()]\ndet = detection.take_image_and_detect_features(\n    microscope=microscope,\n    settings=settings,\n    features=features,\n)\n\n# move based on detection\ndetection.move_based_on_detection(microscope, settings, det, beam_type=BeamType.ELECTRON)\n</code></pre>"},{"location":"autolamella/case_study_serial_liftout/#step-8-lower-extraction-volume","title":"Step 8 - Lower Extraction Volume","text":"<p>\"Lower the extraction volume into place by adjusting z. Use the FIB channel as guidance. Double-check intermittently for alignment with line/corner landmarks using the SEM channel. a. For double sided attachment: i. If the extraction volume is too wide to fit between the grid bars, mill off excess material using regular cross sections or patterns (30kV, 300 pA). The extracted volume should fit close to perfectly into the mesh. ii. Align the lower front edge of the extraction volume with the previously milled line.\"</p> <p>We break this down into the following steps:</p> <ol> <li>Check the size of the volume block and the landing grid.</li> <li>If larger, mill the sides away. If not, continue.</li> <li>Detect the bottom edge of the volume block, and the centre of the landing grid.</li> <li>Move the manipulator down based on the detection (z-axis only).</li> </ol> <pre><code># check volume block size\n# see if wider than grid bars gap \n# TODO:\n\n# detect points in electron beam at low mag\nsettings.image.hfw = 150e-6\nsettings.image.beam_type = BeamType.ION\nfeatures = [VolumeBlockBottomEdge(), LandingGridCentre()]\ndet = detection.take_image_and_detect_features(\n    microscope=microscope,\n    settings=settings,\n    features=features,\n)\n\n# move based on detection\ndetection.move_based_on_detection(microscope, settings, det, move_x=False, beam_type=BeamType.ION)\n</code></pre>"},{"location":"autolamella/case_study_serial_liftout/#step-9-landing-attachment","title":"Step 9 - Landing Attachment","text":"<p>\"Attach the extracted volume to the grid bars by redposition milling. Place the milling start of the patterns at on the interface of the grid bar and extraction volume.\"</p> <p>\"For double-sided attachment mill on both adjacent grid bars for attachment. Mill a vertical array of regular cross-sections (single pass, width 4.0 \u00b5m, height 0.5 \u00b5m, zdepth 10 \u00b5m, vertical spacing 0.25 \u00b5m, 30 kV, 1 nA) directed away from the extracted volume.\"</p> <p>We break this down into the following steps:</p> <ol> <li>Detect corners of the volume block</li> <li>Offset them by the height we want our lamella</li> <li>Get milling stages from protocol</li> <li>Mill the welds</li> </ol> <p>First we need to define our weld milling protocol. We already support these kind of milling patterns, under the type \"Spot Weld\". A spot weld consists of a set of equally horizontal patterns, and is used as the name suggests for redeposition welds. Similar to attaching the  volume block to the adapter, setting passes = 1 is important so we don't mill over our redeposited material.</p> protocol-serial-liftout.yaml<pre><code>landing-weld:\n    stages:\n    # left weld\n    -   height: 0.5e-6\n        width: 4.0e-6\n        depth: 10.0e-6\n        pitch_vertical: 0.25e-6\n        n_rows: 5\n        n_columns: 1\n        pitch_horizontal: 0\n        rotation: 0.0\n        passes: 1.0\n        milling_current: 300.0e-12\n        milling_voltage: 1.0e-9\n        hfw: 150.0e-6\n        application_file: \"autolamella\"\n        scan_direction: \"RightToLeft\"\n        type: \"ArrayPattern\"\n    # right weld\n    -   height: 0.5e-6\n        width: 4.0e-6\n        depth: 10.0e-6\n        pitch_vertical: 0.25e-6\n        n_rows: 5\n        n_columns: 1\n        pitch_horizontal: 0\n        rotation: 0.0\n        passes: 1.0\n        milling_current: 300.0e-12\n        milling_voltage: 1.0e-9\n        hfw: 150.0e-6\n        application_file: \"autolamella\"\n        scan_direction: \"LeftToRight\"\n        type: \"ArrayPattern\"\n</code></pre> <p>This protocol gives us the following milling patterns.</p> <p>We can now write the code for detecting the corners, offseting the patterns, and milling the welds.</p> <pre><code># detect points in ion beam\nsettings.image.beam_type = BeamType.ION\nfeatures = [VolumeBlockBottomLeftCorner(), VolumeBlockBottomRightCorner()]\ndet = detection.take_image_and_detect_features(\n    microscope=microscope,\n    settings=settings,\n    features=features,\n)\n\n# get the points\nleft_corner = det.features[0].feature_m \nright_corner = det.features[1].feature_m\n\n# add some offset in y\nv_offset = 2e-6  # half of recommended 4um height (step 11)\nleft_corner.y  +=  v_offset\nright_corner.y +=  v_offset\n\n# get weld milling stages\nstages = milling.get_milling_stages(\"weld\", settings.protocol, [left_point, right_point])\n\n# mill stages\nmilling.mill_stages(microscope=microscope, stages=stages)\n</code></pre>"},{"location":"autolamella/case_study_serial_liftout/#step-10-move-manipulator","title":"Step 10 - Move Manipulator","text":"<p>\"Move the needle up by a step of 50-100 nm to create strain.\"</p> <pre><code># move manipulator up 50-100 nm to create strain\ndy = 100e-9\nmicroscope.move_manipulator_corrected(dx=0, dy=dy, beam_type=BeamType.ION)\n</code></pre>"},{"location":"autolamella/case_study_serial_liftout/#step-11-release-section","title":"Step 11 - Release Section","text":"<p>\"Release the section by milling a line pattern across the extracted volume at the desired sectioning distance from the lower edge of the extracted volume (30kV, 1 nA, z-depth 20 \u00b5m). Sectioning at 4 \u00b5m is recommended to begin with, but sections down to 1 \u00b5m can be obtained.\"</p> <p>We break this down into the following steps:</p> <ol> <li>Detect bottom edge of the volume block</li> <li>Offset them by the height we want our lamella</li> <li>Get milling stages from protocol</li> <li>Mill the sever</li> </ol> <p>Milling protocol</p> protocol-serial-liftout.yaml<pre><code>landing-sever:\n    cleaning_cross_section: 0.0\n    depth: 20.0e-06\n    height: 0.25e-06\n    hfw: 150.0e-6\n    milling_current: 1.0e-09\n    milling_voltage: 30.0e+3\n    rotation: 0.0\n    scan_direction: LeftToRight\n    width: 50.0e-06\n    application_file: \"autolamella\"\n    type: \"Rectangle\" # TODO: change to Line\n</code></pre> <pre><code># detect points, in ion beam\nsettings.image.beam_type = BeamType.ION\nfeatures = [VolumeBlockBottomEdge()]\ndet = detection.take_image_and_detect_features(\n    microscope=microscope,\n    settings=settings,\n    features=features,\n)\n\n# add some offset in y\nv_offset = 4e-6  # recommended 4um height \npoint = det.features[0].feature_m\npoint.y += v_offset\n\n# get weld milling stages\nstages = milling.get_milling_stages(\"landing-sever\", settings.protocol, point)\n\n# mill stages\nmilling.mill_stages(microscope=microscope, stages=stages)\n</code></pre>"},{"location":"autolamella/case_study_serial_liftout/#step-12-validate-release","title":"Step 12 - Validate Release","text":"<p>\"Check whether the section has been released by moving the needle up by 1-3 steps of 50 nm. If the section moves with the needle, repeat the line pattern milling.\"</p> <p>We break this down into the following steps</p> <ol> <li>Move the manipulator up by 50-100nm.</li> <li>Detect the bottom edge of the volume block, and the top edge of the lamella.</li> <li>Measure the distance between these points</li> <li>If the distance is greater than threshold continue. If not, repeat the milling.</li> </ol> <pre><code>confirm_sever = False\nwhile confirm_sever is False:\n\n    # Step 11 - Mill Sever \n    # HERE\n\n    # move the manipulator up a small amount\n    for i in range(3):\n        microscope.move_manipulator_corrected(dx=0, dy=50e-9, beam_type=BeamType.ION)\n\n    # detect the distance between volume block and lamella\n    settings.image.beam_type = BeamType.ION\n    features = [VolumeBlockBottomEdge(), LamellaTopEdge()]\n    det = detection.take_image_and_detect_features(\n        microscope=microscope,\n        settings=settings,\n        features=features,\n    )\n\n    # check if the distance is greater than threshold \n    threshold = 0.5e-6\n    confirm_sever = (abs(det.distance.y) &gt; threshold)\n\n# Step 13 - Move Manipulator up\n</code></pre>"},{"location":"autolamella/case_study_serial_liftout/#step-13-move-manipulator-up","title":"Step 13 - Move Manipulator Up","text":"<p>\"Once the section is released, carefully maneuver the extraction volume up. As soon as there is some distance to the section (~1 \u00b5m), increase the step size or jog. Move the volume up slightly below the edge of the FIB image in lowest magnification\"</p> <pre><code># move up slowly\ndy = 100e-9\nfor i in range(20):\n    microscope.move_manipulator_corrected(dx=0, dy=dy, beam_type=BeamType.ION)\n\n# move up\nmicroscope.move_manipulator_corrected(dx=0, dy=100e-6, beam_type=BeamType.ION) # question: is this too much force?\n</code></pre>"},{"location":"autolamella/case_study_serial_liftout/#step-14-retract-manipulator","title":"Step 14 - Retract Manipulator","text":"<p>\"Retract the needle\".</p> <pre><code># retract the manipulator\nmicroscope.retract_manipulator()\n</code></pre>"},{"location":"autolamella/case_study_serial_liftout/#step-15-repeat","title":"Step 15 - Repeat","text":"<p>*\"Move the stage to the next section attachment position and continue from step 5. Repeat this, until the extracted volume has been completely sectioned.\"</p> <p>At this point we would end our workflow stage, and continue to the next landing position to repeat the next landing.</p> <p>We also need to develop an automated stopping condition, to determine when the \"volume has been completely sectioned\". Again we can use the model to measure the remaining volume.</p> <p>We break down this down into the following steps:</p> <ol> <li>Assume the manipulator is inserted, or we are at a position where we can see the entire volume block. For example, at the start of the landing workflow after the manipulator is inserted.</li> <li>Detect the bounding box of the volume block.</li> <li>Measure the size of the volume block bounding box</li> <li>If the size is above a threshold, we continue to land more. If below, the volume block has been exhausted, and we need to clean the adapter and reset.</li> </ol> <pre><code>def validate_volume_block_size(microscope, settings) -&gt; bool:\n    \"\"\"Validates if the volume block has enough material to continue landing\"\"\"\n\n    # detect volume block features at low mag in ion beam\n    settings.image.hfw = 400e-6\n    settings.image.beam_type = BeamType.ION\n    features = [VolumeBlockTopEdge(), VolumeBlockBottomEdge()]\n    det = detection.take_image_and_detect_features(\n        microscope=microscope,\n        settings=settings,\n        features=features,\n    )\n\n    # get distance\n    volume_block_height = abs(det.distance.y) # distance between features\n\n    # check threshold\n    threshold = settings.protocol[\"options\"].get(\"minimum_volume_size\", 10e-6)\n\n    continue_landing\n    if volume_block_height &gt;= threshold:\n        continue_landing = True\n\n    return continue_landing\n</code></pre>"},{"location":"autolamella/case_study_serial_liftout/#section-thinning","title":"Section Thinning","text":"<p>After this point, you can use the standard autolamella workflow to thin and polish your lamella. If you ran serial liftout through the user interface, it will automatically prompt you to continue the workflow. All the landing positions are saved, and assoicated so you can quickly setup your thinning patterns and continue.</p>"},{"location":"autolamella/competition/","title":"Competition","text":""},{"location":"autolamella/features/","title":"Features","text":""},{"location":"autolamella/features/#minimap","title":"Minimap","text":"<p>The minimap tool allows the user to create a map of a cryo-EM grid as a whole at high resolution to allow for easy navigation and selection of possible lamellae locations. The minimap is created by taking a grid of high resolution images from either the SEM or FIB and stitching the images together to form a map. The minimap tool can be accessed from the tools menu.</p> <p></p> <p>The minimap tool opens in a seperate window, where the user can select the grid size and the tile size. The tile size is the size of the image taken for each subsection to form the whole grid. Once the parameters have been set, click run tile collection to run the process</p> <p></p> <p>Once the minimap is created, positions can be added and correlated. From here, you can also move to the selected position by clicking move to position. </p> <p></p> <p>A more detailed and in depth follow through of the minimap can be found in this video</p>"},{"location":"autolamella/features/#supervision","title":"Supervision","text":"<p>The supervision parameter outlines how much of the process can be user supervised. The example outlined shows the process being fully supervised. This ensures that the user has control of milling parameters before running, detected features and the ability to redo milling if necessary.</p> <p>The process can be done fully unsupervised if required. You may also selectively supervise and unsupervise relevant stages as necessary. In the protocol tab under supervision, the supervision checkbox can be set for each stage.</p> <p></p>"},{"location":"autolamella/features/#workflows","title":"Workflows","text":"<p>As outlined in the walkthrough, there are two main workflows available. The standard autolamella workflow labelled as Default and the waffle method labelled as Waffle.</p> <p>With the default method, the lamellae are milled in a standard fashion. The waffle method involves milling trenches in a way to allow for undercuts to be performed. Once the trenches are milled, the undercuts are performed and the lamellae are milled in the same fashion as the default method.</p>"},{"location":"autolamella/features/#time-travel","title":"Time Travel","text":"<p>The time travel feature allows the user to bring the lamella back to any of its previous states, to allow for repetition of any part of the process. </p>"},{"location":"autolamella/features/#lamella-protocol","title":"Lamella Protocol","text":"<p>Protocol walkthrough </p>"},{"location":"autolamella/features/#statistics-data-and-logging","title":"Statistics, Data and Logging","text":"<p>The tools folder in the project directory contains a number of useful tools for analysing data and logging. The stats.py file allows the user to generate statistics from the data collected during the autolamella process. The stats.py file can be run from the command line using the following command:</p> <p>streamlit run stats.py</p> <p>The experiments analytics include information about the following:</p> <ul> <li>The number of lamellas that went through each stage of the process ( Trenches, Undercut, Polish) </li> <li>The experiment timeline </li> <li>The duration of each step with reference images  </li> <li>Each lamella's history  </li> </ul>"},{"location":"autolamella/getting_started/","title":"Getting Started","text":""},{"location":"autolamella/getting_started/#installation","title":"Installation","text":"<p>To install autolamella:</p> <pre><code>conda create -n fibsem python=3.9 pip\nconda activate fibsem\npip install autolamella\n</code></pre> <p>This will also install the openfibsem dependency.</p> <p>Alternatively, installing the napari plugin with pip or through the napari plugin manager, will install autolamella.</p> <pre><code>pip install napari-openfibsem\n</code></pre>"},{"location":"autolamella/getting_started/#microscope-configuration","title":"Microscope Configuration","text":"<p>Please see the OpenFIBSEM API Getting Started for details about configuring your microscope.</p>"},{"location":"autolamella/getting_started/#protocols","title":"Protocols","text":"<p>The protocol file defines everything about the workflow. This includes the method, machine learning parameters, workflow options, and the milling configurations.</p> <p>We provide individual baseline protocols for each method:</p> <ul> <li>autolamella-on-grid: protocol-on-grid.yaml</li> <li>autolamella-waffle: protocol-waffle.yaml</li> <li>autolamella-autoliftout: protocol-autoliftout-base.yaml</li> <li>autolamella-serial-liftout: protocol-serial-liftout.yaml</li> </ul> <p>It is recommended that you start with either the on-grid or waffle method in supervised mode to test everything is working correctly.  </p> <p>For details about the protocol options, please see Protocol Structure below. For details about milling configurations, please see the Milling API.</p>"},{"location":"autolamella/getting_started/#running-autolamella","title":"Running AutoLamella","text":"<p>Once you have configured your microscope, and have a protocol selected, you are ready to run AutoLamella.</p> <p>To run autolamella:</p> <pre><code>autolamella_ui\n</code></pre> <p>To run the liftout methods (these will be merged into the main user interface eventually):</p> <pre><code>autoliftout_ui\n</code></pre> <p>Or launch via napari plugin manager: Napari -&gt; Plugins -&gt; Napari OpenFIBSEM -&gt; AutoLamella UI</p>"},{"location":"autolamella/getting_started/#user-guide","title":"User Guide","text":"<p>The following steps show the basic walkthrough for starting autolamella. The waffle method is used as an example.</p> <p>For a detailed walkthrough on each method please see AutoLamella Walkthrough.</p> <p> AutoLamella - Start Screen</p> <p> AutoLamella - Microscope Connected</p> <p> AutoLamella - Create Experiment</p> <p> AutoLamella - Name Experiment</p> <p> AutoLamella - Select Protocol</p> <p> AutoLamella - Protocol UI</p> <p> AutoLamella - Ready to Start</p> <p> AutoLamella - Add Lamella</p> <p> AutoLamella - Trench Ready</p> <p>From here you can follow the instructions at the bottom right of the screen, and they will walk you through the workflow.</p>"},{"location":"autolamella/getting_started/#protocol-structure","title":"Protocol Structure","text":"<p>The following is the entire protocol structure for all methods. Each method uses a subset of the configuration listed here. </p> <pre><code># protocol\noptions:\n    name: autolamella-waffle-mouse-scan-rotation-0deg                   # descriptive name of the protocol\n    method: autolamella-waffle                                          # protocol method (see supported methods)\n    ml-checkpoint: autolamella-waffle-20240107.pt                       # machine learning checkpoint to use (see supported models)\n    use_microexpansion: false                                           # mill the microexpansion patterns (stress relief)\n    use_notch: true                                                     # mill the notch pattern (stress relief)\n    alignment_attempts: 3.0                                             # the max number alignment repeat attempts\n    alignment_at_milling_current: true                                  # whether to align at the milling or imaging current\n    take_final_reference_images: true                                   # acquire reference images after final polishing\n    high_quality_image:                                                 \n        enabled: false                                                  # acquire high quality (frame-integrated) images after final polishing\n        dwell_time: 2.0e-6                                              # dwell time for hq\n        resolution: [3072, 2048]                                        # resolution for hq\n        hfw: 50.e-6                                                     # hfw for hq\n        frame_integration: 2                                            # frame integration for hq\n    take_final_overview_image: true                                     # acquire a low-magnification overview after final polishing\n    compucentric_x_offset: 0.0e-6                                       # the fixed offset in x to apply after compucentric rotation \n    compucentric_y_offset: 0.0e-6                                       # the fixed offset in y to apply after compucentric rotation\n    supervise:                                                          # enable supervision mode for indvidual stages\n    supervise:\n        landing: true\n        liftout: true\n        reset: true\n        trench: true\n        undercut: true\n        setup_lamella: true\n        mill_rough: true\n        mill_regular: true\n        mill_polishing: true\n    batch_mode: true                                                    # batch trenching stages together\n    confirm_next_stage: true                                            # confirm with the user before advancing to next stage\n    undercut_required: False                                            # complete the undercut stage\n    undercut_return_to_electron: True                                   # return flat to electron beam after undercut\n    liftout_joining_method: None                                        # method to join the manipulator and lamella (autolamella-autoliftout only) [None, Weld]\n    liftout_contact_detection: True                                     # use brightness based contact detection (autolamella-autoliftout only)\n    liftout_contact_offset: 0.25e-6                                     # additional offset movement after contact (autolamella-autoliftout only)\n    liftout_charge_neutralisation_iterations: 35                        # number of ion images to charge sample (autolamella-autoliftout-only)\n    landing_joining_method: Weld                                        # method to join lamella and landing post (autolamella-autoliftout only) [Weld]\n    landing_post_x_offset: 0.75e-6                                      # additional offset movement after contact (autolamella-autoliftout only)\n    landing_charge_neutralisation_iterations: 100                       # number of electron images to discharge sample (autolamella-autoliftout only)\n    trench_start_position: grid-01-lamella                             # the saved position to start selecting lamella positions \n    landing_start_position: grid-02-landing                             # the saved position to start selecting landing positions\n    landing_grid:                                                       # the landing grid parameters (autolamella-serial-liftout only)\n        x: 100.0e-6\n        y: 400.0e-6\n        rows: 4\n        cols: 10\nplatinum:                                                               # platinum deposition parameters (optional)\n    application_file: cryo_Pt_dep\n    beam_current: 5.0e-11\n    dwell_time: 1.0e-06\n    gas: Pt dep\n    position: Electron Default\n    rate: 3.0e-10\n    spot_size: 3.0e-06\n    weld:\n        hfw: 0.0001\n        length: 1.5e-05\n        time: 30.0\n    whole_grid:\n        hfw: 3.0e-05\n        length: 7.0e-06\n        time: 30.0\nmilling:                                                                    # milling protocols for each stage (required for method)\n    notch:                                                                  # notch (autolamella-waffle)\n        application_file: autolamella\n        cleaning_cross_section: false\n        depth: 2.5e-06\n        distance: 2.0e-06\n        enabled: true\n        flip: 0\n        hfw: 80e-6\n        hheight: 2.0e-07\n        hwidth: 4.0e-06\n        milling_current: 2.0e-09\n        preset: 30 keV; 2.5 nA\n        vheight: 2.0e-06\n        vwidth: 2.0e-07\n        type: WaffleNotch\n    trench:                                                                 # trench: (autolamella-waffle, autolamella-autoliftout, autolamella-serial-liftout)\n        application_file: autolamella\n        cleaning_cross_section: false\n        depth: 1.25e-06\n        hfw: 0.00018\n        lamella_height: 2.5e-05\n        lamella_width: 2.2e-05\n        milling_current: 7.6e-09\n        offset: 0.0\n        preset: 30 keV; 2.5 nA\n        size_ratio: 2.0\n        trench_height: 3.2e-05\n        type: Trench\n    undercut:                                                               # undercut: (autolamella-waffle, autolamella-autoliftout, autolamella-serial-liftout)\n        application_file: autolamella\n        cleaning_cross_section: false\n        depth: 1.2e-06\n        height: 16.0e-06\n        hfw: 8.0e-05\n        milling_current: 7.6e-09\n        preset: 30 keV; 2.5 nA\n        tilt_angle: -5.0\n        tilt_angle_step: 2.0\n        width: 22.0e-6\n        type: Rectangle\n    fiducial:                                                               # fiducial: (all)\n        application_file: autolamella\n        cleaning_cross_section: false\n        depth: 1.5e-06\n        enabled: true\n        height: 1.0e-05\n        hfw: 8.0e-05\n        milling_current: 7.6e-09\n        passes: null\n        preset: 30 keV; 20 nA\n        rotation: 45\n        width: 1.0e-06\n        type: Fiducial\n    lamella:                                                                # lamella: (all)\n        stages:\n        -   application_file: autolamella\n            cleaning_cross_section: true\n            depth: 2.0e-06\n            hfw: 8.0e-05\n            lamella_height: 5.0e-07\n            lamella_width: 14.0e-6\n            milling_current: 2.0e-09\n            offset: 2.0e-06\n            preset: 30 keV; 2.5 nA\n            size_ratio: 1.0\n            trench_height: 5.0e-06\n            type: Trench\n        -   application_file: autolamella\n            cleaning_cross_section: true\n            depth: 1.0e-06\n            hfw: 8.0e-05\n            lamella_height: 5.0e-07\n            lamella_width: 1.4e-05\n            milling_current: 7.4e-10\n            offset: 5.0e-07\n            preset: 30 keV; 1 nA\n            size_ratio: 1.0\n            trench_height: 2.0e-06\n            type: Trench\n        -   application_file: autolamella\n            cleaning_cross_section: true\n            depth: 4.0e-07\n            hfw: 8.0e-05\n            lamella_height: 4.5e-07\n            lamella_width: 1.4e-05\n            milling_current: 6.0e-11\n            offset: 0.0\n            preset: 30 keV; 50 pA\n            size_ratio: 1.0\n            trench_height: 6.0e-07\n            type: Trench\n    flatten:                                                                # flatten: (autolamella-autoliftout)\n        cleaning_cross_section: 1.0\n        depth: 1.0e-05\n        height: 2.5e-05\n        hfw: 8.0e-05\n        milling_current: 2.8e-08\n        rotation: 0.0\n        scan_direction: LeftToRight\n        width: 2.0e-06\n        application_file: \"autolamella\"\n        type: \"Rectangle\"\n        preset: \"30 keV; 20 nA\"\n    liftout-sever:                                                          # liftout-sever: (autolamella-serial-liftout)\n        cleaning_cross_section: 0.0\n        depth: 25.0e-06\n        height: 5.0e-06\n        hfw: 400.0e-6\n        milling_current: 28.0e-09\n        rotation: 0.0\n        scan_direction: TopToBottom\n        width: 50.0e-06\n        application_file: \"autolamella\"\n        type: \"Rectangle\"\n        preset: \"30 keV; 20 nA\"\n    liftout-weld:                                                          # liftout-weld: (autolamella-serial-liftout)\n        height: 2.5e-6\n        width: 0.5e-6\n        depth: 4.0e-6\n        pitch_horizontal: 0.25e-6\n        n_columns: 10\n        n_rows: 1\n        pitch_vertical: 0.0e-6\n        rotation: 0.0\n        passes: 1.0\n        milling_voltage: 30.0e+3\n        milling_current: 300.0e-12\n        hfw: 150.0e-6\n        application_file: \"autolamella\"\n        scan_direction: \"BottomToTop\"\n        type: \"ArrayPattern\"\n        preset: \"30 keV; 2.5 nA\"\n    prepare-copper-weld:                                                           # prepare-copper-block-weld: (autolamella-serial-liftout)\n        stages:\n        -   height: 2.5e-6\n            width: 0.5e-6\n            depth: 4.0e-6\n            pitch_horizontal: 1.0e-6\n            n_columns: 15\n            n_rows: 1\n            pitch_vertical: 0.0e-6\n            rotation: 0.0\n            passes: 1.0\n            milling_voltage: 30.0e+3\n            milling_current: 300.0e-12\n            hfw: 150.0e-6\n            application_file: \"autolamella\"\n            scan_direction: \"TopToBottom\"\n            type: \"ArrayPattern\"\n            preset: \"30 keV; 2.5 nA\"\n    landing-weld:                                                                 # weld: (autolamella-autoliftout, autolamella-serial-liftout)\n        stages:\n        # left weld\n        -   height: 0.5e-6\n            width: 4.0e-6\n            depth: 10.0e-6\n            pitch_vertical: 0.25e-6\n            n_rows: 5\n            n_columns: 1\n            pitch_horizontal: 0\n            rotation: 0.0\n            passes: 1.0\n            milling_current: 300.0e-12\n            milling_voltage: 1.0e-9\n            hfw: 150.0e-6\n            application_file: \"autolamella\"\n            scan_direction: \"RightToLeft\"\n            type: \"ArrayPattern\"\n        # right weld\n        -   height: 0.5e-6\n            width: 4.0e-6\n            depth: 10.0e-6\n            pitch_vertical: 0.25e-6\n            n_rows: 5\n            n_columns: 1\n            pitch_horizontal: 0\n            rotation: 0.0\n            passes: 1.0\n            milling_current: 300.0e-12\n            milling_voltage: 1.0e-9\n            hfw: 150.0e-6\n            application_file: \"autolamella\"\n            scan_direction: \"LeftToRight\"\n            type: \"ArrayPattern\"\n    landing-sever:                                                          # landing-sever: (autolamella-serial-liftout)\n        cleaning_cross_section: 0.0\n        depth: 25.0e-06\n        height: 1.0e-06\n        hfw: 150.0e-6\n        milling_current: 7.6e-09\n        rotation: 0.0\n        scan_direction: TopToBottom\n        width: 50.0e-06\n        application_file: \"autolamella\"\n        type: \"Rectangle\"\n        preset: \"30 keV; 20 nA\"\n</code></pre>"},{"location":"autolamella/ml/","title":"Machine Learning","text":"<p>Machine Learning is a core part of AutoLamella. Here we are highlighting the datasets, models and tooling we have developed as part of the project.</p>"},{"location":"autolamella/ml/#dataset","title":"Dataset","text":""},{"location":"autolamella/ml/#autolamella-dataset","title":"AutoLamella Dataset","text":"<p>The autolamella dataset consists of images from multiple different lamella preparation methods. All data is annotated for semantic segmentation, and is available through the huggingface api at patrickcleeve/autolamella</p> <p>Summary</p> Dataset / Method Train Test Total Waffle 214 76 290 Liftout 801 163 969 Serial Liftout 301 109 412 Full 1316 348 1664 <p>Details about the datasets can be found in summary.csv in the dataset directory.</p>"},{"location":"autolamella/ml/#labels","title":"Labels","text":"<p>Currently, the dataset is labelled for the following classes. In the future, we will add additional labels for objects such as ice contamination. If you would like to label this data, please see the labelling tools to get started.</p> <pre><code>CLASS_LABELS: # autolamella\n  0: \"background\"\n  1: \"lamella\"\n  2: \"manipulator\"\n  3: \"landing_post\"\n  4: \"copper_adaptor\"\n  5: \"volume_block\"\n</code></pre>"},{"location":"autolamella/ml/#downloading-data","title":"Downloading Data","text":"<p>To download datasets, you can use the huggingface api:</p> <pre><code>from datasets import load_dataset\n\n# download waffle dataset\nds = load_dataset(\"patrickcleeve/autolamella\", name=\"waffle\")\n\n# download liftout dataset\nds = load_dataset(\"patrickcleeve/autolamella\", name=\"liftout\")\n\n# download serial-liftout dataset\nds = load_dataset(\"patrickcleeve/autolamella\", name=\"serial-liftout\")\n\n# download test split only\nds = load_dataset(\"patrickcleeve/autolamella\", name=\"waffle\", split=\"test\")\n</code></pre> <p>To display images and annotations:</p> <pre><code># show random image image and annotation (training split) \nimport random\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom fibsem.segmentation.utils import decode_segmap_v2\n\n# random data\nidx = random.randint(0, len(ds[\"train\"]))\nimage = np.asarray(ds[\"train\"][idx][\"image\"])\nmask = np.asarray(ds[\"train\"][idx][\"annotation\"])\n\n# metadata\nsplit = ds[\"train\"].split\nconfig_name = ds[\"train\"].config_name\n\nplt.title(f\"{config_name}-{split}-{idx:02d}\")\nplt.imshow(image, cmap=\"gray\", alpha=0.7)\nplt.imshow(decode_segmap_v2(mask), alpha=0.3)\nplt.axis(\"off\")\nplt.show()\n</code></pre> Waffle Liftout Serial Liftout <p>You can also concatenate the datasets together into a single dataset for easy combined training (e.g. mega models)</p> <pre><code>from datasets import load_dataset, concatenate_datasets\n\n# load invidual datasets\nwaffle_train_ds = load_dataset(\"patrickcleeve/autolamella\", name=\"waffle\", split=\"train\")\nliftout_train_ds = load_dataset(\"patrickcleeve/autolamella\", name=\"liftout\", split=\"train\")\nserial_liftout_train_ds = load_dataset(\"patrickcleeve/autolamella\", name=\"serial-liftout\", split=\"train\")\n\n# concatenate datasets (e.g. mega model)\ntrain_ds = concatenate_datasets([waffle_train_ds, liftout_train_ds, serial_liftout_train_ds])\n\nprint(train_ds)\n</code></pre> <pre><code>Dataset({\n    features: ['image', 'annotation'],\n    num_rows: 1316\n})\n</code></pre>"},{"location":"autolamella/ml/#acknowledgement","title":"Acknowledgement","text":"<ul> <li>Waffle and Liftout data from Monash</li> <li>Serial Liftout data from MPI</li> </ul>"},{"location":"autolamella/ml/#dataset-format","title":"Dataset Format","text":"<p>Image data is 8bit grayscale tiffs, labels are saved as class index maps (8bit tiff). The corresponding image and labels have the same filename, and the labels are located in the labels/ directory.</p> <p>The file layout of the dataset is:</p> <pre><code>autolamella-dataset/\n    summary.csv\n    autolamella-waffle/\n        train/\n            image-0000.tif\n            labels/\n                image-0000.tif\n        test/\n    autoliftout/\n    serial-liftout/\n</code></pre>"},{"location":"autolamella/ml/#keypoint-dataset","title":"Keypoint Dataset","text":"<p>The keypoint dataset is used for model evaluation, to as closely mimic the online performance of the models when running on an actual FIBSEM.</p> <p>You can run the evaluation against the keypoint dataset to determine the accuracy for each detection task. Running keypoint evaluation is the best way to compare two different models, and determine if a new model has improved, or regressed. Machine learning models can often regress on previously successful task when retrained or finetuned, so it is important to assess this accuracy rather than just during training. </p> <p>Each dataset contains labelled keypoints in the test directory. You can also create your own keypoint dataset using the Keypoint Labelling plugin. </p> <p>For information on using the keypoint evaluation, please see the Concepts Page.</p>"},{"location":"autolamella/ml/#models","title":"Models","text":""},{"location":"autolamella/ml/#baseline-models","title":"Baseline Models","text":"<p>We have trained models for each method on the subset of data. Models are available on huggingface patrickcleeve/autolamella. Includes archived development models. You can try out a demo of these models on huggingface.</p> <p>The current best performing models for each method are:</p> Method Dataset Checkpoint AutoLamella Waffle Waffle autolamella-waffle-20240107.pt AutoLamella Liftout Full autolamella-liftout-20240107.pt AutoLamella Serial Liftout Serial Liftout autolamella-serial-liftout-20240107.pt"},{"location":"autolamella/ml/#mega-model","title":"Mega Model","text":"<p>We are in the process of developing a combined model for all these methods, called the mega model.</p> <p>Currently the mega model is outperformed by the specifc waffle, and serial liftout models, but performs better for liftout. My initial thought is that this is because the waffle and serial liftout datasets are from a single sample (and a single run in the serial liftout case), so on these cases the models are probably overfit on these modes. However, the liftout dataset contains multiple samples, and a much more diverse set of images, which benefits more increased size and variation in the dataset.</p> <p>Therefore, we are very keen to incorporate a lot more varied training data for the other methods. We are looking for additional data to include in this model, if you would like to contribute, please get in contact at patrick@openfibsem.org</p>"},{"location":"autolamella/ml/#tools","title":"Tools","text":"<p>This section highlights some of the tools developed.</p> <p>For specific details about concepts and terminology, please refer to the Concepts Page.</p>"},{"location":"autolamella/ml/#data-collection-and-curation-supervised-mode","title":"Data Collection and Curation (Supervised Mode)","text":"<p>When running autolamella, imaging data is logged and saved for later use. When running in supervised mode, every correction the user makes is logged and classified. We use this user feedback to automatically split the dataset, and generate a set of evaluation keypoints for testing. This form of active learning allows efficient model improvement by only including data that the model fails to predict correctly.</p>"},{"location":"autolamella/ml/#data-labelling-model-assisted-labelling","title":"Data Labelling (Model Assisted Labelling)","text":"<p>We developed a napari plugin for labelling images for semantic segmentation. The plugins supports manual labelling and model assisted labelling.</p> <p>Model assisted labelling supports two kinds of model; segmentation models and segment anything models. Segmentation models allow prelabelling of data using a pretrained segmentation model, while segment anything models use a generic segment anything model to prompt segmentation. The user can then manually edit the segmentation to correct for any model errors.</p> <p>In practice these two models are useful at different stages of development. For example, when labelling a new dataset, or one where the model performance is poor, using segment anything allows you to quickly generate segmentation masks with interactive prompting. Once you have a decent model, segmentation model labelling is much faster, and usually only requires minor edits from the user.</p>"},{"location":"autolamella/ml/#example-serial-liftout-data","title":"Example: Serial Liftout Data","text":"<p>When we received the serial liftout data, we didnt have any models trained for it. Therefore, it was much faster to use SAM to label the training dataset. Once an initial model was trained we switched to using the segmentation model, and manually editing the masks.</p> <p> Segment Anything Labelling</p> <p> Model Assisted Labelling</p> <p>With the assistance of this tooling, the full dataset (all methods) now contains around 1600 labelled images.</p>"},{"location":"autolamella/ml/#model-evaluation","title":"Model Evaluation","text":"<p>We provide evaluation tools for evaluating the perform of a number of different models on the keypoint detection task.</p> <p>The evaluation will run each model checkpoint through the detection pipeline, save the results and compare them to the ground truth labels provided. Each individual image can be plotted, as well as the full evaluation statistics. This evaluation pipeline is useful for checking model improvement and preventing regressions on previously successful tasks.</p> <p>Here we are showing evaluations from the development models.</p> <p>[Under Constrution] TODO: insert data from paper</p>"},{"location":"autolamella/ml/#experimental","title":"Experimental","text":""},{"location":"autolamella/ml/#generating-labels","title":"Generating Labels","text":"<p>From the segmentation masks, you can generate other useful labelled objects. The following script will generate bounding boxes and instance segmentations for each object in the mask. This uses the Get Objects API.</p> <p>Generate bounding boxes and instance masks from segmentation masks. generate_segmentation_objects.py</p> <p>These bounding boxes, and instance masks should be useful for training different, and larger models, or panoptic segmentation models. If you would like any help using the dataset, labels, or api please contact Patrick @patrickcleeve2, or via email.</p> <p>[Under Construction]</p>"},{"location":"autolamella/ml/#depth-estimation","title":"Depth Estimation","text":"<p>[Under Construction]</p> <p>Depth-Anything backbone</p>"},{"location":"autolamella/motivation/","title":"Motivation","text":"<p>standardise lamella preparation</p>"},{"location":"autolamella/protocol/","title":"AutoLamella Protocol","text":"<p>The new AutoLamella program utilises the OpenFIBSEM code package to build a more streamlined and robust automated lamella workflow that includes a new user interface. This updated AutoLamella program also includes a more intuitive system for the lamella protocol. AutoLamella protocol's should now be easier to make, without requiring any calculations. </p>"},{"location":"autolamella/protocol/#waffle-method","title":"Waffle Method","text":"<p>The waffle method is a new method of milling lamellae that allows for undercuts to be performed. The waffle method involves milling trenches in a way to allow for undercuts to be performed. Once the trenches are milled, the undercuts are performed and the lamellae are milled in the same fashion as the default method.</p> <p>The lamella height and width are specified in the protocol, as well as the height and width of the rectangles that make up the waffle pattern. The protocol also includes the milling current/preset to be used when milling, as well as the size ratio of the trenches.</p> <p>The undercuts are defined as rectangle patterns of a given height and width. The tilt angles are also specified. </p>"},{"location":"autolamella/protocol/#the-new-lamella-protocol-format","title":"The new lamella protocol format","text":"<p>Each of the colours indicates a different protocol stage. In this case there are three: Rough Cut in yellow, Regular Cut in blue, and Polishing Cut in magenta. Additionally the optional microexpansion joints are indicated in yellow as they are milled during the Rough Cut stage if the user opts to use them. </p> <p>The Lamella width and height are indicated at the centre, and must be input for each protocol stage. The placement of each trench is based on two factors: the offset, and the trench height. For example, the Polishing Cut (magenta) has an offset of 0 as it is situated directly above and below the Lamella, and in our default protocol example, has a trench height of 1e-6m. The Regular Cut (blue) has an offset of 1e-6m, and a trench height of 2e-6m. Finally, the offset of the Rough Cut (yellow) is the cumulative trench height of the previous stages, 3e-6m; and has a trench height of 10e-6m. It should be mentioned that in practice the order of the protocol stages would be the reverse, as the stages are milled sequentially, it is just easier to explain in this manner. Additionally, if you would like overlap between stages, the offset of the stage simply needs to be less than the cumulative trench heights of the other stages.</p> <p>As previously mentioned the microexpansion joints are optional and can be enabled/disabled in within the UI. If they are enabled they must have the height, width, and distance from the Lamella within the protocol. The distance does NOT include the Lamella width itself, and is accounted for when milling.</p> <p>If running the waffle method, a notch is used instead of microexpansion joints. The protocol specifies all the milling settings, as well as the dimensions of the patterns: height and width for the vertical rectangles and for the horizontal ones. The distance between the rectangles is also specified. The distance is the distance between the centre of the notch and the centre of the lamella, and does not include the width of the rectangles themselves. The distance is accounted for when milling.</p> <p>Optionally, a fiducal mark can be used for beam alignment during the lamella milling process. The fiducial requires the width and height of a rectangle, which will then be rotated +/- 45 degrees to create the 'X'.  </p> <p>Additionally, the number of attempts the program should make when attempting to align the imaging beam to the fiducial should be stored within the Lamella section of the protocol. You can also specify whether to align at the imaging current or the milling current of each stage.</p> <p>Finally, here is what a completed protocol in the new format might look like as a .yaml file:</p> <pre><code>name: autolamella_demo\napplication_file: Si # Thermo only\nmethod: waffle\nml: # machine learning parameters \n    encoder: resnet34\n    num_classes: 3\n    checkpoint: model4.pt #model4.pt\noptions:\n    undercut_return_to_electron: True\n    alignment_attempts: 3\n    supervise:\n        features: false\n        lamella: true\n        setup_lamella: true\n        trench: true\n        undercut: true\ntrench:\n    application_file: autolamella\n    cleaning_cross_section: false\n    depth: 1.0e-06\n    hfw: 0.00018\n    lamella_height: 2.5e-05\n    lamella_width: 2.2e-05\n    milling_current: 7.6e-09\n    offset: 0.0\n    preset: 30 keV; 2.5 nA\n    size_ratio: 2.0\n    trench_height: 3.2e-05\nundercut:\n    application_file: autolamella\n    cleaning_cross_section: false\n    depth: 1.0e-06\n    height: 8.0e-06\n    hfw: 8.0e-05\n    milling_current: 7.6e-09\n    preset: 30 keV; 2.5 nA\n    tilt_angle: -5.0\n    tilt_angle_step: 2.0\n    width: 22.0e-6\nfiducial:\n  application_file: autolamella\n  cleaning_cross_section: false\n  depth: 1.0e-06\n  enabled: true\n  height: 1.0e-05\n  hfw: 8.0e-05\n  milling_current: 2.0e-09\n  passes: null\n  preset: 30 keV; 20 nA\n  rotation: 45\n  width: 1.0e-06\nlamella:\n    lamella_height: 8.0e-07\n    lamella_width: 1.0e-05\n    stages:\n    -   application_file: autolamella\n        cleaning_cross_section: true\n        depth: 2.0e-06\n        hfw: 8.0e-05\n        lamella_height: 8.0e-07\n        lamella_width: 14.0e-6\n        milling_current: 2.0e-09\n        offset: 2.0e-06\n        preset: 30 keV; 2.5 nA\n        size_ratio: 2.0\n        trench_height: 1.0e-05\n    -   application_file: autolamella\n        cleaning_cross_section: true\n        depth: 1.0e-06\n        hfw: 8.0e-05\n        lamella_height: 8.0e-07\n        lamella_width: 1.4e-05\n        milling_current: 7.4e-10\n        offset: 5.0e-07\n        preset: 30 keV; 1 nA\n        size_ratio: 1.0\n        trench_height: 2.0e-06\n    -   application_file: autolamella\n        cleaning_cross_section: true\n        depth: 4.0e-07\n        hfw: 8.0e-05\n        lamella_height: 6.0e-07\n        lamella_width: 1.4e-05\n        milling_current: 6.0e-11\n        offset: 0.0\n        preset: 30 keV; 50 pA\n        size_ratio: 1.0\n        trench_height: 5.0e-07\nmicroexpansion:\n  application_file: autolamella\n  cleaning_cross_section: false\n  depth: 1.0e-06\n  distance: 1.0e-05\n  height: 1.8e-05\n  hfw: 200e-6\n  milling_current: 2.0e-09\n  preset: 30 keV; 2.5 nA\n  width: 5.0e-07\n</code></pre>"},{"location":"autolamella/protocol/#how-to-convert-to-the-new-protocol-format","title":"How to convert to the new protocol format","text":"<p>A tool has been created to automatically convert an old protocol file to the new format. </p> <p>Simply navigate to the autolamella folder that contains protocol_converter.py in a terminal and write the following:</p> <pre><code>python protocol_converter.py(\"path/old_protocol.yaml\", \"path/new_protocol.yaml\")\n</code></pre> <p>The first argument refers to the curent file path of the old protocol yaml file. The second location indicates the file location you would like the converted protocol yaml file saved to.</p>"},{"location":"autolamella/user_guide/","title":"Workflow","text":"<p>AutoLamella workflows are broken down into a series of consecutive steps called workflow stages. Workflow stages are shared across methods, with most only requiring changes to the protocol. </p> <p>We group these stages into three conceptual groups; setup, isolation and polishing.  </p> <p>The full map of every workflow is as follows:</p> <p>[TODO]</p>"},{"location":"autolamella/user_guide/#workflow-stages","title":"Workflow Stages","text":"<p>At the end of each workflow stage, we save the state of the microscope, allowing us to restore the state of the microscope at the start of the next stage,This allows us to continue on exactly from the previous state even if time has passed, the system has been rebooted or any other interruption. It also allows us to batch operations, e.g. perform all trench milling operations together, and easily stop and start the program.  </p> <p>Assume that at the end of every workflow stage, the state is saved and can be restored to via the time travel controls.</p> <p>Pre Workflow Stage: We restore the state of the microscope which was saved after selecting positions, and log that this workflow stage has started for analytics purposes.  </p> <p>Post Workflow Stage: We save the state of the microscope, and log that this workflow stage has finished.  </p>"},{"location":"autolamella/user_guide/#setup","title":"Setup","text":"<p>In the setup stages, the user selects the positions for milling and landing (liftout methods only). These stages are currently manual, and the user must select the position by following the guided steps in the workflow.</p>"},{"location":"autolamella/user_guide/#select-positions","title":"Select Positions","text":"<p>The user selects the milling positions. For the on-grid method these are the positions of the final lamella and are selected at the milling angle. For waffle, liftout and serial-liftout the positions are for trench milling and are selected flat to the ion beam. </p> <p>On-grid and waffle methods support the use of the minimap, which allows multiple positions to be selected in a short amount of time, as well as correlation with fluorescence data. We will add minimap support for other methods in the future. </p> <p>For liftout methods, the user needs to specify the inital lamella and landing positions in the protocol. Saved positions can be exported from the Movement tab, and are stored in fibsem/config/positions.yaml.  </p> <pre><code>options:\n    trench_start_position: pre-tilt-35-deg-grid-01-lamella     # starting point for selecting milling position\n    landing_start_position: pre-tilt-35-deg-grid-02-landing     # starting point for selecting landing position\n</code></pre>"},{"location":"autolamella/user_guide/#select-landing-positions","title":"Select Landing Positions","text":"<p>The user selects the landing positions for liftout methods. For the liftout method the user is required to select a landing position for each selected milling position. For serial-liftout, we generate a map of landing positions, based on the protocol values.</p> <pre><code>options:\n    landing_grid:\n        x: 100.0e-6     # grid spacing in x\n        y: 400.0e-6     # grid spacing in y\n        rows: 4         # number of rows to generate\n        cols: 10        # number of columns to generate\n</code></pre>"},{"location":"autolamella/user_guide/#isolation","title":"Isolation","text":"<p>The isolation stages remove the bulk of material from the sides and underside of the selected area. Higher milling currents are used to prioritise material removal over sample damage. </p>"},{"location":"autolamella/user_guide/#trench-milling","title":"Trench Milling","text":"<p>The trench milling stage removes the bulk of material from around the selected area.</p>"},{"location":"autolamella/user_guide/#restore-selected-position","title":"Restore Selected Position","text":"<p>We restore the selected trench milling position that was selected the setup steps. The trench milling position was selected flat to the ion beam, so we do not need to move. Both the position of the stage, and the milling pattern were selected.</p>"},{"location":"autolamella/user_guide/#align-reference-image","title":"Align Reference Image","text":"<p>We can optionally choose to align a reference image to re-align with more precision. (Not recommended).</p>"},{"location":"autolamella/user_guide/#mill-trench","title":"Mill Trench","text":"<p>We retrieve the milling pattern and position from the protocol and draw it. If in supervised mode, the user has the opportunity to edit this pattern. Otherwise, the milling operation will start. Once milling has finished, the system is restored back to the imaging configuration.</p>"},{"location":"autolamella/user_guide/#acquire-reference-images","title":"Acquire Reference Images","text":"<p>We acquire low and high magnification reference images. These enable us to analyse the success of the milling operations, and provide a potential reference for alignment in future alignments.</p>"},{"location":"autolamella/user_guide/#undercut-milling","title":"Undercut Milling","text":"<p>The undercut milling stage removes material from the underside of the selected area, freeing it from the base of the sample / holder. </p>"},{"location":"autolamella/user_guide/#restore-trench-milling-position","title":"Restore Trench Milling Position","text":"<p>We restore the trench milling position.</p>"},{"location":"autolamella/user_guide/#move-flat-to-electron-beam","title":"Move Flat to Electron Beam","text":"<p>We move the stage flat to the electron beam (rotate 180 degrees compucentrically).</p> <p>You can specify an additional compucentric rotation offset with the following parameters:</p> <pre><code>options:\n    compucentric_x_offset: 25e-6    # fixed y movement after compucentric rotation (metres)\n    compuncentric_y_offset: 50e-6   # fixed y movement after compucentric rotation (metres)\n</code></pre>"},{"location":"autolamella/user_guide/#coincident-feature-alignment","title":"Coincident Feature Alignment","text":"<p>We perform a coincident feature alignment to ensure we are coincident after compucentrically rotating.</p> <p>Align Feature Coincident     Detect Feature Centre in Electron Beam     Stable Move to Feature Centre     Detect Feature Centre in Ion Beam     Vertical Move to Feature Centre     The Feature should now be centred in both beams (coincident)</p> <p>We can specify which feature we want to align with using the features argument.</p> <pre><code>on-grid: null\nwaffle: LamellaCentre\nliftout: LamellaCentre\nserial-liftout: VolumeBlockTopEdge\n</code></pre> <p>Under the hood we use the projected stage position to differentiate between multiple feature detection. The position is projected from the trench milling position to this view.  </p>"},{"location":"autolamella/user_guide/#mill-undercut","title":"Mill Undercut","text":"<p>We tilt the stage down (negative) to access the underside of the volume block. We can perform this step in increments by specifying the parameters, tilt_angle, and tilt_angle_step. Specifying multiple steps will repeat this step multiple times, gradually shrinking the height of the undercut pattern.</p> <p>We detect the top edge of the volume block to place our undercut pattern. We can specify a specific offset from this pattern to determine how 'deep' we want to perform the undercut, v_offset.</p> <pre><code>undercut:\n    ...\n    tilt_angle: -5      # undercut tilt per step\n    tilt_angle_step: 2  # number of undercut steps\n    v_offset: 5.0e-6    # milling pattern offset\n</code></pre> <p>We retrieve the undercut milling pattern from the protocol and draw it using the detected feature position. Once milling operations are completed the microscope is restore back to the imaging configuration.</p>"},{"location":"autolamella/user_guide/#return-flat-to-electron-beam-optional","title":"Return Flat to Electron Beam [Optional]","text":"<p>After milling the undercut pattern, we can optionally return flat to the electron beam, or stay at the tilted angle. It's recommended to stay at the tilted angle if doing the waffle method as the next step is to perform the lamella thinning and polishing.</p> <pre><code>options:\n    undercut_return_to_electron: true   # move flat to electron after undercut\n</code></pre>"},{"location":"autolamella/user_guide/#align-feature-in-ion-beam","title":"Align Feature in Ion Beam","text":"<p>After moving back we align the feature in the ion beam to ensure coincidence of the beams before moving to the next stage.</p>"},{"location":"autolamella/user_guide/#acquire-reference-images_1","title":"Acquire Reference Images","text":"<p>We acquire low and high magnification reference images for analysis and alignment.</p>"},{"location":"autolamella/user_guide/#liftout","title":"Liftout","text":"<p>The liftout stage attaches the selected region to the manipulator, and severs it from the rest of the sample. After liftout, the selected region should be solely attached to the manipulator and be ready to be transfered to the landing grid.  </p> <p>Specific implementations for liftout, and serial-liftout. </p>"},{"location":"autolamella/user_guide/#restore-undercut-position","title":"Restore Undercut Position","text":"<p>We restore to the undercut position. </p>"},{"location":"autolamella/user_guide/#coincident-feature-alignment_1","title":"Coincident Feature Alignment","text":"<p>We use the coincident alignment (LamellaCentre) procedure to ensure the beams are coincident.</p>"},{"location":"autolamella/user_guide/#insert-manipulator","title":"Insert Manipulator","text":"<p>We insert the manipulator to the liftout offset position. This position is just above the eucentric position, and to the left of the sample. </p>"},{"location":"autolamella/user_guide/#manipulator-control","title":"Manipulator Control","text":"<p>We use the feature detector to move the manipulator to the left edge of the lamella. The feature detection detects the manipulator tip, and the lamella left edge in both beams, and moves the manipulator into position inside the side trench to the left of the lamella edge. If deposition free attachment is used, the sample is charged at this point.  </p>"},{"location":"autolamella/user_guide/#manipulator-contact-and-attachment","title":"Manipulator Contact and Attachment","text":"<p>Once the manipulator is positioned to the left edge of the lamella and inside the trench, we horizontally towards the lamella, so the manipulator makes contact with the side of the lamella. If brightness based contact detection is used, the manipulator will move slowly towards the lamella until a brightness change is observed.</p> <p>Once the manipulator is in contact with the lamella, the joining method can occur. For deposition free attachment, the workflow continues. For redeposition welding, the  weld pattern if placed at the interface of the manipulator and lamella. The lamella and manipulator are now joined together. </p> <pre><code>options\n    liftout_joining_method: null                    # manipulator joing method to use, None or Weld\n    liftout_contact_offset: 0.25e-6                 # additional movement after contact\n    liftout_contact_detection:                      # use brightness based contact detection\n    liftout_charge_neutralisation_iterations: 35    # number of images to charge sample before contact\n</code></pre>"},{"location":"autolamella/user_guide/#manipulator-sever","title":"Manipulator Sever","text":"<p>We detect the right edge of the lamella region, and place the severing pattern. The severing pattern dettaches the lamella from the rest of the sample. The lamella should be attached solely to the manipulator. </p>"},{"location":"autolamella/user_guide/#retract-manipulator","title":"Retract Manipulator","text":"<p>The manipulator is moved slowly upwards from the trench, and then retracted fully. </p>"},{"location":"autolamella/user_guide/#landing","title":"Landing","text":"<p>The landing stage attaches the selected region to the landing grid, and severs it from the manipulator. After landing the selected region should be solely attached to the landing grid, and dettached from the manipulator. </p> <p>Specific implementations for liftout, and serial-liftout.</p>"},{"location":"autolamella/user_guide/#restore-landing-position","title":"Restore Landing Position","text":"<p>We restore the landing position selected by the user, and align to the reference images. We should be centred on the landing position and coincident in both beams.</p>"},{"location":"autolamella/user_guide/#insert-manipulator_1","title":"Insert Manipulator","text":"<p>We insert the manipulator to the landing position, which is near the parking position high above the grid. We detect the lamella, manipulator and landing position and move the manipulator down to the left of the landing post position. </p>"},{"location":"autolamella/user_guide/#landing-procedure","title":"Landing Procedure","text":"<p>We detect the right edge of the lamella and the landing post and move the manipulator so they are in contact. </p> <p>Once they are in contact we can weld the lamella to the landing post. The reposition weld pattern (spot_weld) is placed on the landing post side of the interface between the lamella and landing post. If the manipulator and lamella were welded togehter, they are cut using a milling pattern. </p> <p>The manipulator is slowly pulled back from the landing post, and reference images are acquired. If the lamella has been successfuly attached to the post, the workflow continues. If deposition free attachment was used, and the lamella fails to attach to the landing post it will still be attached to the manipulator, and the landing procedure can be repeated again. </p>"},{"location":"autolamella/user_guide/#retract-manipulator_1","title":"Retract Manipulator","text":"<p>We retract the manipulator, and acquire high and low magnification reference images for analysis and alignment. If the manipulator needs to be reset due to being cut, the reset procedure occurs now. </p>"},{"location":"autolamella/user_guide/#polishing","title":"Polishing","text":"<p>The polishing stages mill the final lamella to electron transparency. In these stages, lower milling currents are used to prioritise sample damage over material removal.  </p>"},{"location":"autolamella/user_guide/#setup-lamella","title":"Setup Lamella","text":"<p>Prior to polishing we get the user to select the final polishing position and pattern. The user also can confirm the position of an alignment fiducial, specified in 'fiducial'. This allows the user to avoid contamination, or use fluroescence data to correlate milling sites, which are not currently supported.</p> <p>This is a guided workflow, and the stage will move to the position of the last completed stage (waffle: undercut, liftout: landing), so the user only needs to move the pattern in the user interface. Once the user selects the polishing position, the microscope state is saved.  </p>"},{"location":"autolamella/user_guide/#mill-stress-relief","title":"Mill Stress Relief","text":"<p>We mill a stress relief feature for on-grid methods to prevent lamellae from cracking when polished. The feature to mill is defined using the following key:</p> <pre><code>on-grid: microexpansion \nwaffle: notch\n</code></pre> <p>Practically, this milling operation occurs at the same time as the thinning cut to save time.  </p>"},{"location":"autolamella/user_guide/#mill-thinning-cut","title":"Mill Thinning Cut","text":"<p>The thinning cut removes the bulk of the material from the lamella, but leaves a small amount to prevent contamination on the final polished lamella. Contamination will slowly build up on all exposed surfaces, so we want to complete all the polishing as close to finishing the workflow and removing the sample as possible.  </p>"},{"location":"autolamella/user_guide/#align-reference-image_1","title":"Align Reference Image","text":"<p>We restore the microscope state from the setup lamella stage, and align to the fiducial image. The user can specify the following alignment parameters. </p> <pre><code>options:\n    alignment_attempts: 3               # the number of alignment repeats\n    alignment_at_milling_current: true  # align at the milling current (or imaging current)\n</code></pre>"},{"location":"autolamella/user_guide/#mill-thinning-pattern","title":"Mill Thinning Pattern","text":"<p>We retrieve the lamella milling pattern from the protocol, and the position selected in the setup lamella stage. We mill all lamella stages, excluding the final one which is completed during the polishing stage. The following protocol shows an example of the breakdown.  </p> <p><pre><code>lamella:\n  stages:\n    -   application_file: autolamella   # mill thinning\n        ...         \n        trench_height: 3.5e-06\n    -   application_file: autolamella   # mill thinning\n        ...\n        trench_height: 2.0e-06\n    -   application_file: autolamella   # mill polishing\n        ...\n        trench_height: 5.0e-07\n</code></pre> Once the milling is complete, the microscope returns to the imaging configuration. </p>"},{"location":"autolamella/user_guide/#acquire-reference-images_2","title":"Acquire Reference Images","text":"<p>We acquire low and high magnification reference images for analysis and alignment.</p>"},{"location":"autolamella/user_guide/#mill-polishing-cut","title":"Mill Polishing Cut","text":"<p>The final polishing should be completed as close to removing the sample from the microscope as possible to prevent contamination build up. </p>"},{"location":"autolamella/user_guide/#align-reference-image_2","title":"Align Reference Image","text":"<p>We align the fiducial reference image the same as in the thinning stage. </p>"},{"location":"autolamella/user_guide/#mill-polishing-pattern","title":"Mill Polishing Pattern","text":"<p>We retrieve the final polishing pattern and position from the protocol and mill the pattern. Once the milling is complete, the microscope returns to the imaging configuration. </p>"},{"location":"autolamella/user_guide/#acquire-reference-images_3","title":"Acquire Reference Images","text":"<p>We acquire low and high magnification reference images for analysis and alignment. Additional high quality images (frame integrated) can be specified for this stage. The final reference images can also be disabled</p> <pre><code>options:\n    take_final_reference_images: true               # take reference images after polishing\n    high_quality_image: \n    enabled: true                                   # take high quality reference images after polishing\n</code></pre>"},{"location":"autolamella/user_guide/#methods-implementation","title":"Methods Implementation","text":""},{"location":"autolamella/user_guide/#on-grid-method","title":"On Grid Method","text":""},{"location":"autolamella/user_guide/#waffle-method","title":"Waffle Method","text":""},{"location":"autolamella/user_guide/#liftout-method","title":"Liftout Method","text":"<p>AutoLamella Liftout is an automated liftout method for the preparation of cryo lamella. The autoliftout requires the following workflow steps:</p>"},{"location":"autolamella/user_guide/#setup_1","title":"Setup","text":"<ul> <li>The user selects lamella and landing positions.</li> </ul> Description Electron Beam Ion Beam Lamella Position (Low) Lamella Position (High) Landing Position (Low) Landing Position (High)"},{"location":"autolamella/user_guide/#mill-trench_1","title":"Mill Trench","text":"<p>Mill lower, upper and side trenches using high currents. (horsheshoe pattern, see ref)</p> <ul> <li>Lower and Upper trenches release lamella from the bulk.</li> <li>Side trench provides access for the needle.</li> </ul> Description Electron Beam Ion Beam Trench Position (Low) Trench Position (High)"},{"location":"autolamella/user_guide/#mill-undercut_1","title":"Mill Undercut","text":"<ul> <li>Mill the underside and part of the other side of the lamella to release from the base of the bulk. Undercut is also refered to as the jcut.</li> </ul> Description Electron Beam Ion Beam Undercut Position (Low) Undercut Position (High)"},{"location":"autolamella/user_guide/#liftout_1","title":"Liftout","text":"<ol> <li>Insert the needle, and guide to near the lamella.</li> <li>Charge the sample with the ion beam</li> <li>Make contact with the lamella,</li> <li>Sever the lamella from the bulk.</li> <li>Retract the needle.</li> </ol> Description Electron Beam Ion Beam Liftout Entry Position Liftout Ready Position Liftout Contact Position Liftout Sever Position Liftout Retract Position"},{"location":"autolamella/user_guide/#landing_1","title":"Landing","text":"<ol> <li>Insert the needle, and guide the lamella to the post</li> <li>Weld lamella to the post</li> <li>Discharge the lamella with the electron beam</li> <li>Removal the needle from the lamella</li> <li>Retract the needle</li> </ol> Description Electron Beam Ion Beam Landing Entry Position 0 Landing Entry Position 1 Landing Entry Position 2 Landing Entry Position 3 Landing Ready Position Landing Weld Position Landing Removal Position Landing Retract Position"},{"location":"autolamella/user_guide/#setup-lamella_1","title":"Setup Lamella","text":"<ul> <li>The user selects the regions of the lamella to polish</li> </ul> Description Electron Beam Ion Beam Polish Setup Position (Low) Polish Setup Position (High) Polish Setup Position (Ultra)"},{"location":"autolamella/user_guide/#mill-thinning","title":"Mill Thinning","text":"<ul> <li>Thin the lamella to a lower thickness, using a relatively high current.</li> </ul> Description Electron Beam Ion Beam MillRoughCut Position (Low) MillRoughCut Position (High) MillRoughCut Position (Ultra)"},{"location":"autolamella/user_guide/#mill-polishing","title":"Mill Polishing","text":"<ul> <li>Polish the lamella to electron transparent thickness.</li> <li>Should be completed immediately prior to transfer to prevent contamination buildup.</li> </ul> Description Electron Beam Ion Beam MillPolishingCut Position (Low) MillPolishingCut Position (High) MillPolishingCut Position (Ultra) <p>The following methods were developed for the liftout workflow.</p>"},{"location":"autolamella/user_guide/#manipulator-preparation","title":"Manipulator Preparation","text":"<p>We flatten the side of the needle to maximise surface contact area with the side of the lamella.</p> <p>TODO: images</p>"},{"location":"autolamella/user_guide/#landing-surface-preparation","title":"Landing Surface Preparation","text":"<p>We flatten the side of the landing post to maximise surface contact area with the side of the lamella. TODO: images</p>"},{"location":"autolamella/user_guide/#charge-control","title":"Charge Control","text":"<p>Biological samples in cryogenic conditions often have large amounts of charge which causes challenges with imaging. Often this charging saturates the detectors and images either glow white or completely dark. To overcome this issue, we have developed the following techniques:</p> <ul> <li>AutoGamma: We automatically apply a digital gamma correction to the image if sufficient mean pixel intensity is determined. Gamma correction shifts the image histogram allowing features to be detected in the image (however it reduces image quality).</li> <li>Charge Neutralisation: To reduce the accumulated charge, we apply a charge neutralisation procedure (e.g. taking a rapid series of electron images to neutralise ion charge after large milling operations). This helps control the charge buildup throughout the process.</li> </ul> <p>TODO: images</p>"},{"location":"autolamella/user_guide/#side-pickup","title":"Side Pickup","text":"<p>To provide better landing stability, we liftout much larger lamella than typical. In conjunction with manipulator and landing surface preparation, we are able to make consistent, right-angled contact with a large surface area between the lamella and the landing post. This provides a more stable base from which to thin the lamella down. The downside of using this method is an increased material waste, and increased thinning time to remove excess material.</p> <p>To provide better liftout, and landing stability we make contact with the side of the lamella to lift it out of the trench. The side pickup provides the following benefits:</p> <ul> <li>More stability on contact: we apply a compressive force to the side of the lamella, instead of bending (if touching from the top). This allows us to make firmer contact without bottoming out the lamella in the trench.</li> <li>Better orientation for landing: Due to the lack of rotation/tilt control the angle of liftout determines the orientation for landing the lamella. When lifting from the top of the lamella, it can sometimes rotate, roll or slide of the needle tip when making contact with the post causing bad landing orientation. It is analogous to spinning a basketball on your finger, it can be done but is difficult to repeat. Making contact from the side allows for the lamella to be evenly compressed between the needle and the post, maintaining its orientation.</li> </ul>"},{"location":"autolamella/user_guide/#contact-detection","title":"Contact Detection","text":"<p>In order to determine whether the needle and lamella have made sufficient contact, we developed a contact detection procedure.</p> <ul> <li>We monitor the image brightness, whilst driving the needle towards the lamella.</li> <li>When contact is made between the needle and lamella, there is a significant increase in brightness due to charge disipation. This effect occurs due to the charge build up in the platinum crust being grounded when contact is made with the needle.</li> <li>We detect this change, and stop the needle movement.</li> </ul> Example 01 Example 02 Example 03 Example 04 <p>However, this effect is very sample dependent and does not occur on some samples.</p> <p> Sample Specific Contact Detection</p>"},{"location":"autolamella/user_guide/#deposition-free-attachment","title":"Deposition Free Attachment","text":"<p>We have developed a repeatable procedure for lifting the lamella by only manipulating the charge buildup. This method does not rely on platinum deposition, or welding (redeposition).</p> <ul> <li>To attach: We move the needle and lamella close together, and take a series ion beam images to build up charge. When the lamella and needle make contact they stick together with static due to charge.</li> <li>To dettach: Once the lamella is welded to the landing post, we run the electron beam to disapate the charge, and the needle slides off the lamella.</li> </ul> <p>The procedure is still being developed, and understood and is very sensitive to parameters and different conditions (e.g. the number of images being taken).</p>"},{"location":"autolamella/user_guide/#liftout-attach","title":"Liftout (Attach)","text":"Description Ready Contact Sever Electron View Ion View"},{"location":"autolamella/user_guide/#landing-dettach","title":"Landing (Dettach)","text":"Description Ready Weld Removal Electron View Ion View"},{"location":"autolamella/user_guide/#serial-liftout-method","title":"Serial Liftout Method","text":""},{"location":"autolamella/user_guide/#user-interface","title":"User Interface","text":""},{"location":"autolamella/user_guide/#process-improvements","title":"Process Improvements","text":""},{"location":"autolamella/user_guide/#machine-learning-microscope-control","title":"Machine Learning Microscope Control","text":""},{"location":"autolamella/user_guide/#contact-detection_1","title":"Contact Detection","text":""},{"location":"autolamella/user_guide/#deposition-free-manipulator-attachment","title":"Deposition Free Manipulator Attachment","text":""},{"location":"autolamella/user_guide/#coincidence-alignment","title":"Coincidence Alignment","text":""},{"location":"autolamella/user_guide/#instance-detection","title":"Instance Detection","text":""},{"location":"autolamella/user_guide/#experiment-management","title":"Experiment Management","text":""},{"location":"autolamella/user_guide/#microscope-configuration","title":"Microscope Configuration","text":""},{"location":"autolamella/user_guide/#protocol-configuration","title":"Protocol Configuration","text":""},{"location":"autolamella/user_guide/#analysis-and-optimisation","title":"Analysis and Optimisation","text":""},{"location":"autolamella/walkthrough/","title":"Walkthrough","text":"<p>The following page provides a detailed walkthrough for each method. As the methods contain significant overlap, only the unique parts will be described. </p> <p>Each walkthrough assumes you have already configured your microscope, loaded your sample and peformed initial setup (linked the stage, platinum deposition, etc.)</p>"},{"location":"autolamella/walkthrough/#on-grid-method","title":"On Grid Method","text":"<p>The following walkhrough is for the on-grid lamella method. The default protocol is protocol-on-grid.yaml.</p>"},{"location":"autolamella/walkthrough/#setup-experiment","title":"Setup Experiment","text":"<ol> <li>Connect to the Microscope (Connection Tab -&gt; Select Configuration -&gt; Connect to Microscope)</li> <li>Create an Experiment (File Menu -&gt; Create Experiment -&gt; Select Directory -&gt; Select Experiment Name)</li> <li>Load a Protocol (File Menu -&gt; Load Protocol -&gt; protocol-on-grid.yaml). We recommend starting with this protocol, and editting it to suit your microscope and sample.</li> <li>Move the stage to the sample grid. You can save this position for future use in the Movement Tab (Movement Tab -&gt; Add Position -&gt; Give your position a name (e.g. Grid 01) -&gt; Export Position (save to file))</li> <li>Move the stage to the milling angle. This is the tilt angle you want to mill your lamella at. You can use the Movement Tab to move to this tilt angle. </li> <li>Acquire Images. Use the Image Tab to acquire images with both beams. Images are required to display milling patterns.</li> <li>Make you beams coincident / eucentric. Use the movement controls to align the coincidence of the beams. First double click on a feature in the electron beam to centre it. Then press Alt + double click in the ion beam align the same feature coincident. The same feature should now be centred in both beams.  </li> </ol>"},{"location":"autolamella/walkthrough/#setup-positions","title":"Setup Positions","text":"<p>After you have setup your experiment, and microscope, you can now start selecting the lamella positions. </p> <ol> <li>Add a Lamella. Change to the Experiment tab, and Add Lamella. You can use the same movement controls to navigate around the sample to find your region of interest. It may also help to increase the field of view to get your bearings.  </li> <li>Once you have found your region of interest, move the milling patterns with the milling controls. Press shift + left click to move the selected pattern, or cntrl + shift + left click to move all the patterns (keeping the same orientation). Patterns cannot be placed outside the image. You can adjust the dimensions and settings for the patterns in the Milling tab.  For best results, make sure your beams are coincident and the lamella and fiducial are placed along the horizontal centre of the image (aligned with the tilt axis).</li> <li>Once you are happy with your pattern positions, press Save Position (in the Experiment tab). The button will switch from orange to green and indicate 'Position Ready'.</li> <li>Repeat steps 1 - 5 until you have selected all your lamella positions.</li> <li>When you are ready, press Run Setup AutoLamella.</li> </ol>"},{"location":"autolamella/walkthrough/#setup-autolamella","title":"Setup AutoLamella","text":"<p>After pressing Setup AutoLamella:</p> <ol> <li>The software will move to the first selected lamella position and if supervision is enabled ask you to confirm the the milling patterns. Press Continue to confirm, or use the milling controls to adjust.</li> <li>Next, the alignment fiducial will be milling. The area around the fiducial will be used to align the lamella at each step. If supervision is enabled, ask you to confirm the milling operation. Press Run Milling to mill the fiducial, and then press Continue when happy with the fiducial.  </li> <li>After the fiducial has been milled, an alignment image is acquired.</li> <li>Steps 1 - 3 will be repeated for each selected lamella position.</li> </ol>"},{"location":"autolamella/walkthrough/#run-autolamella","title":"Run AutoLamella","text":"<p>After pressing Run AutoLamella</p> <ol> <li>The software will move back to the first selected lamella position, and re-align using the alignment image.</li> <li>The stress relief features (microexpansion, waffle notch) will be milled.  If supervision is enabled, ask you to confirm the milling operation. Press Run Milling to mill the pattern, and then press Continue when happy with the milling.</li> <li>The rough trench milling patterns will be milled (all lamella trenches except the final polishing).  If supervision is enabled, ask you to confirm the milling operation. Press Run Milling to mill the pattern, and then press Continue when happy with the milling.  </li> <li>Steps 1 - 4 will be repeated for each selected lamella position.</li> <li>Once rough milling has been completed for each lamella, the software will go back to the first selected lamella position, realign the alignment image, and begin final polishing.  If supervision is enabled, ask you to confirm the milling operation. Press Run Milling to mill the pattern, and then press Continue when happy with the milling.  </li> <li>Step 5 is repeated for all selected lamella positions.</li> <li>Once final polishing is completed the software will return to the Experiment Tab, where you can see the status of all selected lamella. You are free to select more lamella and run again, but it is recommended to remove your sample after final polishing to prevent contamination build up. </li> </ol>"},{"location":"autolamella/walkthrough/#waffle-method","title":"Waffle Method","text":"<p>The following walkthrough is for the waffle method. The default protocol is protocol-waffle.yaml.</p>"},{"location":"autolamella/walkthrough/#setup-experiment_1","title":"Setup Experiment","text":"<ol> <li>Connect to the Microscope (Connection Tab -&gt; Select Configuration -&gt; Connect to Microscope)</li> <li>Create an Experiment (File Menu -&gt; Create Experiment -&gt; Select Directory -&gt; Select Experiment Name)</li> <li>Load a Protocol (File Menu -&gt; Load Protocol -&gt; protocol-waffle.yaml). We recommend starting with this protocol, and editting it to suit your microscope and sample.</li> <li>Move the stage to the sample grid. You can save this position for future use in the Movement Tab (Movement Tab -&gt; Add Position -&gt; Give your position a name (e.g. Grid 01) -&gt; Export Position (save to file))</li> <li>Move the stage flat to the ion beam. This is the rotation and tilt that makes the sample perpendicular to the ion beam. You can use the Movement Tab -&gt; Move Flat to Ion Beam button to move to this position. If this does not move you to the current position, please check you have configured your microscope correctly.  </li> <li>Acquire Images. Use the Image Tab to acquire images with both beams. Images are required to display milling patterns.</li> <li>Make you beams coincident / eucentric. Use the movement controls to align the coincidence of the beams. First double click on a feature in the electron beam to centre it. Then press Alt + double click in the ion beam align the same feature coincident. The same feature should now be centred in both beams.  </li> </ol>"},{"location":"autolamella/walkthrough/#setup-trench-positions","title":"Setup Trench Positions","text":"<p>After you have setup your experiment, and microscope, you can now start selecting the trench positions. </p> <ol> <li>Add a Lamella. Change to the Experiment tab, and Add Lamella. You can use the same movement controls to navigate around the sample to find your region of interest. It may also help to increase the field of view to get your bearings.  </li> <li>Once you have found your region of interest, move the milling patterns with the milling controls. Press shift + left click to move the selected pattern, or cntrl + shift + left click to move all the patterns (keeping the same orientation). Patterns cannot be placed outside the image. You can adjust the dimensions and settings for the patterns in the Milling tab. </li> <li>Once you are happy with your pattern positions, press Save Position (in the Experiment tab). The button will switch from orange to green and indicate 'Position Ready'.</li> <li>Repeat steps 1 - 5 until you have selected all your lamella positions.</li> <li>When you are ready, press Run Waffle Trench Milling AutoLamella.</li> </ol>"},{"location":"autolamella/walkthrough/#using-the-minimap","title":"Using the Minimap","text":"<p>As an alternative to the above, you can also use the minimap to acquire a tiled image flat to the ion beam and select positions from there. To access the minimap, use the Tools Menu -&gt; Open Minimap Tool. </p> <ol> <li>Set the image beam type to Ion, and select your imaging settings. Recommended settings are Grid Size = 2000um, Tile Size = 500um, resolution 1024px, Dwell Time = 1us, Autocontrast, Autogamma. The save path and file name will be generated for you experiment automatically. </li> <li>Press Run Tile Collection. The software will acquire a tileset, and stitch it together. Currently overlap is not supported. </li> <li>Once the stitching is complete, you can add a new lamella position with Alt + Left Click. </li> <li>Change to the Position Tab and enable Display Pattern (and select trench) to see an overlay of the trench pattern in the image. </li> <li>To move an existing pattern, go to the Position Tab -&gt; Select the Position and press Shift + Left Click on the image to move it. You can also move the stage to the position by pressing Move to Position Name or by Double Left Clicking on the image. </li> <li>Optionally, if you have correlation data (fluroescence images) you can load them in the Correlation Tab and correlate them with your overview image. </li> <li>Once you are happy with the positions go back to the AutoLamella UI. </li> <li>In the AutoLamella UI, go through each selected position and press move to position. Once you are happy with your pattern positions, press Save Position (in the Experiment tab). The button will switch from orange to green and indicate 'Position Ready'. IMPORTANT: make sure you go to the position before pressing Save Position (otherwise it will save the position as wherever the stage currently is, we are working on making this more streamlined). </li> <li>When you are ready, press Run Waffle Trench Milling to start milling trenches. </li> </ol>"},{"location":"autolamella/walkthrough/#trench-milling","title":"Trench Milling","text":"<p>After pressing Trench Milling:</p> <ol> <li>The software will move to the first selected trench position, and restore the microscope state. </li> <li>The trench milling pattern (trench) will be milled. If supervision is enabled, ask you to confirm the milling operation. Press Run Milling to mill the pattern, and then press Continue when happy with the milling.</li> <li>Charge neutralisation will be run, this is to disapate ion charge built up during trench milling. </li> <li>Reference images will be acquired of the final trench. </li> <li>Steps 1 - 4 will be repeated for each selected position.</li> <li>Once all trenches have been milled, the software will return to the Experiment Tab and undercut milling will be enabled. Press Run Waffle Undercut Milling to start milling undercuts. </li> </ol>"},{"location":"autolamella/walkthrough/#undercut-milling","title":"Undercut Milling","text":"<p>After pressing Undercut Milling.</p> <ol> <li>The software will move the the first trench position, and restore the microscope state. </li> <li>The stage will rotate 180 degrees, and tilt flat to the electron beam to prepare for undercut milling. </li> <li>The software will use machine learning feature detection to align the lamella (trench) centre in the electron and ion beams. If supervision is enabled, it will ask you to confirm the feature detections. Drag the feature to move it to the correct location (if required), and then press Continue to proceed with the workflow. </li> <li>The stage will tilt down by the amount specified in the protocol protocol\"options\" (default is -5.0 deg). </li> <li>The software will detect the top of the lamella to be used to place the undercut pattern. If supervision is enabled, it will ask you to confirm the feature detections. Drag the feature to move it to the correct location (if required), and then press Continue to proceed with the workflow.  </li> <li>The undercut milling pattern (undercut) will be milled. If supervision is enabled, ask you to confirm the milling operation. Press Run Milling to mill the pattern, and then press Continue when happy with the milling.</li> <li>Steps 4 - 6 will repeat for the number of iterations specified in protocol\"milling\"[\"stages]</li> <li>The software will detect the centre of the lamella to re-align it to the centre of the image in both beams to restore coincidence after tilting. If supervision is enabled, it will ask you to confirm the feature detections. Drag the feature to move it to the correct location (if required), and then press Continue to proceed with the workflow. </li> <li>Reference images will be acquired of the final undercut. </li> <li>Steps 1 - 9 will be repeated for each selected position.</li> <li>Once all undercuts have been milled, the software will return to the Experiment Tab and Setup AutoLamella will be enabled. Press Run Setup AutoLamella to setup the final lamella milling. </li> </ol>"},{"location":"autolamella/walkthrough/#setup-and-run-autolamella","title":"Setup and Run AutoLamella","text":"<p>From here, the workflow is exactly the same as the on-grid method. For more details please see On-Grid Setup AutoLamella</p> <p>The same as for the on-grid method, after the final polishing workflow completes the software will return the Experiment Tab and display the status of each lamella. It is recommended that you remove your sample after final polishing to prevent contamination build up. </p>"},{"location":"autolamella/walkthrough/#liftout-method","title":"Liftout Method","text":"<p>[Under Construction]</p>"},{"location":"autolamella/walkthrough/#setup-protocol","title":"Setup Protocol","text":"<p>Both liftout method require additional protocol setup. This step will walkthrough configuring the protocol for your system. </p>"},{"location":"autolamella/walkthrough/#scan-rotation","title":"Scan Rotation","text":"<p>Liftout was developed with ion beam scan rotation set to 0 degrees. I've done my best to make it agnostic to the scan rotation (e.g. fliping the direction of movements), but can't promise i've considered everything. I know scan rotation = 180 deg is more common, but it's recommened to use 0 degrees for running liftout. I will update this note, when I have validated it works for 180 deg rotation too. If you use 180 degrees rotation, and encountered specific issues, please let me know at patrick@openfibsem.org.</p>"},{"location":"autolamella/walkthrough/#named-positions","title":"Named Positions","text":"<p>You will need to define two named positions, to specify which grid is for milling and which is for landing. Respectively these are called trench_start_position and landing_start_position in the protocol.  </p> <p>To specify these named positions, you first need to add them to the positions.yaml file. To add the named positions.</p> <ol> <li>Open OpenFIBSEM UI / AutoLamella UI / AutoLiftout UI, connect to the microscope.</li> <li>Change to the Movement Tab.</li> <li>Move the stage to the grid you want to use for milling. Go flat to the Ion beam.</li> <li>Press Add Position. Rename the position, and press update. You can call it whatever you like, but recommended is something like liftout-grid-01-milling.</li> <li>Move the stage to the grid you want to use for landing. Go to the landing angle.</li> <li>Press Add Position. Rename the position, and press update. You can call it whatever you like, but recommended is something like liftout-grid-02-landing.</li> <li>Press Export Positions and select the positions.yaml. Choose to overwrite and append to the file. </li> <li>Reload AutoLiftout UI, connect to the microscope, and create/load your experiment/protocol to see these named positions in the Protocol tab.</li> <li>Set the Lamella Start Position and Landing Start Position to your named position. Update Protocol and Save Protocol (File Menu -&gt; Save Protocol).</li> </ol>"},{"location":"autolamella/walkthrough/#setup-autoliftout","title":"Setup AutoLiftout","text":"<p>The Setup AutoLiftout workflow will walk you through selecting milling positions and their corresponding landing positions. </p> <ol> <li>The software will move the stage to the position specified as Lamella Start Position.  </li> <li>Navigate to the region of interest, and select the position to mill the trenches. You can also adjust the milling patterns in the milling tab. The trench overlay is only for navigation and selection and won't be milled yet. Press Continue when you are happy. </li> <li>You will be asked if you want to continue selecting milling positions. Press Yes and Step 2 will be repeated for a new milling position. Continue selecting positions until you are happy. Press No to continue to select landing positions.</li> <li>The software will move the stage to the position specified as Landing Start Position. </li> <li>Navigate to the landing post / grid, and mill the surface flat. Press Run Milling to mill the flatten pattern, and then press Continue when happy with the milling.</li> <li>Step 5 will be repeated for each selected milling position.</li> <li>Once you have selected and milled each landing position, the software will return to the Experiment Tab. You should see the status of each lamella. </li> <li>When you are ready, press Run AutoLiftout to begin the workflow. </li> </ol>"},{"location":"autolamella/walkthrough/#run-autoliftout","title":"Run AutoLiftout","text":"<p>The AutoLiftout workflow consists of four tasks; trench milling, undercut milling, liftout and landing. Trenches and Undercuts are the same workflow as in the waffle method, and can be completed in batch, but liftout and landing have to be completed sequentially for each lamella. </p> <p>For details on the trench and undercut milling, please see the above walkthrough. The only different between these workflows is the milling patterns for the trench and undercut which are defined in the protocol. </p>"},{"location":"autolamella/walkthrough/#liftout","title":"Liftout","text":"<p>Before starting Liftout you will be asked if you want to Continue Lamella-01-XX from LiftoutLamella. You will need to complete both Liftout and Landing for each laemlla in sequence, and this is the last point you can interrupt without losing your lamella. Once you are ready, press Continue to start Liftout. Press Skip to continue to the next lamella. </p> <ol> <li>The software will move the stage to the undercut position, and restore the microscope state. </li> <li>The software will use machine learning feature detection to align the lamella (trench) centre in the electron and ion beams. If supervision is enabled, it will ask you to confirm the feature detections. Drag the feature to move it to the correct location (if required), and then press Continue to proceed with the workflow. </li> <li>The manipulator will be inserted above and to the left of the lamella trench. The software will use machine learning feature detection to detect the manipulator tip and the left edge of the lamella. If supervision is enabled, it will ask you to confirm the feature detections. Drag the feature to move it to the correct location (if required), and then press Continue to proceed with the workflow. </li> <li>Step 3 will be repeated several times in different beams to align the manipulator to the left of the lamella edge. If supervision if enabled you will be asked to confirm the position of the manipulator. Use the manipulator controls to adjust if required. </li> <li>The sample will be charged with the ion beam. The software will use machine learning feature detection to detect the manipulator tip and the left edge of the lamella and move them to contact. If supervision is enabled, it will ask you to confirm the feature detections. Drag the feature to move it to the correct location (if required), and then press Continue to proceed with the workflow. </li> <li>If using brightness based contact detection, the manipulator will be iteratively moved towards the lamella until contact is detected. If not, no additional movement is made. </li> <li>The manipulator is moved slightly up to avoid bottoming out, and make better surface contact with the lamella.</li> <li>If liftout weld is selected, the manipulator is welded to the lamella with a milling redeposition pattern. If no weld is selected, the software continues on. </li> <li>The software will use machine learning feature detection to detect the right edge of the lamella. If supervision is enabled, it will ask you to confirm the feature detections. Drag the feature to move it to the correct location (if required), and then press Continue to proceed with the workflow. </li> <li>The sever milling pattern (sever) will be milled. If supervision is enabled, ask you to confirm the milling operation. Press Run Milling to mill the pattern, and then press Continue when happy with the milling.</li> <li>The manipulator is removed from the trench, and then retracted fully.</li> <li>The software will then ask you to continue with Land Lamella. It is recommended you complete landing immediately.</li> </ol>"},{"location":"autolamella/walkthrough/#landing","title":"Landing","text":"<ol> <li>The softwre moves the stage to the landing position selected earlier and aligns to the reference image. </li> <li>The manipulator will be inserted above and to the left of the landing post. The software will use machine learning feature detection to detect the right edge of the lamella and the landing post. If supervision is enabled, it will ask you to confirm the feature detections. Drag the feature to move it to the correct location (if required), and then press Continue to proceed with the workflow.</li> <li>Step 2 will be repeated several times in different beams to land the lamella right edge on the landing post.</li> <li>After landing, if supervision is enabled, the software will ask you to confirm the lamella has landed. Press Continue if it has landed to continue with the workflow, or press Repeat to repeat the last step.</li> <li>The software detects the lamella right edge to place the weld milling pattern. If supervision is enabled, it will ask you to confirm the feature detections. Drag the feature to move it to the correct location (if required), and then press Continue to proceed with the workflow.</li> <li>The weld milling pattern (weld) will be milled. If supervision is enabled, ask you to confirm the milling operation. Press Run Milling to mill the pattern, and then press Continue when happy with the milling.</li> <li>The sample will be discharged, and optionally this procedure can be repeated. If the manipulator was welded to the lamella, the cut is performed here. </li> <li>The manipulator moves back from the landing post. If supervision is enabled, you will be asked to confirm if the landing was successful. Press Continue to continue with the workflow, or Repeate to retry the landing attempt (deposition free attachment only).</li> <li>You can optionally reset (re-sharpen, mill) the manipulator. This is not required for deposition free attachment method.</li> </ol> <p>The software will now repeate Liftout and Landing for each selected position. Once all landings are completed (or you exit early), you can move onto polishing lamella with AutoLamella workflow. </p>"},{"location":"autolamella/walkthrough/#liftout-run-autolamella","title":"Liftout - Run AutoLamella","text":"<p>From here, the workflow is exactly the same as the on-grid method. For more details please see On-Grid Setup AutoLamella. The only difference is the stage will move to a different angle for lamella milling as specified in the protocol under protocol\"options\"</p> <p>The same as for the on-grid method, after the final polishing workflow completes the software will return the Experiment Tab and display the status of each lamella. It is recommended that you remove your sample after final polishing to prevent contamination build up.</p>"},{"location":"autolamella/walkthrough/#serial-liftout-method","title":"Serial Liftout Method","text":"<p>[Under Construction]</p>"},{"location":"autolamella/walkthrough_v1/","title":"Walkthrough","text":"<p>This is a general walkthrough on running an autolamella workflow. Further details can be viewed in their respective documentation and some are linked within this walkthrough.</p> <p>A guided video walkthrough can be found here</p> <p>You can find more details on the application features here: Autolamella Features</p>"},{"location":"autolamella/walkthrough_v1/#methods","title":"Methods","text":"<p>The autolamella program has incorporated two possible workflows that can be achieved. One is the default auto lamella which is the standard lamella preparation workflow. The other is the waffle method workflow which has been recently developed as outlined in this paper. </p> <p>From a user interface perspective, both methods can be setup and run in a near identical fashion. The core processes of selecting lamella positions, milling parameters, supervision and monitoring can be set up the same way for both methods.</p>"},{"location":"autolamella/walkthrough_v1/#connection-and-setup","title":"Connection and Setup","text":"<p>The first step is to connect to the microscope. This can be setup to be done manually or automatically if the system parameters are setup in the system.yaml file.</p> <p>To connect, first launch the autolamella program. Then in the connect tab (Under the system tab), enter the IP address of the microscope server and select the manufacturer of the microscope. Then click connect. </p> <p></p> <p>Once connected, create an experiment from the file menu by clicking create experiment. This will prompt you to choose a location to save the experiment folder which contains the experiment.yaml file. </p> <p>The experiment file contains all the information about the experiment and the lamellae. This includes the positions of the lamellae, the milling parameters, and the status of each lamella.</p> <p>Once an experiment has been created, the experiment can be reloaded anytime by clicking load experiment from the file menu. This will prompt you to select the experiment.yaml file to load.</p> <p>The next step is to load a protocol. Select load protocol from the file menu. This will prompt you to select a protocol.yaml file to load. A default one is provided, however, it can be modified to suit your needs. In the protocol tab, changes can be made and then saved. Details on each parameter is explained in the features section of the documentation under Lamella protocol. !</p> <p></p> <p>To update the changes for the current session, click update protocol. To save these changes to a new protocol file, click save protocol. This will prompt you to select a location to save the protocol.yaml file. </p>"},{"location":"autolamella/walkthrough_v1/#adding-lamellae","title":"Adding Lamellae","text":"<p>Once the system is setup, the first step is to acquire images and move to a location for creating a lamella. This can be done by clicking acquire all images in the imaging tab. This will acquire all the images and display them in the napari viewer. To move, directly to some coordinates, you can move to a position in the movement tab. Alternatively, you can also click on the image to move to that position. The movement tab also has controls for tilting and moving flat to the ion or electron beam.</p> <p>Once at a desired location, click add lamella to add a lamella to the experiment. This will setup a position. To move around, double clicking on the image will move the stage to that position. Alternatively, you can also move to a position in the movement tab. </p> <p></p> <p>This image shows an example of the setup when using the waffle method workflow. However, the initial placement phase is identical for the default workflow. </p> <p></p> <p>To remove a lamella, click remove lamella and this will remove it from the experiment. The dropdown next to current lamella can be used to select a lamella individually and remove it or change its placement as necessary. Once satisfied with the placement, click save position to confirm its location. Additional lamellae can be added and saved in the same way. Once all the lamellae location have been saved, the process can continue to the next step.</p>"},{"location":"autolamella/walkthrough_v1/#workflow","title":"Workflow","text":"<p>The process now diverges based on which workflow is being used. </p>"},{"location":"autolamella/walkthrough_v1/#default-workflow","title":"Default Workflow","text":""},{"location":"autolamella/walkthrough_v1/#setup","title":"Setup","text":"<p>With lamellae chosen and position saved. The button labelled \"Run Setup Autolamella\" will be highlighted. Clicking this will begin the process of setting up the lamellae and confirming the position. </p> <p>To make any changes to the milling parameters, click on the milling tab. In the dropdown labelled milling stage, the specific aspect can be selected. The paraemters such as width and height can then be changed. </p> <p>For multiple lamellae, the program will iterate through the lamellae and setup each one. Each individial lamella has its own state saved.</p> <p></p> <p>Changes to the fiducial, microexpansion or notch can also be done here. Once satisfied with the process, press the continue to progress through the setup into the milling process. If a fiducial is being used, it will mill the fiducial at this stage.</p>"},{"location":"autolamella/walkthrough_v1/#run-autolamella","title":"Run Autolamella","text":"<p>Once setup is complete and the program is ready to run autolamella, click the Run Autolamella button in the experiment tab to begin the process. This will begin the process of milling the lamella.</p> <p>It will now run through each stage in the lamella preparation phase. Press run milling in the milling tab to run the milling process in each stage. Once again, any last minute changes can be made at the milling tab. </p> <p></p> <p>If milling is unsatisfactory, changes can be made and the milling process can be redone by clicking Run Milling again. Once satisfactory, click continue to move to the next stage. </p> <p>The program will run through each stage on multiple lamellae before moving onto the next stage. i.e. it will mill the rough trenches for all the lamellae before moving onto the next stage for any lamella.</p> <p>Once all the stages have been completed and the lamellae have been prepared, the experiment is complete. In the main experiment tab, the status of each lamella will be marked as finished.</p> <p></p>"},{"location":"autolamella/walkthrough_v1/#waffle-method","title":"Waffle Method","text":"<p>The waffle method for lamella preparation involves a different workflow. </p> <p>The initial trenches are milled in a way to allow for undercuts to be performed. Once these are done, the lamellae are milled in the usual fashion as the default workflow</p>"},{"location":"autolamella/walkthrough_v1/#waffle-trenches","title":"Waffle Trenches","text":"<p>Once the positions have been selected as outlined above, click Run Waffle Trench Milling to begin the process</p> <p>Similar to the default workflow, at each stage, the program will iterate through each stage for each lamella and allow you to make changes to the milling if necessary. If the milling is unsatisfactory, click Run Milling again to redo the milling. Once satisfied, click continue to move to the next stage.</p> <p></p>"},{"location":"autolamella/walkthrough_v1/#waffle-undercut","title":"Waffle Undercut","text":"<p>Once the waffle trenches have been milled, the next step is to perform undercuts on the lamellae. The Run waffle Undercut Milling button will be highlighted. Clicking this will begin the process of undercutting the lamellae.</p> <p>If the trench milling was unsuccessful and cannot be redone, you can mark the specific lamella as Failed. This will skip the rest of the process for that lamella. The status of the lamella will be marked as failed in the main experiment tab.</p> <p></p> <p>The undercut milling begins by first identifying the location of the lamella centre, this brings up the detection tab where the user can verify that the lamella centre has been detected correctly by the program. If incorrect, the centre location can be manually adjusted by dragging the location point.</p> <p></p> <p>Once detection is verified, the stage will tilt to the specified undercut tilt angle and relaunch the centre verification process from the tilted angle. Once the centre location has been verified, it will return to the milling tab to confirm the milling step. As usual, any changes to be made can be done so and remilling can be done until result is satisfactory. Once satisfied, click continue to move to the next stage.</p> <p>The program will continue to tilt to the next undercut and rerun the process. By default, there are two undercuts, however, any number of undercuts can be set up.</p> <p>It will perform all the undercuts for each lamella before moving onto the subsequent lamella</p> <p>Once the undercuts are done, the next stages are identical to the default workflow. In the main experiment tab, the Run Setup Autolamella will be highlighted and the process can continue as outlined above.</p>"},{"location":"autolamella/walkthrough_v1/#features-and-details","title":"Features and Details","text":"<p>This walkthrough goes through a basic outline of the autolamella process. However, there are a vast array of tools and features available to customise and automate the process. These are outlined in the features section of the documentation. </p>"},{"location":"autoliftout/","title":"AutoLiftout","text":""},{"location":"autoliftout/GettingStarted/","title":"Getting Started","text":"<p>To get started using AutoLiftout, you will need to install the program and prepare your microscope and sample.  Once you have done this, you can run the program.</p>"},{"location":"autoliftout/GettingStarted/#installation","title":"Installation","text":""},{"location":"autoliftout/GettingStarted/#install-dependencies","title":"Install Dependencies","text":"<p>Please see OpenFIBSEM for how to install the dependencies.</p>"},{"location":"autoliftout/GettingStarted/#install-autoliftout-environment","title":"Install AutoLiftout Environment","text":"<p>Clone this repository: </p> <pre><code>$ git clone https://github.com/DeMarcoLab/autoliftout.git\n</code></pre> <p>Install dependencies and package</p> <pre><code>$ cd autoliftout\n$ conda env create -f environment.yml\n$ conda activate autoliftout\n$ pip install -e .\n</code></pre>"},{"location":"autoliftout/GettingStarted/#preparation","title":"Preparation","text":"<p>We used the following microscope and setup for AutoLiftout:</p> <ul> <li>Microscope: ThermoFisher Helios Hydra PFIB</li> <li>Sample: Drosophila Embryo on Carrier</li> <li>Landing Post: Ted Pella Posts (8)</li> <li>Shuttle: 35 Degree Pre-Tilt (Carrier + Autogrid slots)</li> <li>Manipulator: (TODO: needle brand)</li> </ul>"},{"location":"autoliftout/GettingStarted/#preparing-the-manipulator","title":"Preparing the Manipulator","text":"<p>Before starting autoliftout, you will need to prepare the manipulator:</p> <ul> <li>Mill the end of your manipulator so there is a 10um flat vertical surface. TODO: image @patrickcleeve2</li> <li>Perform EasyLift Alignment (Needle Calibration)</li> </ul>"},{"location":"autoliftout/GettingStarted/#running-the-program","title":"Running the Program","text":"<p>To run autoliftout enter the following command in your terminal:</p> <pre><code>autoliftout_ui\n</code></pre> <p></p> <p>(@patrickcleeve2 change this flow, it is weird. Should be something like: Start -&gt; New Experiment or Load Experiment -&gt; Run Experiment)</p> <ol> <li>Enter a name for your experiment (All experiments are saved in autoliftout/liftout/log)</li> </ol> <p></p> <p>To edit your protocol / settings before you start your experiment, click the Edit-&gt;Edit Protocol button. This will open the protocol editor. You can edit the protocol and save it by clicking the \"Save\" button. You can also load a previously saved protocol by clicking the File-&gt;Load Protocol button.</p> <p></p> <ol> <li> <p>You can now start your experiment by clicking the \"Setup AutoLiftout\" button. </p> </li> <li> <p>You will be guided through the setup process. Follow the instructions on the screen and click \"Continue\" when you are ready to move on. Setup consists of two steps:</p> </li> <li> <p>Selecting the lamella positions.</p> </li> <li>Selecting the landing positions.</li> </ol> <p>Once Setup is complete, the 'Run AutoLiftout' button will be enabled. Click this button to start autoliftout.</p> <ol> <li> <p>You will be guided through the run process. Follow the instructions on the screen and click \"Continue\" when you are ready to move on. The autoliftout workflow consists of the following stages:</p> </li> <li> <p>MillTrench: Lamella are milled to create a trench (Upper, Lower, Side Release).</p> </li> <li>MillUndercut: Lamella are milled to create an undercut. (Underside Release)</li> <li>Liftout:  Lamella are lifted out of the trench using the manipulator.</li> <li>Landing:  Lamella are landed on the landing posts.</li> <li>Reset: Manipulator is sharpened and returned to the home position [Optional].</li> </ol> <p>As these stages complete, the user interface will update to show the progress of the experiment.</p> <p></p> <p>You are able to add more lamella positions to your experiment by re-running the 'Setup AutoLiftout' button. This will allow you to add more lamella positions to your experiment. You can also change the lamella options by clicking the 'Lamella Tab'. This will allow you to lamella properties for the experiment. Lamellas marked as failed are not included in the experiment.</p> <p></p> <ol> <li> <p>Once AutoLiftout is finished, the 'Run MillPolishingCut' button will be enabled. Click this button to start polishing. The MillPolishingCut workflow consists of the following stages:</p> </li> <li> <p>SetupPolish: User selects the region of the lamella to polish.</p> </li> <li>MillRoughCut:  Lamella are thinned to removal bulk of material.</li> <li>MillPolishingCut: Lamella are polished to electron transparency</li> </ol> <p>It is recommended that you run the polishing workflow after all lamella have been lifted. We have found this helps prevent contamination build-up. However, you can run the polishing workflow at any time.</p> <ol> <li>You are able to view the statistics for the run by opening a new terminal and entering the following command:</li> </ol> <pre><code>cd autoliftout/liftout/tools\nstreamlit run stats.py\n</code></pre> <p>The following stats page will open up in a web browser. Enter the name of the experiment you would like to view, and the statistics should populate. </p> <p>For a more detailed guide of the workflow, see the User Guide page.</p>"},{"location":"autoliftout/GettingStarted/#troubleshooting","title":"Troubleshooting","text":"<p>If you find any bugs or issues with the program, please create an issue on the GitHub Issues page. </p>"},{"location":"autoliftout/Manufacturing/","title":"A Manufacturing Approach","text":""},{"location":"autoliftout/UserGuide/","title":"User Guide","text":"<p>AutoLiftout is an automated liftout program for the preparation of cryo-lamella. 1</p>"},{"location":"autoliftout/UserGuide/#the-workflow","title":"The Workflow","text":"<p>The AutoLiftout workflow consists of a number of stages that must be completed sequentially.</p>"},{"location":"autoliftout/UserGuide/#setup","title":"Setup","text":"<ul> <li>The user selects lamella and landing positions.</li> </ul> Description Electron Beam Ion Beam Lamella Position (Low) Lamella Position (High) Landing Position (Low) Landing Position (High) <ul> <li>Optionally sputter platinum to protect the sample.</li> </ul>"},{"location":"autoliftout/UserGuide/#mill-trench","title":"Mill Trench","text":"<p>Mill lower, upper and side trenches using high currents. (horsheshoe pattern, see ref)</p> <ul> <li>Lower and Upper trenches release lamella from the bulk.</li> <li>Side trench provides access for the needle.</li> </ul> Description Electron Beam Ion Beam Trench Position (Low) Trench Position (High)"},{"location":"autoliftout/UserGuide/#mill-undercut","title":"Mill Undercut","text":"<ul> <li>Mill the underside and part of the other side of the lamella to release from the base of the bulk. Undercut is also refered to as the jcut.</li> </ul> Description Electron Beam Ion Beam Undercut Position (Low) Undercut Position (High)"},{"location":"autoliftout/UserGuide/#liftout","title":"Liftout","text":"<ol> <li>Insert the needle, and guide to near the lamella.</li> <li>Charge the sample with the ion beam</li> <li>Make contact with the lamella,</li> <li>Sever the lamella from the bulk.</li> <li>Retract the needle.</li> </ol> Description Electron Beam Ion Beam Liftout Entry Position Liftout Ready Position Liftout Contact Position Liftout Sever Position Liftout Retract Position"},{"location":"autoliftout/UserGuide/#landing","title":"Landing","text":"<ol> <li>Insert the needle, and guide the lamella to the post</li> <li>Weld lamella to the post</li> <li>Discharge the lamella with the electron beam</li> <li>Removal the needle from the lamella</li> <li>Retract the needle</li> </ol> Description Electron Beam Ion Beam Landing Entry Position 0 Landing Entry Position 1 Landing Entry Position 2 Landing Entry Position 3 Landing Ready Position Landing Weld Position Landing Removal Position Landing Retract Position"},{"location":"autoliftout/UserGuide/#millpolishingcut-setup","title":"MillPolishingCut Setup","text":"<ul> <li>The user selects the regions of the lamella to polish</li> </ul> Description Electron Beam Ion Beam Polish Setup Position (Low) Polish Setup Position (High) Polish Setup Position (Ultra)"},{"location":"autoliftout/UserGuide/#millroughcut","title":"MillRoughCut","text":"<ul> <li>Thin the lamella to a lower thickness, using a relatively high current.</li> </ul> Description Electron Beam Ion Beam MillRoughCut Position (Low) MillRoughCut Position (High) MillRoughCut Position (Ultra)"},{"location":"autoliftout/UserGuide/#millpolishingcut","title":"MillPolishingCut","text":"<ul> <li>Polish the lamella to electron transparent thickness.</li> <li>Should be completed immediately prior to transfer to prevent contamination buildup.</li> </ul> Description Electron Beam Ion Beam MillPolishingCut Position (Low) MillPolishingCut Position (High) MillPolishingCut Position (Ultra)"},{"location":"autoliftout/UserGuide/#methods","title":"Methods","text":"<p>We have developed a number of different methods for performing liftout. We believe these methods provide a more reliable, and higher throught liftout workflow. The methods developed work are complementary.</p> <p>For more background on these methods, please read: AutoLiftout: A manufacturing approach.</p>"},{"location":"autoliftout/UserGuide/#manipulator-preparation","title":"Manipulator Preparation","text":"<p>We flatten the side of the needle to prepare for the maximum surface contact area with the side of the lamella.</p> <p>TODO: images</p>"},{"location":"autoliftout/UserGuide/#landing-surface-preparation","title":"Landing Surface Preparation","text":"<p>We flatten the side of the landing post to prepare for the maximum surface contact area with the side of the lamella. TODO: images</p>"},{"location":"autoliftout/UserGuide/#charge-control","title":"Charge Control","text":"<p>Biological samples in cryogenic conditions often have large amounts of charge which causes challenges with imaging. Often this charging saturates the detectors and images either glow white or completely dark. To overcome this issue, we have developed the following techniques:</p> <ul> <li>AutoGamma: We automatically apply a digital gamma correction to the image if sufficient mean pixel intensity is determined. Gamma correction shifts the image histogram allowing features to be detected in the image (however it reduces image quality).</li> <li>Charge Neutralisation: To reduce the accumulated charge, we apply a charge neutralisation procedure (e.g. taking a rapid series of electron images to neutralise ion charge after large milling operations). This helps control the charge buildup throughout the process.</li> </ul> <p>TODO: images</p>"},{"location":"autoliftout/UserGuide/#big-lamella","title":"Big Lamella","text":"<p>To provide better landing stability, we liftout much larger lamella than typical. In conjunction with Manipulator Preparation, Landing Surface Preparation, and Side Pickup we are able to make consistent, right-angled contact with a large surface area between the lamella and the landing post. This provides a more stable base from which to thin the lamella down. The downside of using this method is an increased material waste, and increased thinning time to remove excess material.</p> <p>TODO: images</p>"},{"location":"autoliftout/UserGuide/#side-pickup","title":"Side Pickup","text":"<p>To provide better liftout, and landing stability we make contact with the side of the lamella to lift it out of the trench. The side pickup provides the following benefits:</p> <ul> <li>More stability on contact: we apply a compressive force to the side of the lamella, instead of bending (if touching from the top). This allows us to make firmer contact without bottoming out the lamella in the trench.</li> <li>Better orientation for landing: Due to the lack of rotation/tilt control the angle of liftout determines the orientation for landing the lamella. When lifting from the top of the lamella, it can sometimes rotate, roll or slide of the needle tip when making contact with the post causing bad landing orientation. It is analogous to spinning a basketball on your finger, it can be done but is difficult to repeat. Making contact from the side allows for the lamella to be evenly compressed between the needle and the post, maintaining its orientation.</li> </ul>"},{"location":"autoliftout/UserGuide/#contact-detection","title":"Contact Detection","text":"<p>In order to determine whether the needle and lamella have made sufficient contact, we developed a contact detection procedure.</p> <ul> <li>We monitor the image brightness, whilst driving the needle towards the lamella.</li> <li>When contact is made between the needle and lamella, there is a significant increase in brightness due to charge disipation. This effect occurs due to the charge build up in the platinum crust being grounded when contact is made with the needle.</li> <li>We detect this change, and stop the needle movement.</li> </ul> Example 01 Example 02 Example 03 Example 04"},{"location":"autoliftout/UserGuide/#charge-pickup","title":"Charge Pickup","text":"<p>We have developed a repeatable procedure for lifting the lamella by only manipulating the charge buildup. This method does not rely on platinum deposition, or welding (redeposition).</p> <ul> <li>To attach: We move the needle and lamella close together, and take a series ion beam images to build up charge. When the lamella and needle make contact they stick together with static due to charge.</li> <li>To dettach: Once the lamella is welded to the landing post, we run the electron beam to disapate the charge, and the needle slides off the lamella.</li> </ul> <p>The procedure is still being developed, and understood and is very sensitive to parameters and different conditions (e.g. the number of images being taken).</p>"},{"location":"autoliftout/UserGuide/#liftout-attach","title":"Liftout (Attach)","text":"Description Ready Contact Sever Electron View Ion View"},{"location":"autoliftout/UserGuide/#landing-dettach","title":"Landing (Dettach)","text":"Description Ready Weld Removal Electron View Ion View"},{"location":"autoliftout/UserGuide/#automation","title":"Automation","text":"<p>The program uses the following features to progress through the workflow.</p>"},{"location":"autoliftout/UserGuide/#state-restoration","title":"State Restoration","text":"<p>State restoration provides a way to \u2018checkpoint\u2019 the position of the workflow. The state is saved at the end of each stage, and can be restored at any time.</p> <ul> <li>When continuing to the next stage, the program will initially restore to the previous microscope state before continuing.</li> <li>This allows the user to restart, pause or close the program and continue from where they left off (assuming no catastrophic lamella damage).</li> <li>This also allows multiple lamella stages to be batch produced, e.g. perform all trench milling in a row. Note: Some lamella stages must be completed sequentially (e.g. Liftout -&gt; Landing).</li> </ul>"},{"location":"autoliftout/UserGuide/#alignment","title":"Alignment","text":"<p>The program uses a fourier cross-correlation to align to reference images.</p> <ul> <li>This alignment is used when a quality reference image is available, for example alignment after restoring state to account for hardware limitations.</li> <li>In general the alignment will use the stage movement to correct, but a higher precision beam shift alignment will be used for higher precision tasks.</li> </ul> <p></p>"},{"location":"autoliftout/UserGuide/#feature-detection","title":"Feature Detection","text":"<p>The program uses a segmentation model to detect common features in the workflow, these include the Needle Tip, the Lamella and the Landing Post.</p> <ul> <li>These feature positions are used to guide the program decision making. For example, the model is used to guide the needle tip to make contact with the lamella.</li> <li>When supervising the user can correct these feature detections using an integrated user interface. This is discussed in the next section.</li> </ul> <p></p>"},{"location":"autoliftout/UserGuide/#user-interface","title":"User Interface","text":"<p>We provide a user interface to enable the user to run the microscope and autoliftout with minimal training.</p>"},{"location":"autoliftout/UserGuide/#ease-of-use","title":"Ease of Use","text":"<p>The launch ui is where you will start when you open autoliftout. It allows you to create, and load experiments and protocols, as well as use stand alone tools such as sputtering platinum and settings validation.</p> <p></p> Edit Protocol UI Edit Lamella"},{"location":"autoliftout/UserGuide/#movement","title":"Movement","text":"<p>The movement ui allows the user to double click on the image to move the stage to the desired location. Two movement modes are available; Stable movements will maintain the eucentricty (ensure both beams are focused at the same point), while Eucentric movements will constrain the stage to move vertical to move the stage back to the eucentric point. When moving eucentricly, the user should first centre a feature in the Electron view, and then double click the same feature in the Ion view to correct the eucentricity.</p> <p></p>"},{"location":"autoliftout/UserGuide/#milling","title":"Milling","text":"<p>The milling ui provides control over the pre-defined patterns used in autoliftout. The user can adjust all the parameters of these patterns to suit their needs. These parameters can be saved on the go to the protocol file.</p> <p></p>"},{"location":"autoliftout/UserGuide/#supervision-mode","title":"Supervision Mode","text":"<p>Users can choose to supervise the workflow by enabling it in the protocol. In this mode, the program will automatically perform all the movements and operations, but will pause and ask the user for confirmation before continuing. Supervision can be turned on/off for individual stages.</p> <p>Feature Detection An example of supervision is the feature detection interface. While in supervision mode, the program will show the user the detected features, and the movement plan. The user can simply click to correct the detected feature, and change the calculated movements.</p> <p></p> <p>Other supervised steps will ask the user to confirm milling operations, and enable the movement interface to correct alignments.</p>"},{"location":"autoliftout/UserGuide/#adapting-to-new-use-cases","title":"Adapting to New Use Cases","text":"<p>AutoLiftout has been designed to be adapted to a range of samples, conditions, and systems. We have attempted to provide a number of variables</p>"},{"location":"autoliftout/UserGuide/#changing-the-system","title":"Changing the System","text":"<p>The system specification and settings can be changed by editing the system.yaml file.</p> <ul> <li>This file defines the system configuration, and the beam settings you want to use for the run.</li> <li>For example, you may choose to use a different detector mode, or type or a different plasma gas.</li> <li>In particular, the stage definitition is important as it defines the relative coordinates of the stage and beams. If you're microscope is different you will need to adjust these parameters.</li> </ul>"},{"location":"autoliftout/UserGuide/#changing-the-protocol","title":"Changing the Protocol","text":"<p>The user can manually edit the protocol.yaml file to change any of the available parameters.</p> <ul> <li>When using the user interface, changes to the milling parameters will prompt the user to update their protocol file.</li> <li>New protocols can be loaded in the launch user interface.</li> </ul>"},{"location":"autoliftout/UserGuide/#model-retraining","title":"Model Retraining","text":"<ul> <li>The provided model can be finetuned for a new dataset (sample, conditions, etc).</li> <li>The most efficient way to collect a new dataset is to run autoliftout in supervised mode using your desired sample/conditions. Whenever the user corrects a feature detection using the interface, the program will automatically flag that image for labelling and save it in a separate directory.</li> <li>The user can then use OpenFIBSEM machine learning tools to label and finetune the model on the new dataset. For more information on these tools please see the OpenFIBSEM repository.</li> </ul> <p>Supervision Mode</p> <p></p> <p>OpenFIBSEM Labelling UI</p> <p></p> <p>Model Redeploy after Training</p>"},{"location":"autoliftout/UserGuide/#automation-tuning","title":"Automation Tuning","text":"<ul> <li>Variables used for automation can be changed by editing the code.</li> <li>Depending on your application you might need to adjust the cross-correlation masks and filter strengths, or step-sizes, or number of iterations.</li> <li>In a future release these will be separated into an external configuration file for easier editing.</li> </ul>"},{"location":"autoliftout/UserGuide/#analysis-tools","title":"Analysis Tools","text":"<p>To assist with tuning the program and workflow, we provide a number of analysis tools.</p> <ul> <li>Statistics: All run statistics are logged, and can be viewed using the following command:</li> </ul> <pre><code>streamlit run liftout/tools/stats.py\n</code></pre> <p>The following shows the statistics available for the entire run. Statistics for indivudal lamella are also available. All statistics are available for export as csv for further analysis. The following stats are from a development run:</p> - - - <p></p> <p></p> <p>Aggregrate statistics are also available for multiple datastes using the tools/statistics.ipynb notebook.</p>"},{"location":"blog/","title":"Blog","text":"<p>hello world</p>"},{"location":"fibsem/","title":"OpenFIBSEM","text":"<p>A universal API for FIBSEM control</p>"},{"location":"fibsem/#introduction","title":"Introduction","text":"<p>Focused Ion Beam Scanning Electron Microscopy (FIBSEM) systems are a powerful tool for imaging and modifying materials at the nanoscale. They consist of a set of common hardware components such as Electron Beam, Ion Beam, Stage, Manipulator, and Gas Injection System. Manufacturers such provide software API to control the hardware. However, each manufacturer has their own proprietary API which is not compatible with other manufacturers. This results in a need for users to learn multiple APIs if they work with different manufacturers or stick to one manufacturer. This also means that applications developed for one manufacturer's hardware may not be portable to another manufacturer's hardware.</p> <p>To address these issues, OpenFIBSEM provides a common API that can control the hardware across different manufacturers. The aim of OpenFIBSEM is to provide a universal interface that enables users to easily switch between manufacturers without needing to learn new proprietary software. With OpenFIBSEM, users can control FIBSEM systems from different manufacturers with a single, common API. This enables cross-platform applications, making it easier to move applications between different FIBSEM systems without needing to rewrite them for each manufacturer's proprietary API.</p> <p> A FIBSEM System Reference</p> <p>OpenFIBSEM aims to provide a core set of functionality, including the ability to control electron and ion beams, the stage, manipulator, and gas injection system. The project aims to expand this functionality over time. In addition, OpenFIBSEM also provides functionality for automation, machine learning, and image processing, enabling users to develop more advanced applications and workflows.</p> <p>In conclusion, OpenFIBSEM provides a universal API for controlling FIBSEM systems from different manufacturers. By providing a common interface, OpenFIBSEM aims to enable users to easily switch between manufacturers without needing to learn new proprietary software. This also enables cross-platform applications, making it easier to move applications between different FIBSEM systems without needing to rewrite them for each manufacturer's proprietary API. With OpenFIBSEM, users can leverage the power of FIBSEM systems to perform advanced imaging and modification tasks with greater ease and efficiency.</p>"},{"location":"fibsem/#supported-manufacturers","title":"Supported Manufacturers","text":"<p>Currently, OpenFIBSEM supports two FIBSEM manufacturers: ThermoFisher and Tescan. Support for additional manufacturers will be added in the future. </p> <p>For more information on future plans, please see Roadmap.</p>"},{"location":"fibsem/#getting-started","title":"Getting Started","text":"<p>For information on installation and getting started, please see Getting Started.</p>"},{"location":"fibsem/#examples","title":"Examples","text":"<p>For examples on how to use OpenFIBSEM, please see Examples.</p>"},{"location":"fibsem/#api-reference","title":"API Reference","text":"<p>For a breakdown of the API please see API Reference.</p>"},{"location":"fibsem/automation/","title":"Automation","text":"<p>OpenFIBSEM provides a number of modules to support automation.</p>"},{"location":"fibsem/automation/#image-processing","title":"Image Processing","text":"<p>We provide a number of image processing functions to support automation. These are available in <code>fibsem.imaging</code>  or <code>fibsem.acquire</code>.</p>"},{"location":"fibsem/automation/#autogamma","title":"AutoGamma:","text":"<p>Adjusting the gamma of the image can improve the contrast of the image. This is useful for aligning images, and can be used to improve the contrast of the image for feature detection. The following figure shows the effect of adjusting the gamma of the image. When the <code>autogamma</code> flag is enabled in <code>ImageSettings</code> the gamma of the images taken will be automatically adjusted with this method. </p> <p> Gamma Adjustment</p>"},{"location":"fibsem/automation/#autoclahe","title":"AutoCLAHE:","text":"<p>Contrast Limited Adaptive Histogram Equalization (CLAHE) is a method for improving the contrast of an image. When the <code>autoclahe</code> flag is enabled in <code>ImageSettings</code> the gamma of the images taken will be automatically adjusted with this method. AutoCLAHE has many parameters that can be tuned. The following figures shows the difference between the different autogamma methods. </p> <p> AutoGamma Functions</p> <p> AutoGamma Functions</p>"},{"location":"fibsem/automation/#alignment","title":"Alignment","text":"<p>The alignment module contains functions are aligning reference images, and tools and parameters for adjusting these alignments.</p> <p>WIP: images</p>"},{"location":"fibsem/automation/#cross-correlation","title":"Cross Correlation","text":"<p>The primary alignment method is fourier cross-correlation to a reference image. The following helper function provides the the methods for alignment, and the required movements, as well as parameters for tuning.</p> <p><pre><code>def align_using_reference_images(\n    microscope: SdbMicroscopeClient,\n    settings: MicroscopeSettings,\n    ref_image: AdornedImage,\n    new_image: AdornedImage,\n    ref_mask: np.ndarray = None,\n    xcorr_limit: int = None,\n    constrain_vertical: bool = False,\n    beam_shift: bool = False,\n    lp_px: int  = 128, \n    hp_px: int = 8,  \n    sigma: int = 6,\n) -&gt; bool:\n    \"\"\"Align new image to reference image using crosscorrelation\n\n    Args:\n        microscope (SdbMicroscopeClient): microscope client\n        settings (MicroscopeSettings): microscope settings\n        ref_image (AdornedImage): reference image\n        new_image (AdornedImage): new image\n        ref_mask (np.ndarray, optional): reference mask. Defaults to None.\n        xcorr_limit (int, optional): crosscorrelation limit. Defaults to None.\n        constrain_vertical (bool, optional): constrain vertical movement. Defaults to False.\n        beam_shift (bool, optional): use beam shift. Defaults to False.\n        lp_px (int, optional): lowpass filter size. Defaults to 128.\n        hp_px (int, optional): highpass filter size. Defaults to 8.\n        sigma (int, optional): gaussian filter sigma. Defaults to 6.\n    Returns:\n        bool: True if alignment was successful, False otherwise\n    \"\"\"\n</code></pre> In order to tune the alignment the user can adjust the following:</p>"},{"location":"fibsem/automation/#filtering","title":"Filtering","text":"<p>The cross correlation alignment can be tuned by adjusting the bandpass filters; lowpass, highpass; and sigma. These filters are applied in fourier space. - <code>lowpass</code>: upper pixel distance bound - <code>highpass</code>: lower pixel distance bound - <code>sigma</code>: blur applied to bandpass mask boundary</p> <p>The effect of these filters on the bandpass mask is shown below:</p> <p></p>"},{"location":"fibsem/automation/#masking","title":"Masking","text":"<p>We provide a number of masking utilities: </p> <ul> <li><code>circle_mask</code>: mask a circular area of the image. </li> <li><code>bandpass_mask</code>: mask a bandpass area of the image (donut)</li> <li><code>rect_mask</code>: mask a rectangular area of the image</li> <li><code>area_mask</code>: mask quarters of the image specified by left, right, upper, and lower params</li> <li><code>vertical_mask</code>: mask a central vertical area of the image</li> <li><code>invert</code>: invert the mask</li> </ul> <p>These masks can be passed to the <code>ref_mask</code>for use in the alignment, and are available in <code>fibsem.imaging.masks</code>. Many of these masking functions contain additional parameters, so please see the implementation for details. </p>"},{"location":"fibsem/automation/#movement","title":"Movement","text":"<p>By default, the function will move the stage to align the reference image. The following parameters adjust this movement. </p> <ul> <li><code>constrain_vertical</code>: this flag will constrain the stage to move only vertically (z). This is useful when attempting to correct the eucentric position using alignment.</li> <li><code>beam_shift</code>: this flag will adjust the shift the beam instead of moving the stage. The beam shift is more precise than the mechanical stage, but has a much lower range of movement (~10um?, check this)</li> </ul>"},{"location":"fibsem/automation/#utilities","title":"Utilities","text":"<p>We also provide a number of utility functions that can help with crosscorrelation. For example:</p> <ul> <li><code>rotate_image</code>: rotate the image 180deg while preserving metadata</li> <li><code>fromFibsemImage</code>: match the image settings used for reference image</li> </ul> <p>These utilities are available in <code>fibsem.imaging.utils</code>.</p>"},{"location":"fibsem/automation/#helper-functions","title":"Helper Functions","text":"<p>The <code>fibsem.alignment</code> module contains more helper functions for performing alignment workflows:</p> <ul> <li><code>correct_stage_drift</code>: multi-step alignment</li> <li><code>eucentric_correct_stage_drift</code>: multi-step alignment + eucentric alignment</li> </ul>"},{"location":"fibsem/automation/#feature-detection","title":"Feature Detection","text":"<p>We provide some feature detection functions and workflows primarly centred around the liftout workflow. These are customisable to the user's needs.</p> <p>The primary detection workflow uses the following to run the feature detection, transform coordinate systems, and optionally allows the user to validate the result. For more information on the user validation please see ml.md.</p> <p><pre><code>def detect_features_v2(\n    microscope: SdbMicroscopeClient,\n    settings: MicroscopeSettings,\n    features: tuple[Feature],\n    validate: bool = True,\n    mask_radius: int = 256,\n) -&gt; DetectedFeatures:\n\n    \"\"\"Detect features in microscope image.\n\n    Args:\n        microscope (SdbMicroscopeClient): microscope client\n        settings (MicroscopeSettings): microscope settings\n        features (tuple[Feature]): features to detect\n        validate (bool, optional): whether to validate features. Defaults to True.\n        mask_radius (int, optional): radius of mask to apply to image. Defaults to 256.\n\n    Returns:\n        DetectedFeatures: detected features\n    \"\"\"\n    ...\n</code></pre> </p> <p>The supported Feature Types are as follows:</p>"},{"location":"fibsem/automation/#machine-learning","title":"Machine Learning","text":"<p>We provide a basic machine learning pipeline and workflow. Currently only segmentation models are supported, but more will be added in the future.</p> <p>For detailed information on the machine learning tools, please see Machine Learning.</p>"},{"location":"fibsem/automation/#movement_1","title":"Movement","text":"<p>The movement module contains functions for moving the microscope stage. </p> <p>We provide a number of advanced movement functions that are useful for correcting and maintianing the eucentricity of the microscope.</p> <p></p>"},{"location":"fibsem/automation/#vertical-movement","title":"Vertical Movement","text":"<p>Vertical movements correct the eucentric position of the microscope. This is useful when initially setting up the microscope, or when the eucentric position has been lost. The vertical movements move the stage vertically in the chamber to correct the eucentric position.</p> <p></p> <p>To use eucentric movements, use:  <pre><code>microscope.vertical_move(dy)\n</code></pre></p> <p>where dy is the distance to move in the image plane (eucentric movements are always calculated from the ion beam perspective).</p>"},{"location":"fibsem/automation/#stable-movement","title":"Stable Movement","text":"<p>Stable movements maintain the sample at the eucentric position, allowing for movement along the sample plane without losing the eucentric position. This is useful for performing liftout, and other tasks that require movement along the sample plane.</p> <p></p> <p>To use stable movements, use:  <pre><code>microscope.stable_move(dx, dy, beam_type)\n</code></pre> where dx, dy are the distance to move in the image plane, and beam_type is the beam type to use for the movement.</p>"},{"location":"fibsem/doc_v2/","title":"OpenFIBSEM Documentation","text":""},{"location":"fibsem/doc_v2/#overview","title":"Overview","text":"<p>OpenFIBSEM is a platform built with python to allow high level FIB-SEM microscope control using a single package across multiple supported microscopes. Currently, support for microscopes of Thermo Fisher Scientific and TESCAN are actively being developed. </p> <p>The OpenFIBSEM package allows control of the microscope in the same syntactic manner regardless of the brand of microscope in use as the package is built upon the existing SDKs for both the different microscopes. </p> <p>The microscope client is set up using an internet connection. Hence the microscope control PC I.P. address needs to be set to connect. (\u201clocalhost\u201d if on a PC connected directly to a microscope).</p> <p>The microscope organisation is abstracted away in the FibsemMicroscope class. All hardware implementations follow the same abstract organisation. This allows for a black box approach in the external modules, where all calls to the microscope are independent of the specific hardware, and all direct calls to the APIs are limited to the class methods. </p> <p></p> <p>As an example, to take a set of reference images from the microscope using an electron beam and an ion beam, the syntax is as follows:</p> <pre><code>eb_image, ib_image = acquire.take_reference_images(microscope, image_settings)\n</code></pre> <p>In this case, the type of microscope is not relevant for the user and this method will work. However, the type of microscope must be initialised during setup. If the microscope in use is a supported Thermo Fisher or TESCAN microscope, it must be set up as so in the system.yaml file.</p> <p>Along with taking images, specific imaging parameters can also be specified. This can be done by creating and initialising an image settings object.</p>"},{"location":"fibsem/doc_v2/#setting-up-microscope","title":"Setting up Microscope","text":"<p>To set up a session with a microscope, relevant microscope type and connection parameters need to be set up in the system.yaml config file that is located in the following directory in the package:</p> <pre><code>\u2026/FIBSEM/fibsem/config/system.yaml\n</code></pre> <p>In the yaml file, the connection set up parameters required are - I.P. Address    - Address of the microscope to be used. The text \u201clocalhost\u201d is valid if the microscope to connect to is on the local pc - Manufacturer     - Microscope manufacturer, If the microscope brand is supported by its relevant SDK packages.</p> <pre><code># system\nsystem:\n  ip_address: \"localhost\" \n  application_file: autolamella\n  manufacturer: \"Thermo\"\n  # beams\n  ion:\n    voltage: 30000\n    current: 20.e-12\n    plasma_gas: \"Argon\" # proper case, e.g. Argon, Oxygen\n    eucentric_height: 16.5e-3\n    detector_type: ETD\n    detector_mode: SecondaryElectrons\n  electron:\n    voltage: 2000\n    current: 1.0e-12\n    eucentric_height: 3.91e-3\n    detector_type: ETD\n    detector_mode: SecondaryElectrons\n  # stage\n  stage:\n    rotation_flat_to_electron: 49 # degrees\n    rotation_flat_to_ion: 229 # degrees\n    tilt_flat_to_electron: 35 # degrees (pre-tilt)\n    tilt_flat_to_ion: 52 # degrees\n    pre_tilt: 35\n    needle_stage_height_limit: 3.7e-3\n# user config settings\nuser:\n  imaging_current: 20.e-12\n  milling_current: 2.e-9\n  resolution: \"1536x1024\"\n  hfw: 150.e-6  \n  pixel_size: \n    x: 0.0\n    y: 0.0\n  beam_type: \"Electron\"\n  autocontrast: True\n  dwell_time: 1.e-6\n  save: False\n  gamma: # gamma correction parameters\n    enabled: True\n    min_gamma: 0.15\n    max_gamma: 1.8\n    scale_factor: 0.01\n    threshold: 46 # px\n</code></pre> <p>User parameters can also be preset using the system.yaml file. All numerical values are in SI units:  - Current: Amps (A) - Time: Seconds (s) - Distance: Metres (m)</p>"},{"location":"fibsem/doc_v2/#setting-hardware-parameters","title":"Setting Hardware Parameters","text":"<p>The hardware specifications need to be provided in the model.yaml file, found at:</p> <pre><code>  \u2026/FIBSEM/fibsem/config/model.yaml\n</code></pre> <p><pre><code># this file is used to define the microscope model, and enabled components\nsystem:\n  name: \"FIBSEM\"\n  manufacturer: \"Demo\"\n  description: \"FIBSEM\"\n  version: \"0.1\"\n  id: 00000\n# define the microscope model\nelectron:\n  enabled: True\nion:\n  enabled: True\nstage:\n  enabled: True\n  rotation: True\n  tilt: True\nmanipulator:\n  enabled: True\n  rotation: True\n  tilt: True\ngis:\n  enabled: True\n  multichem: True\n</code></pre> Simply set the parameter to True if the hardware is present in the microscope. </p>"},{"location":"fibsem/doc_v2/#example-code","title":"Example code","text":"<p>An example function for taking images with both beams can be found in the example_OpenFIBSEM file. </p> <pre><code>from fibsem import utils, acquire\nimport matplotlib.pyplot as plt\n\n\ndef main():\n    # connect to microscope\n    microscope, settings = utils.setup_session()\n\n    # take image with both beams\n    eb_image, ib_image = acquire.take_reference_images(microscope, settings.image)\n\n    # show images\n    fig, ax = plt.subplots(1, 2, figsize=(7, 5))\n    ax[0].imshow(eb_image.data, cmap=\"gray\")\n    ax[1].imshow(ib_image.data, cmap=\"gray\")\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p></p>"},{"location":"fibsem/examples/","title":"Examples","text":""},{"location":"fibsem/examples/#connecting-to-the-microscope","title":"Connecting to the Microscope","text":""},{"location":"fibsem/examples/#image-acquisition","title":"Image Acquisition","text":""},{"location":"fibsem/examples/#stage-movement","title":"Stage Movement","text":""},{"location":"fibsem/examples/#beam-milling","title":"Beam Milling","text":""},{"location":"fibsem/examples/#autolamella","title":"AutoLamella","text":""},{"location":"fibsem/examples/#volume-electron-microscopy","title":"Volume Electron Microscopy","text":""},{"location":"fibsem/features/","title":"Features","text":""},{"location":"fibsem/features/#beam-current-alignment","title":"Beam Current Alignment","text":"<p>The beam current alignment feature is a calibration tool to perform beam current alignment. It can be easily accessed and from the tools menu.</p> <p></p> <p>This will open a new window which will allow the user to align the currents to a reference. </p> <p></p> <p>To begin, the user must take images by clicking on the button labelled as \"Take Images\". This takes two images, one for the reference and one for aligning.</p> <p>The images are labelled as reference and aligning which allows the user to visually comparing when aligning the beam. The reference and the aligning currents can be selected using the drop down available on the right.</p> <p>To align the beam, the user must simply click on align beam. When alignment is done, a pop up window will reveal the shift needed to align the images</p> <p></p> <p>Clicking 'OK' will close the window and the user can continue to align the beam with other currents. Below the buttons there will be a list for reference which shows which currents have been aligned.</p> <p>Clicking the \"Overlay Images\" checkbox will overlay the two images for comparison which provides another visual check for alignment.</p> <p></p> <p>Once the user is satisfied with the alignment, they can close the window and return back to the main OpenFIBSEM window. If necessary, this tool can be run again when required.</p>"},{"location":"fibsem/features/#measurement-tools","title":"Measurement Tools","text":"<p>OpenFIBSEM has a napari based built in ruler to measure distances on an image. The ruler can be toggled on and off in the Image tab of the main window.</p> <p></p> <p>The check box enables or disables the ruler. Please note, while the ruler is enabled the user will not be able to interact with the image. To interact with the image, the ruler must be disabled. Standard image features such as panning, zooming, clicking to move and so on are all only available when the ruler is disabled.</p> <p>To measure a distance, the user must drag either the left or the right point. Dragging a point will update the measured distance automatically. The line cannot be moved, only the points.</p> <p>Next to the checkbox, the measured distance is calculated in microns. The dX and dY values are also displayed. The measured values are simply a pixelwise calculation of the distance based on the horizontal field width (HFW).</p> <p>The ruler can be used on either the ION image or ELECTRON image. The point can dragged to either side to calculate distance in an image. If the two images do not share the same HFW, then the HFW of the image on which the left point is on will be used to calculate the distance. Hence ensure that both points are wholly in a single image.</p> <p>There is also a static scale bar and cross hair point that can be enabled or disabled in the Image tab. The scale bar automatically updates if the HFW is changed and a new image is taken.</p> <p></p>"},{"location":"fibsem/ml/","title":"Machine Learning","text":"<p>OpenFIBSEM contains a number of tools designed to support machine learning workflows.</p>"},{"location":"fibsem/ml/#segmentation","title":"Segmentation","text":"<p>The Segmentation Model Training Pipeline is a user-friendly tool for training models for semantic segmentation. This pipeline makes use of off-the-shelf UNet models, which are known for their simplicity and efficacy. However, for those who wish to use their own custom models, the pipeline also allows for such customization.</p> <p>The pipeline is designed to work with TIFF images and corresponding label maps. The user can easily train their own segmentation model on their own data by editing the config.yaml file located in the segmentation directory. This config file allows the user to specify the model architecture, training hyperparameters, and the data to be used for training. With just a few modifications to the config file, the user can start training their segmentation model in no time.</p> <p>The primary files in the model are: - <code>train.py</code>: training pipeline - <code>model.py</code>: segmentation model class - <code>dataset.py</code>: segmentation dataset class</p>"},{"location":"fibsem/ml/#configyaml","title":"config.yaml","text":"<pre><code>train: \n  data_dir: /home/patrick/github/data/train/        # Directory of training data\n  save_dir: /home/patrick/github/fibsem/models/     # Directory to save models\n  checkpoint: null                                  # Checkpoint to start training from\n  encoder: \"resnet34\"                               # Specify model architecture. List of available encoders in readme.\n  epochs: 20                                        # Number of epochs to train for\n  cuda: true                                        # Enable/Disable CUDA training\n  batch_size: 4                                     # Number of samples per batch\n  num_classes: 3                                    # Number of classes in segmentation labels. Includes background as class 0.\n  learning_rate: 0.0001                             # Training Learning Rate\n  wandb: true                                       # Logs information and plots to wandb\n  wandb_project: \"fibsem_pipeline\"                  # [Optional] wandb project\n  wandb_entity: \"demarcolab\"                        # [Optional] wandb entity\n</code></pre>"},{"location":"fibsem/ml/#data-labelling","title":"Data Labelling","text":"<p>The Segmentation Labelling User Interface is a tool that has been developed using the Napari library. The interface has been developed to work seamlessly with OpenFIBSEM images. </p> <p>The Labelling UI has been developed to work natively with the segmentaion model training pipeline. This integration makes it incredibly easy for users to quickly label images and feed the data into the training pipeline. The user interface provides an intuitive and user-friendly interface for annotating images, allowing users to quickly and accurately label images for training their segmentation models. This integration greatly streamlines the process of preparing data for training and speeds up the overall development process.</p> <p></p>"},{"location":"fibsem/ml/#active-learning","title":"Active Learning","text":"<p>The generation of microscopy data is a time-consuming and expensive process. To address this challenge, an active learning pipeline has been integrated into the Fibsem framework. This pipeline allows for more efficient training data collection and model improvement, making the best use of the limited data available.</p> <p>The active learning pipeline is activated when the user uses the \"validate\" flag in the detect_features_v2 function. When this flag is enabled, the user will be prompted to validate the features detected by the model. If the user finds any errors in the detection, they can correct it, and a copy of the image will be saved along with the flags for labelling. These error cases can then be labelled using the labelling tools provided, and the model can be re-trained and deployed, improving its performance over time. This process has been used internally to achieve significant improvements in the performance of the segmentation models for Fibsem workflows.</p> <p></p>"},{"location":"fibsem/ml/#labelling","title":"Labelling","text":"<p>We have developed an integrated labelling tool for segmentation dataset.</p>"},{"location":"fibsem/ml/#labelling-ui","title":"Labelling UI","text":"<p>The Labelling UI allows users to draw the labels (masks) for training a segmentation model. To see more detailed instructions, see the guide on labelling and detection widgets here</p>"},{"location":"fibsem/ml/#model-assisted-labelling","title":"Model Assisted Labelling","text":"<p>The model assisted labelling tool allows you to use a trained model to assist in the labelling of new data. This is useful for labelling large datasets. The model will make a prediction and the user can correct the prediction using the same drawing tools.</p> <p>To use, go to the Model tab and load your model, and then tick 'model assisted' to enable the model assisted labelling.</p>"},{"location":"fibsem/ml/#experimental","title":"Experimental","text":"<p>We have implemented the Segment Anything Model from MetaAI. This model is trained to segment any object. Here we use it as part of the model assisted labelling </p> <p>For more detailed about SAM see: https://github.com/facebookresearch/segment-anything</p> <p>To use SAM:</p> <p>```python pip install git+https://github.com/facebookresearch/segment-anything.git pip install opencv-python pycocotools matplotlib onnxruntime onnx</p> <p>```</p> <p>Download weights: SAM ViT-H</p>"},{"location":"fibsem/ml_details/","title":"Labelling UI Guide","text":""},{"location":"fibsem/ml_details/#labelling-ui-widget","title":"Labelling UI widget","text":"<p>The labelling widget is built into OpenFIBSEM and provides an image processing tool to prepare labels for the purposes of training an segmentation machine learning model such as UNet. The model can run on CPU however a CUDA enabled GPU is recommended for speed and efficiency.</p> <p></p>"},{"location":"fibsem/ml_details/#labelling-ui-workflow","title":"Labelling UI workflow","text":"<p>To begin, launch the UI and load the directories in which the images are that are to be labelled and the directory in which the labels are to be saved. Clicking the button with the three dots will open a file explorer window to select the directory. Once the paths are set, click the \"Load Data\" button to load the images and labels.</p> <p>The number of classes refers to the unique number of objects to be segmented. In our example, we have the needle and lamella which are two classes. The number of classes can be changed at any time and the UI will update accordingly.</p> <p></p> <p>Once the data has been loaded. The first image will be displayed in the main napari window. The image can be manipulated as normal using the napari controls. </p> <p></p> <p>To label the images manually, select the mask layer and apply the brush tool. The brush tool can be selected and manipulated as standard in napari. The standard napari toolbar can be seen on the top left in the figure above.</p> <p>The images in the data set can be cycled through by clicking previous or next. The current image index is displayed above the next/previous buttons. </p>"},{"location":"fibsem/ml_details/#model-assisted-labelling","title":"Model assisted labelling","text":"<p>The model assisted labelling tool assists the process to reduce the effort of manually labelling the data with the brushing tool. The model provides a prediction of the image and the user can then correct the prediction by brushing over the image.</p> <p>A CUDA enabled GPU is not required for training purposes but it is recommended for efficiency. </p> <p>To enable model assisted labelling, first load a model in the model tab. Ensure that the correct checkpoint and encoder is loaded. The model path can be loaded using the 3 dots button to open the file directory. The model can then be loaded by clicking the Load Model button.</p> <p></p> <p>Once the model is loaded, click the Model Assisted checkbox if it is not already done so. The images will now automatically be semi-labelled and can be adjusted as necessary with the paint brush tool. The model assisted labelling can be toggled on and off at any time. The labels are saved automatically and switching between images will automatically update the labels.</p> <p></p>"},{"location":"fibsem/ml_details/#training-a-new-model","title":"Training a new model","text":"<p>A new model can also be trained based on the images and labels created within this UI itself. To train a new model, ensure you have a image set with labels. The models are created and trained using PyTorch. The models are saved as .pt files and can be loaded in to the UI for model assisted labelling or for any other purpose.</p> <p>To setup, begin by going to the Train tab and setting up the paths to the images and labels. The output path is the location where the newly trained model will be saved.</p> <p></p> <p>Ensure that the number of images and the number of labels are the same length</p> <p>In the Model tab, you can set parameters for the model. - Encoder: the encoder used for the segmentation model (e.g. resnet34) - Checkpoint: the name for the checkpoint when training the new model - Number of classes: the number of classes in the data set</p> <p></p> <p>In the Training tab, you can set parameters for the training. - Batch size: the batch size used for training - Number of epochs: the number of epochs to train for - Learning rate: the learning rate used for training</p> <p></p> <p>In the Logging the use of Weights And Biases (WANDB) can be setup if desired. WANDB is a tool for logging and visualising training runs. To use WANDB, you will need to create an account and login. The WANDB API key can be found in your account settings.</p> <p>Click the \"Use Weights And Biases\" checkbox if using WANDB.</p> <p></p> <p>Once everything is set up, press train model and the training will begin. The training progress will be displayed in the terminal. The WANDB dashboard can be used to visualise the training progress. The progress of the model training is visualised in the main window</p> <p></p> <p>Once the training is done, the model can be accessed from the location where it is saved and can be loaded in to use for assisted labelling or any other purpose.</p>"},{"location":"fibsem/ml_feature_detection/","title":"Feature Detection and Correction Widget","text":"<p>The feature detection widget is a supplementary tool used to detect and correct features in the image. The widget is built into OpenFIBSEM and used a napari pop up window to correct or make changes to features that have been detected by the model. The model can run on CPU however a CUDA enabled GPU is recommended for speed and efficiency.</p> <p>One of the current use cases that this widget is used for is to correct the needle and lamella features that have been detected by the model. If the model is inaccurate with the detection, the user can make changes to the feature positions in a simple UI. The positions are then used for needle movement.</p> <p>Ideally, this widget would be used in conjunction with an existing workflow to make changes on the fly if necessary, for example, correcting the location of a feature for milling, correcting the location for needle movement and so on.</p> <p></p> <p>This is an example of the feature detection widget. In this scenario, it is relevant to identify the locations of the needle tip and lamella centre. The features detected by the model and its corresponding locations can be seen. Here the location of the needle tip is accurate, however, the lamella centre seems to be incorrect. Hence the user can make changes to this very easily.</p> <p></p> <p>The user simply can move the point labelled lamella centre towards a more accurate location to properly label the detection. The change can be seen in the right hand side, with information in pixel coordinates. The flag user corrected is raised to true to inform the system that the user has made changes to the feature location. If necessary, clicking \"Run Feature Detection\" will run the model again to detect the features. The user can then make further changes if necessary.</p> <p>Once completed, clicking \"Continue\" will pass on the relevant information to the next step in the workflow. In this case, the needle tip and lamella centre coordinates are passed on to the needle movement widget.</p>"},{"location":"fibsem/motivation/","title":"Motivation","text":"<p>Here we introduce OpenFIBSEM, a universal API for FIBSEM control. The API aims to provide a single cross-platform interface for controlling FIBSEM systems, and a series of reusable modules and components for microscopy workflows. Due to the diversity of FIBSEM systems and applications, the package focuses on improving the programmability of these systems by focusing on composition, and extendibility. The package implements core functionality such as imaging, movement, milling, manipulator control, provides modules for system calibration, alignment, and image analysis, and re-usable user interface components integrated with napari. The package currently supports ThermoFisher and TESCAN hardware, with support for other manufacturers planned in the future. We will also demonstrate the improved automation driving by OpenFIBSEM by discussing several internally developed FIBSEM applications, such as AutoLamella v2 (automated cryo-lamella preparation), AutoLiftout (automated cryo-liftout), and Salami (automated volume microscopy).</p>"},{"location":"fibsem/motivation/#background-motivation","title":"Background Motivation","text":"<p>In order to provide motivation for this project, we draw a comparison between the current state of the electron microscopy field and the field of computing. In the 1960s, computing was largely limited to academic, government, and high-value commercial applications, and was performed in large shared facilities with expensive equipment operated by experts in the field of computer programming and operation. Programming was done for specific hardware and applications, and users scheduled time and shared resources.</p> <p>However, the computing industry underwent a dramatic shift, becoming universally used and ubiquitous due to improvements in hardware and software. The development of microprocessors significantly improved computer performance while reducing costs, while the development of operating systems such as Unix enabled programmers to develop programs that could run across different hardware platforms. The use of higher-level programming languages such as C made it easier for programmers to create new programs and opened up programming to a wider range of users. These developments facilitated the automation of manual tasks and drove the computing industry forward.</p> <p>To make FIBSEM microscopy more accessible and universal, we believe that the field should follow a similar trajectory. Improvements in hardware, including better physics, materials, engineering, and economies of scale, are expected to continue. On the software side, we believe that OpenFIBSEM can provide the foundation for a cross-platform operating system and development ecosystem for FIBSEM systems. Designed with universality, composability, and extendibility in mind, these improvements in programmability of FIBSEM systems will ultimately make it easier to automate existing workflows and develop new applications, thereby driving structural biology research forward.</p>"},{"location":"fibsem/motivation/#design","title":"Design","text":"<p>The OpenFIBSEM API is designed with three main objectives in mind. First, it aims to be universal, ensuring that users can use the same functionality across different hardware, while enabling cross-platform application development by default. Second, it aims to be composable, allowing users to combine different functionalities to suit their specific requirements. Users should be able to use as much or as little of OpenFIBSEM as they choose, and integrate it with other software tools. Lastly, the API aims to be extendible, enabling users to add new functionalities and interfaces while ensuring compatibility with existing tools. By achieving these three objectives, OpenFIBSEM aims to facilitate the development of advanced FIBSEM applications and workflows in structural biology research.</p> <p>We aim to achieve the above goals by implementing the following architecture: </p> <p>The OpenFIBSEM development team has outlined several objectives aimed at improving the API's functionality and accessibility. These objectives include the migration of all existing packages to universal standards, expanding support for a wider range of manufacturers, incorporating additional user modules, and integrating more user interface components. Additionally, the team plans to develop standalone user applications that utilize OpenFIBSEM as their underlying API. These initiatives are expected to improve the overall usability and extendibility of OpenFIBSEM, enabling researchers to develop more advanced FIBSEM applications for structural biology research.</p>"},{"location":"fibsem/motivation/#universal-standards","title":"Universal Standards","text":"<p>The primary interface components are:</p>"},{"location":"fibsem/motivation/#fibsemmicroscope","title":"FibsemMicroscope","text":"<p>The FibsemMicroscope is an example of an Abstract Base Class (ABC) in the context of microscopy. It defines a standardized interface that all types of hardware should conform to in order to interact with the package. This enables higher level modules to interact with the microscope without having to worry about the specific type of hardware being used.</p> <p>In addition, the ABC can add additional functionality to the microscope if available, making it possible to use advanced features of different types of hardware without needing to understand the details of how they work. This implementation provides a powerful abstraction layer that simplifies the process of using microscopy hardware.</p> <p>We recommend defining at least the most minimal configuration:</p> <pre><code>class NewMicroscope(FibsemMicroscope):\n\n    def connect(...)\n        ...\n    def disconnect(...)\n        ...\n    def acquire_image(...)\n        ...\n    def move_stage_absolute(...)\n        ...\n    def move_stage_relative(...)\n        ...\n</code></pre>"},{"location":"fibsem/motivation/#fibsemimage","title":"FibsemImage","text":"<p>The FibsemImage is a common image format that includes metadata specific to Fibsem microscopy. This allows for seamless integration with different types of hardware and ensures that metadata is preserved, and consistent across hardware. The FibsemImage also includes functions that can convert manufacturer-specific formats to the FibsemImage format, which enables users to work with images from different hardware without the need for specialized knowledge.</p> <p>One of the key benefits of the FibsemImage is that it is used as an input argument for OpenFIBSEM modules. The flexible metadata format can also be extended if required, which provides a high degree of customization to meet specific research needs. Additionally, the storage mechanism for FibsemImage files can be changed if required for larger scale images, (such as in https://www.nature.com/articles/s41592-021-01326-w) and tools will be provided to convert to common formats if needed.</p> <pre><code>class FibsemImage:\n    ...\n    def fromNewMicroscope(...) -&gt; FibsemImage:\n        ... \n    def toNewMicroscope(... ) -&gt; NewMicroscopeImage:\n        ...\n</code></pre>"},{"location":"fibsem/motivation/#fibsemcoordinatesystem","title":"FibsemCoordinateSystem","text":"<p>The FibsemCoordinateSystem is a unified coordinate system that is designed to ensure that a position or movement within the system is consistent across different types of hardware. The coordinate system is based on a 0, 0, 0 starting point at the electron pole piece and is always in raw format, meaning it is not dependent on the working distance.</p> <p>Currently, the FibsemCoordinateSystem is not yet enabled as it requires access to a wider range of hardware to test and ensure that it is functioning correctly. However, once it is enabled, it will provide a way to ensure consistency and accuracy when working with Fibsem microscopy data, regardless of the specific type of hardware being used.</p> <p>Just to get it out of the way:</p> <p></p>"},{"location":"fibsem/motivation/#composition","title":"Composition","text":"<p>OpenFIBSEM offers modules that are designed to be flexibly composed together to enable users to implement the tools that suit their particular needs. The user interface (UI) is an essential component of FIBSEM systems and applications, but developers face significant challenges in writing the boilerplate code for UIs. This task is time-consuming and increasingly complex as applications become more intricate. To address this challenge, OpenFIBSEM provides reusable UI components, such as those for imaging, movement, and milling, which can be imported into any application. These widgets are integrated with the napari viewer, making them easy to use. Developers can drop these widgets into their application, and they will communicate with the viewer and the microscope. Other modules can invoke these widgets to perform standard UI operations, such as capturing images and updating the display, or enabling double-clicks to move the stage. Since these widgets are composable, developers can choose to use them all, any, or none in their application, in conjunction with the core package. Example applications utilizing these components include FibsemUI, Salami UI, and Autolamella, among others.</p>"},{"location":"fibsem/motivation/#ui-components","title":"UI Components","text":"Component Description Example Viewer Displays images, patterns and recieves user input Imaging Captures images from the microscope and displays them in the viewer Movement Moves the stage and updates the viewer Milling Draw Patterns and Run Milling <p>Eucentric correction is a critical operation that aligns the ion beam and electron beam so that both beams are coincident. To perform this operation, the stage must be centered on a feature in the electron beam and then moved vertically to align the ion beam with the electron beam. OpenFIBSEM offers a cross-platform movement functionality to center the stage by calling microscope.move_eucentric(settings, dy), which moves the stage purely vertically in the ion image plane. This functionality works on both TESCAN and ThermoFisher instruments. To perform this operation, we need the distance to the feature in the ion image, which can be obtained from different sources such as user interface clicks, alignment from a reference image, or feature detection from a machine learning model. By utilizing these components, we can develop multiple eucentric alignment methods, allowing users to implement or develop the method that suits their application and specific conditions, rather than being constrained to predefined workflows.</p> <p> ML Based Eucentric Correction Workflow</p> <p>OpenFIBSEM's open-source nature facilitates frequent updates to its components, methods, tools, and workflows that other researchers might find useful. Contributions from others are welcome, and users can contribute an example workflow by opening a pull request on Github, which will be added to the examples in the repository. For instance, a user may wish to use a proprietary detector and associated API while still benefiting from the core imaging and stage movement functionality offered by OpenFIBSEM.</p>"},{"location":"fibsem/motivation/#extensibility","title":"Extensibility","text":"<p>OpenFIBSEM is an extensible software package that allows users to implement new functionality and extend the capabilities of FIBSEM systems. Several examples of such extensions are Stable Movement, AutoFocus, AutoGamma, AutoCLAHE, and Charge Neutralisation. Stable Movement corrects for the pre-tilt of the shuttle holder when moving the stage, thus maintaining eucentric position. AutoFocus is a custom routine that can be tuned or extended, while AutoGamma and AutoCLAHE implement multiple image post-processing methods for dealing with excessive charge effects. Charge Neutralisation, on the other hand, develops a procedure for neutralising or building up the charge on a sample.</p> <p></p> <p>OpenFIBSEM supports the interfacing of hardware interactions with a microscope through an implementation of the FibsemMicroscope abstract base class. This class defines the interfaces available for all microscopes to interact with the hardware, and FibsemImage and FibsemCoordinateSystem provide common data structures for user modules to consume and produce. Therefore, extending to a new manufacturer involves implementing each of the base class methods, such as connect, acquire_image, and stage_move_absolute. Although each subclass requires all the base methods to be implemented, in practice, this only means the method needs to be present, not that it does anything. Thus, implementing the core imaging and movement functionality is recommended first, with other methods logging a warning that they are not implemented, or throwing an error until implemented. This approach allows OpenFIBSEM to support a wide range of FIBSEM systems available, each with various subsystems and components.</p> <p>OpenFIBSEM also enables users to extend it to new modalities, as demonstrated by (Piescope)[CITATION], where integrating additional modalities into the same chamber has significant benefits. For instance, adding a BeamType.LIGHT enumeration to represent a fluorescence microscope could be achieved without changing existing functionality or large-scale rewrites.</p> <pre><code>class BeamType(Enum):\n        ELECTRON = 1\n        ION = 2\n        LIGHT = 3\n\nclass FibsemImage(...):\n    \u2026\n    @staticmethod\n    def fromPIEScope(...) -&gt; \u2018FibsemImage\u2019:\n        \u2026\n\ndef acquire_image(microscope, image_settings: ImageSettings) -&gt; FibsemImage:\n    if not isinstance(image_settings.beam_type, BeamType):\n        return None     \n\n    if image_settings.beam_type in [BeamType.ELECTRON, BeamType.ION]:\n        return microscope.acquire_image(image_settings)\n\n    if image_settings.beam_type is BeamType.Light:\n        piescope_image = piescope.acquire_image(image_settings)\n        return FibsemImage.fromPIEScope(piescope_image)\n</code></pre> <p>Similarly, different methodologies such as EDS or additional sensors such as a Chamber CCD could also be supported. Because OpenFIBSEM is designed to be extended, adding new functionality does not require significant changes to existing functionality.</p> <p>## User Applications</p> <p>We have created a range of applications using OpenFIBSEM, which are publicly available on Github. These applications have been intentionally designed to be versatile and adaptable, providing a strong foundation for developing new applications. The applications that we have developed include:</p> <p>FibsemUI: A versatile User Interface that enables users to access imaging, movement, and milling operations in a seamless and customizable manner.</p> <p></p> <p>Salami: An automated approach to Volume Electron Microscopy that is highly efficient and reliable.</p> <p></p> <p>AutoLamella v2: An automated cryo-lamella preparation approach that streamlines the process and ensures high-quality results.</p> <p></p> <p>We aim to continue extending the functionality of OpenFIBSEM by porting existing applications to this backend and developing new applications that can be used as examples for other users.</p>"},{"location":"fibsem/roadmap/","title":"Project Roadmap","text":"<p>The following is a roadmap of the planned OpenFIBSEM development.This roadmap is being developed in the v2 branches. </p> <p></p>"},{"location":"fibsem/roadmap/#milestone-01","title":"Milestone 01","text":"<p>Support for two manufacturer's hardware, and core functionality implemented.</p> <ul> <li>FibsemMicroscope</li> <li>FibsemImage</li> <li>FibsemCoordinateSystem</li> <li>Acquire</li> <li>Movement</li> <li>Milling</li> </ul>"},{"location":"fibsem/roadmap/#demo-01","title":"Demo 01","text":"<p>Present two demo applications using core functionality, and test real uses cases across hardware. </p> <ul> <li>AutoLamella v2: automated cryo-lamella lamella preparation - AutoLamella V2</li> <li>Salami: automated slice and view </li> </ul>"},{"location":"fibsem/roadmap/#milestone-02","title":"Milestone 02","text":"<p>Auxillary systems implemented, detectors, and non-core functionality - Validation - Calibration - Manipulator - GasInjectionSystem - Detector - Imaging - Segmentation</p>"},{"location":"fibsem/roadmap/#demo-02","title":"Demo 02","text":"<ul> <li>AutoLiftout</li> </ul>"},{"location":"fibsem/started/","title":"Getting Started","text":""},{"location":"fibsem/started/#installation","title":"Installation","text":"<p>Please see README.md</p>"},{"location":"fibsem/started/#desktop-shortcut","title":"Desktop Shortcut","text":"<p>To create a desktop shortcut for FibsemUI, simply run the shortcut.py file.</p>"},{"location":"fibsem/started/#system-configuration","title":"System Configuration","text":"<p>The system configuration is defined by a system.yaml file. This defines various system settings, including connection details, beam, imaging, and stage settings. </p> <p>You will need to change the ip_address to connect to your microscope. </p> <p>The default file can be found in fibsem/config/system.yaml. When you call utils.setup_session() with no arguments, the default file is used. You can either edit the default file, or provide the config_path to your own system.yaml file in setup_session.</p> <p>WIP: update for v2</p> <pre><code># system\nsystem:\n  ip_address: 10.0.0.1\n  application_file: autolamella\n  manufacturer: Thermo # Thermo or Tescan\n  # beams\n  ion:\n    voltage: 30000\n    current: 20.e-12\n    plasma_gas: \"Argon\" # proper case, e.g. Argon, Oxygen\n    eucentric_height: 16.5e-3\n    detector_type: ETD\n    detector_mode: SecondaryElectrons\n  electron:\n    voltage: 2000\n    current: 1.0e-12\n    eucentric_height: 4.0e-3\n    detector_type: ETD\n    detector_mode: SecondaryElectrons\n  # stage\n  stage:\n    rotation_flat_to_electron: 50 # degrees\n    rotation_flat_to_ion: 230 # degrees\n    tilt_flat_to_electron: 35 # degrees (pre-tilt)\n    tilt_flat_to_ion: 52 # degrees\n    pre_tilt: 35\n    needle_stage_height_limit: 3.7e-3\n# user config settings\nuser:\n  imaging_current: 20.e-12\n  milling_current: 2.e-9\n  resolution: \"1536x1024\"\n  hfw: 150.e-6  \n  beam_type: \"Electron\"\n  autocontrast: True\n  dwell_time: 1.e-6\n  save: False\n  gamma: # gamma correction parameters\n    enabled: True\n    min_gamma: 0.15\n    max_gamma: 1.8\n    scale_factor: 0.01\n    threshold: 46 # px\n</code></pre> <p>Note: setup_session will not automatically switch to these settings. To do so, you need to call validation.validate_initial_microscope_state.</p>"},{"location":"fibsem/started/#example","title":"Example","text":"<p>Once you have changed your system.yaml file, you should be able to run example/example.py to take images with both beams, and plot.</p> <pre><code>from fibsem import utils, acquire\nimport matplotlib.pyplot as plt\n\n\ndef main():\n\n    # connect to microscope\n    microscope, settings = utils.setup_session()\n\n    # take image with both beams\n    eb_image, ib_image = acquire.take_reference_images(microscope, settings.image)\n\n    # show images\n    fig, ax = plt.subplots(1, 2, figsize=(7, 5))\n    ax[0].imshow(eb_image.data, cmap=\"gray\")\n    ax[1].imshow(ib_image.data, cmap=\"gray\")\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"fibsem/started/#the-basics","title":"The Basics","text":""},{"location":"fibsem/started/#microscope-connection","title":"Microscope Connection","text":"<p>The microscope is a client connection to the Microscope Server. At the moment, only ThermoFisher AutoScript Client is supported. </p>"},{"location":"fibsem/started/#microscopesettings","title":"MicroscopeSettings","text":"<p>MicroscopeSettings is a large structure containing the settings for the different microscope systems.</p> <p>It is populated from your configuration in system.yaml. Most functions take a combination of the microscope client, and settings as arguments. </p>"},{"location":"fibsem/started/#taking-an-image","title":"Taking an Image","text":"<p>The most basic use case for the package is taking an image. Imaging functions are contained in fibsem.acquire, and imaging conditions are controlled by modifying the ImageSettings struct.</p> <p>ImageSettings is part of the MicroscopeSettings, and can be accessed by settings.image. For example, to change the hfw of the image and take an image (snippet):</p> <pre><code># change hfw to 400e-6\nsettings.image.hfw = 400e-6\n\n# take image\nimage = acquire.new_image(microscope, settings.image)\n</code></pre>"},{"location":"fibsem/started/#movement","title":"Movement","text":"<p>...</p>"},{"location":"fibsem/started/#milling","title":"Milling","text":"<p>...</p>"},{"location":"fibsem/user_guide/connection/","title":"Connecting to a Microscope","text":"<p>To begin connecting to a microscope, click on the connect tab. Here, you can connect to a microscope, load a configuration file, save a configuration file, and apply the settings to the microscope.</p> <p>Initially, none of the subsystems are connected and only the configuration tab is available. Please refer to the System Configuration and Setup Guide for more information on the configuration tab. Make any changes there if necessary or continue to simply start with the default configuration.</p> <p>In the connect tab in the I.P. Address section, enter the I.P. address of the microscope, or localhost if the microscope is on the same computer. Then, click on the dropdown for manufacturer and select the manufacturer of the microscope. </p> <p></p> <p>Once done, click connect to microscope. This will connect to the microscope and load the default configuration. If the connection is successful, the button will display 'Microscope Connected' and the button will be highlighted in green. The other subsystem tabs will also become available.</p> <p></p> <p>If connection is unsuccessful, an error will arise. Please refer to the error messages for information on the error and troubleshooting solutions.</p> <p>Once connected to a microscope, other functionality is available. To take an image, click on the Image tab. Ensure the settings are as desired and click 'Acquire Image'. This will take an image and display it in the image viewer. Click 'Acquire All Images' to take both an ion and electron image. Please see the imaging section for more information on the Imaging.</p> <p></p>"},{"location":"fibsem/user_guide/detection/","title":"Feature Detection and Machine Learning Tools","text":"<p>OpenFIBSEM hosts a variety of machine learning tools incorporated into the workflows for lamella preparation. This includes feature detection and classification through image segmentation and detection. </p> <p>Through the use of detection and classification, OpenFIBSEM can be used to automate the process of lamella preparation. This is done by detecting the features of interest and classifying them into the relevant categories. This allows for the process to make decisions on its own regarding movement and milling ultimately reducing the need for human input. </p> <p>OpenFIBSEM provides several baseline models for different methods and samples available on huggingface for this purpose. These models have been finetuned for cryo-lamella preparation on different samples. You can also load from a local checkpoint, by specifying the full path. </p> <p>To constantly improve the model, OpenFIBSEM also allows for user feedback to be incorporated into the model. This is done by allowing the user to verify the detection and classification of the features of interest. This feedback is then used to train the model to improve its accuracy. By default this data is logged to fibsem/log/data/ml. This can be changed in the config file.</p>"},{"location":"fibsem/user_guide/detection/#model-selection","title":"Model selection","text":"<p>To load a baseline from huggingface, specify the checkpoint name, and matching encoder. The encoder to use can be determined by the naming scheme of the checkpont, (e.g. openfibsem-baseline-34.pt -&gt; encoder=\"resnet34\", openfibsem-01-18.pt -&gt; encoder=\"resnet18\")</p> <p>A model can be loaded like so by using the load_model function found in fibsem/segmentation/model.py</p> <pre><code>from fibsem.segmentation.model import load_model\n\n# load model checkpoint from huggingface (openfibsem-baseline-34.pt)\nmodel = load_model(checkpoint=\"openfibsem-baseline-34.pt\", encoder=\"resnet34\")\n\n# load base model (imagenet checkpoint)\nmodel = load_model(checkpoint=None, encoder=\"resnet34\")\n\n# load a local checkpoint\ncheckpoint_path = \"path/to/model/checkpoint.pt\" # Using model saved on disk\nmodel = load_model(checkpoint = checkpoint_path, encoder = \"resnet18\")\n</code></pre>"},{"location":"fibsem/user_guide/detection/#feature-detection-in-automated-lamella-preparation","title":"Feature Detection in Automated Lamella Preparation","text":"<p>Segmentation and feature detection is used in the automated lamellae preparation process to guide movement and milling. The regions of interest are segmented and detected, which are then used to control or make changes to position and milling parameters.</p> <p></p> <p>In the example shown above, the user is at the stage to mill the undercut for a lamella. The user is also supervising the workflow which ensures that the user has the final decision on the detection and feature position. </p> <p>When repositioning to mill the undercut, the system runs feature detection to identify the position of the lamella centre to ensure accurate movement of the stage. In the image, the segmentation and detection of the lamella is shown. The feature of interest being the lamella centre is set as a point in the napari viewer.</p> <p>The user is then prompted to verify the detection and position of the feature. Here, if the position is invalid or incorrect, the user can simply drag the point to the correct location and press continue to proceed.</p> <p>This process of user verification is enabled when the workflow is run in supervised mode on the selected stages. When the workflow is run in unsupervised mode, the model is used to control the workflow without verification from the user. This is the ideal case when the model has been trained to a point user verification is not required, further reducing human involvement in the process.</p>"},{"location":"fibsem/user_guide/detection/#feedback-and-model-training","title":"Feedback and Model Training","text":"<p>When in supervised mode, the user is prompted to verify the detection and position of the feature. When the user makes changes to the detection, metrics such as the new correct position, and how far the detection was from the user corrected position is used to analyse the performance and retrain the model if and when necessary.</p> <p>Based on whether the detection was correct or not, the images can be split into a training and validation dataset. The training dataset is used to train the model and the validation dataset is used to evaluate the model.</p> <p>OpenFIBSEM programs are constantly collecting this training and validation data enabling the model to be trained and improved over time. This allows for the model to be constantly improved and updated to the latest data.</p>"},{"location":"fibsem/user_guide/guide/","title":"User Guide","text":"<p>For more information on the subsystems, please refer to the respective sections in the user guide.</p> <ul> <li>Connection</li> <li>System Setup</li> <li>Imaging</li> <li>Movement</li> <li>Milling</li> <li>Manipulator</li> <li>Feature Detection</li> </ul>"},{"location":"fibsem/user_guide/imaging/","title":"Imaging","text":"<p>The imaging tab provides a suite of functionality to control the imaging process on both the electron and ion beam. This includes controlling image settings such as resolution and dwell time and processing methods such as auto contrast and autogamma.</p> <p>The settings for the detectors and the beam can also be altered here. There are also additional tools such as a scale bar and a ruler to take measurements. Details on these tools can be found here</p> <p>The crosshair can be enabled or disabled in this tab as well. </p> <p></p> <p>When making changes to these settings, the settings will take effect when clicking 'Acquire Image'. The settings can be individually applied to the electron or ion beam or both simultaneously. The beam dropdown allows the user to select which beam to make changes for.  </p>"},{"location":"fibsem/user_guide/imaging/#image-settings","title":"Image Settings","text":"<p>These settings are responsible for basic image parameters such as resolution, dwell time and horizontal field width. The resolution is specified in pixels, dwell time in micro-seconds and horizontal field width in microns. </p> <p>There are also additional processing methods available, the AutoContrast and AutoGamma functions can be enabled or disabled as necessary. Enabling them activates the function for every image taken.</p> <p>Images can also be saved when required. Click the save image checkbox to enable image saving everytime a new image is taken. When enabled, additional fields will appear to allow the user to choose the save location and the file name.</p> <p></p>"},{"location":"fibsem/user_guide/imaging/#detector-settings","title":"Detector Settings","text":"<p>This section allows the user to alter and specify the detector settings available on the microscope. This includes the type and mode if available. The brightness and contrast can also be adjusted. To apply the changes, click 'Set Detector Settings' and then click Acquire Image(s) to take the image.</p>"},{"location":"fibsem/user_guide/imaging/#beam-settings","title":"Beam Settings","text":"<p>This section allows the user to modify the beam settings available on the microscope. This includes the  working distance (specified in mm), beam current (specified in picoAmps), voltage (kV) and beam shift in x and y (specified in microns). To apply the changes, click 'Set Beam Settings' and then click Acquire Image(s) to take the image.</p>"},{"location":"fibsem/user_guide/manipulator/","title":"Manipulator","text":"<p>The nanomanipulator or needle is a subsystem in some FIBSEM systems to allow for manipulation of the sample. This is typically used for lift-out and sample preparation. OpenFIBSEM allows for control of the manipulator through movement and saved positions. The manipulator section allows control for insertion and retraction along with movement in the x,y and z axis and rotation if supported.</p>"},{"location":"fibsem/user_guide/manipulator/#manipulator-calibration-tescan","title":"Manipulator Calibration (TESCAN)","text":"<p>For TESCAN systems, the manipulator needs to run a calibration setup upon first time usage on a microscope. This is done to correlate the named positions setup by TESCAN to the actual microscope coordinates, which allows reading the current position of the manipulator in terms of its name.</p> <p>If the manipulator is not calibrated, the subsystem will be disabled with the message indicating that the manipulator needs calibration. This is a one time operation but can be redone if necessary.</p> <p></p> <p>To calibrate the manipulator, click on the tools menu and select \"Manipulator Calibration\". This will begin the process of calibration, during which, the manipulator moves rapidly between the \"Parking\", \"Standby\" and \"Working\" positions. Before calibrating it is recommend to move the stage down to ensure that the manipulator is free of obstructions so that no damage is done to the system. Follow the prompts on the screen to complete the calibration. It is completely automatic and requires no other user input. Once completed, it will be ready to use.</p>"},{"location":"fibsem/user_guide/manipulator/#manipulator-control","title":"Manipulator Control","text":"<p>The manipulator can be inserted and retracted as necessary. Inserting the manipulator brings it to the working area and retracting it brings it back to the standby position. </p> <p>The manipulator can be controlled in the available axes, namely the x,y,z and rotation. The manipulator can be moved in the x,y,z axes by entering a value in the respective field and clicking the \"Move\" button. The movements made are relative moves. However, positions can be saved as named positions and moved to directly. </p> <p>To save the current position as a named position, enter a name into the save position field and click \"Save Position\". To move to an available saved position, choose from the drop down menu and click \"Go to Position\" to go to the position.</p> <p></p>"},{"location":"fibsem/user_guide/milling/","title":"Milling","text":"<p>The milling section allows the user to setup and control the milling process using the FIB. This includes setting up the milling patterns and specific milling settings.</p> <p></p> <p>The milling process is done in milling stages. Each milling stage comprises of a pattern and the milling settings required for this pattern. The milling stages are then executed in the order of creation. A milling stage can be added by clicking the 'Add' button. An ion beam image must be taken first before a milling stage can be added. The stages are named in order of creation. A stage can be removed by pressing the remove button. A specific milling stage can be selected by choosing it from the milling stage drop down.</p>"},{"location":"fibsem/user_guide/milling/#milling-settings","title":"Milling Settings","text":"<p>For each milling stage, there are milling settings associated with it, along with the pattern to be milled. The milling settings are specific to each manufacturer:</p> <p>TESCAN:</p> <ul> <li>Milling rate (specified in mm<sup>3</sup> / A / s)</li> <li>Dwell time (microseconds)</li> <li>Spot size (microns)</li> <li>Spacing (spot spacing)  </li> <li>Preset  </li> </ul> <p>ThermoFisher:</p> <ul> <li>Current (A)</li> <li>Application File</li> </ul>"},{"location":"fibsem/user_guide/milling/#milling-patterns","title":"Milling Patterns","text":"<p>The pattern specifies the kind of pattern to be milled. These include simple shapes such as rectangles, circles and lines. However, OpenFIBSEM also includes a host of complex shapes ideal for lamella preparation. Each pattern has its own unqiue set of parameters that can be set. The full list of patterns is includes:</p> <ul> <li>Rectangle</li> <li>Line</li> <li>Circle</li> <li>Trench</li> <li>Horseshoe</li> <li>Undercut</li> <li>Fiducial</li> <li>Spot Weld</li> <li>Micro Expansion</li> <li>Waffle Notch</li> <li>Clover</li> <li>Triforce</li> <li>Annulus</li> <li>Bitmap (ThermoFisher Only)</li> </ul> <p>By default, when changes are made to the pattern settings in the UI, the pattern displayed in the viewer is updated live. However, this can be disabled if necessary by unchecking the 'Live Update' checkbox.</p> <p>A pattern's position can be chosen relative to it's location on the ion image. This can be manually moved by entering coordinates in the centre x and centre y field. The coordinates of (0,0) is the centre of the image.</p> <p>Alternatively, the pattern can be moved anywhere within the image by pressing the Shift key and left-clicking on the image. If the pattern is out of bounds, it will return an out-of-bounds error and the pattern will remain where it was.</p>"},{"location":"fibsem/user_guide/milling/#multiple-stages","title":"Multiple Stages","text":"<p>Multiple stages can be setup at once. In this manner, once multiple stages are ready, clicking \"Run Milling\" will run all the stages sequentially without any more manual input. This avoids the repetitive nature of setting up and running stages individually.</p> <p>When there are multiple stages active, each seperate stage is coloured differently for identification. Changes can only be made to one stage at a time. To make changes to the stage, select the stage from the drop down menu and then make the relevant changes to the pattern or milling settings.</p> <p></p>"},{"location":"fibsem/user_guide/milling/#moving-multiple-patterns","title":"Moving Multiple Patterns","text":"<p>Shift + Ctrl + Left-Click</p> <p>Moving multiple patterns simultaneously is also possible. To do this, press the Shift + Ctrl + Left-Click on a position in the ion image. By default, the checkbox \"Keep Relative Orientation\" is selected. This means when moving all the patterns, the relative orientation of the patterns to each other is kept the same. If this is not selected, all the patterns will be centred on the same new point.</p> <p>Moving multiple patterns uses the current selected pattern as the reference to move. I.e. the currently selected stage will move to the point chosen, while the other stages will move relative to this stage, retaining their relative position.</p> <p></p> <p>To move all the patterns to a single location regardless of relative orientation, uncheck the \"Keep Relative Orientation\" checkbox. This will move all the patterns to the same location.</p> <p></p>"},{"location":"fibsem/user_guide/milling/#run-milling","title":"Run Milling","text":"<p>Once satisfied with the milling and pattern settings and the stages are set as desired. Click \"Run Milling\" to perform milling. The milling stages will be performed in their numerical sequence order. When milling is running, the button will be highlighted orange</p> <p></p> <p>DURING MILLING, MOST OTHER FUNCTIONALITY IS DISABLED INCLUDING IMAGE ACQUISITION AND STAGE MOVEMENT</p> <p>Once milling is complete, the button will return to its original colour and other functionality will be restored. The milling stages can be repeated or new ones can be added. The system will also automatically restore back to the original imaging current, and re-image the sample.</p>"},{"location":"fibsem/user_guide/movement/","title":"Movement","text":"<p>The movement tab provides functionality and control of the stage movement in the microscope system. This includes the ability to move the stage in the x, y and z directions as well as tilt and rotation if these are available in the microscope. </p> <p>Additionally, the movement of the stage can be done by double clicking on a point in the image itself either in the electron or ion image (An image must be taken first). This will move the stage to the point clicked on and the point will now be centred in the view.</p> <p></p>"},{"location":"fibsem/user_guide/movement/#stage-movement","title":"Stage Movement","text":"<p>In the movement tab, the current coordinates are displayed. The coordinates are displayed in mm and angles in degrees where applicable. To move to a specific coordinate, enter the coordinates in the respective fileds and click 'Move to Position'. This will move the stage to the specified position. </p> <p>The stage can also be tilted directly to be flat to each respective beam if necessary. To do this, click on either 'Move Flat to ELECTRON Beam' or 'Move Flat to ION Beam'. This will move the stage to be flat to the respective beam.</p> <p>By default, after every movement, an image is taken at the new position and the viewer is updated. However, this behaviour can be disabled if necessary. To disable this for the electron beam or ion beam or both, select the respective checkbox under 'Acquire images after moving'. The images will be taken with settings as specified in the image tab. For example, if autocontrast is enabled, the image will be autocontrasted every time a movement is made. This may be unnecessary and can be disabled if desired in the imaging tab.</p>"},{"location":"fibsem/user_guide/movement/#positions","title":"Positions","text":"<p>Specific positions can also be saved to be accessed or modified later. The positions tab allows control over this functionality</p> <p></p> <p>To save a named position, simply enter a name for the position in the save position field and click 'Save position'. This will save the position and add it to the list of saved positions in the drop down. It's coordinates are displayed as well. To switch between saved positions, open the drop down and click on the saved position to go to and click 'Go To'. </p> <p>A saved positions location can be updated if necessary. At the desired location, select the saved position from the drop down and click 'Update position'. This will update the position to the current location.</p> <p>A saved position can be removed if necessary by clicking 'Remove position'. This will remove the position from the list of saved positions.</p> <p>Saved positions can also be exported and imported if necessary. To export, click 'Export positions' and select a location to save the positions to. This will save the positions to a .yaml file. To import, click 'Import positions' and select the .yaml file to import. This will import the positions from the file and add them to the list of saved positions.</p>"},{"location":"fibsem/user_guide/system_setup/","title":"System Configuration and Setup Guide","text":"<p>This guide outlines the steps to configure and setup the system parameters. Each subsystem will be explained. This process does not need to be done everytime the system is started. A default is provided. If changes are made, this can be saved to a file and loaded on startup.</p> <p>On start up of the application the configuration tab will be loaded. Here you can make changes as necessary. </p> <p></p> <p>To load the default configuration and connect to the microscope, simply click the \"Connect to Microscope\" button in the connect tab. This will load the default configuration and connect to the microscope.</p> <p>The configuration can be saved and loaded from a file. This allows for the user to save a configuration and load it on start up. To save, click \"Save configuration to file\" and select a location to save the file. To load, click \"Import Configuration\" and select the file to load. The file to load must be a configuration type yaml file that has been previously saved.</p> <p>The configuration parameters can be altered before connection to the microscope. To make changes to the microscope configuration while it is connected, click \"Apply All Settings\" to apply the changes. This will update the parameters in the program.</p>"},{"location":"fibsem/user_guide/system_setup/#parameters","title":"Parameters","text":""},{"location":"fibsem/user_guide/system_setup/#stage-settings","title":"Stage Settings","text":"<p>The stage parameters can be defined in this section. This section outlines the basic stage and beam column angles which allows for correct calculations of the stage position and subsequently, the movement of the stage.</p> <p></p> <p></p> <p>Referring to the diagram above, the stage parameters are defined as follows:</p> <ul> <li>Rotation flat to electron/ion beam</li> </ul> <p>This is the rotation of the stage in degrees in which the sample will be flat to the respective beam when using a pre-tilted shuttle.</p> <ul> <li>Tilt flat to electron/ion beam</li> </ul> <p>This is the core tilt of the stage in degrees in which the sample will be flat to the respective beam (for a shuttle with NO pre-tilt). On the diagram, the angle labelled alpha is the tilt flat to the ion beam. Typically a system will be perpendicular to the electron beam, so the tilt flat to the electron beam will be 0.</p> <p>On ThermoFisher systems this is usually 52 degrees, and on TESCAN systems this is usually 55 degrees.</p> <ul> <li>Shuttle Pre-Tilt</li> </ul> <p>This is the pre tilted angle of the shuttle if a pre tilted shuttle is used.</p> <ul> <li>Needle Stage Height Limit</li> </ul> <p>This is the limit of the needle stage height in mm. This is used to prevent the needle stage from crashing into the sample or stage (ThermoFisher systems only).</p>"},{"location":"fibsem/user_guide/system_setup/#microscope-model-settings","title":"Microscope Model Settings","text":"<p>The microscope parameters can be defined in this section. This section specifies the main hardware inclusions available on the microscope. This lets the user enable or disable functionality depending on availablity. For example, if a system does not have a manipulator, this can be disabled here and other functionality can be used without errors</p> <p></p>"},{"location":"fibsem/user_guide/system_setup/#system-settings","title":"System Settings","text":"<p>The system parameters related to the ion and electron beams can be defined and set up in this section. In this section, you can also specify if the system is to be connected directly on start up or manually connect to the microscope each time.</p> <p></p>"},{"location":"fibsem/user_guide/system_setup/#user-settings","title":"User Settings","text":"<p>The default imaging and milling parameters are be specified in this section.  </p> <p></p>"},{"location":"openfibsem/","title":"OpenFIBSEM","text":"<p>A universal API for FIBSEM Control, Development and Automation</p>"},{"location":"openfibsem/#overview","title":"Overview","text":"<p>OpenFIBSEM is a Python package for controlling and automating FIB/SEM microscopes. It is designed to be a universal API for FIBSEM control, development and automation. OpenFIBSEM is designed to abstract away the details of the microscope and provide a simple, intuitive interface for controlling the microscope, as well as reuseable modules for common workflows and operations. OpenFIBSEM is designed to be extensible and can be easily adapted to support new microscopes.</p> <p>We currently support the TESCAN Automation SDK and ThermoFisher AutoScript. Support for other FIBSEM systems is planned.</p>"},{"location":"openfibsem/#install","title":"Install","text":""},{"location":"openfibsem/#install-openfibsem","title":"Install OpenFIBSEM","text":"<p>There are several ways to install OpenFIBSEM depending on your application and needs.</p>"},{"location":"openfibsem/#pypi-for-users","title":"PyPI (For Users)","text":"<pre><code>pip install fibsem \n</code></pre>"},{"location":"openfibsem/#github-for-development","title":"Github (For Development)","text":"<p>Clone this repository, and checkout main:</p> <pre><code>git clone https://github.com/DeMarcoLab/fibsem.git\n</code></pre> <p>Install dependencies and package</p> <pre><code>cd fibsem\nconda create -n fibsem python=3.9 pip\nconda activate fibsem\npip install -e .\n</code></pre>"},{"location":"openfibsem/#napari-plugin","title":"Napari Plugin","text":"<p>The OpenFIBSEM tools and user interface are also available as a napari plugin:</p> <pre><code>pip install napari-openfibsem\n</code></pre> <p>Or use napari plugin manager</p>"},{"location":"openfibsem/#additional-installation-information","title":"Additional Installation Information","text":"<p>For detailed instructions on installation, and installing the commercial microscope APIs, see Installation Guide.</p>"},{"location":"openfibsem/#getting-started","title":"Getting Started","text":"<p>To get started, see the example/example.py:</p> <p>Recommended: You can start an offline demo microscope by speciying manufacturer: \"Demo\" in the system.yaml file (fibsem/config/system.yaml). This will start a demo microscope that you can use to test the API without connecting to a real microscope. To connect to a real microscope, set the ip_address and manufacturer of your microscope in the system.yaml or alternatively, you can pass these arguments to utils.setup_session() directly.</p> <p>This example shows you how to connect to the microscope, take an image with both beams, and then plot.</p> example/example.py<pre><code>from fibsem import utils, acquire\nimport matplotlib.pyplot as plt\n\ndef main():\n\n    # connect to microscope\n    microscope, settings = utils.setup_session(ip_address=\"localhost\", manufacturer=\"Demo\")\n\n    # take image with both beams\n    eb_image, ib_image = acquire.take_reference_images(microscope, settings.image)\n\n    # show images\n    fig, ax = plt.subplots(1, 2, figsize=(7, 5))\n    ax[0].imshow(eb_image.data, cmap=\"gray\")\n    ax[1].imshow(ib_image.data, cmap=\"gray\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>This example is available as a script in example/example.py. For more detailed examples, see the Examples sections below.</p>"},{"location":"openfibsem/#examples","title":"Examples","text":""},{"location":"openfibsem/#core-functionality","title":"Core Functionality","text":"<p>For examples of core functionality please see:</p> <ul> <li>example/example_imaging.py: image acqusition</li> <li>example/example_movement.py: stage movement</li> <li>example/example_milling.py: drawing patterns and beam milling</li> <li>example/autolamella.py: recreation of AutoLamella V1 (automated cryo-lamella preparation) in ~150 lines of code</li> </ul> <p>Additional example scripts and notebooks are available.</p>"},{"location":"openfibsem/#projects-using-openfibsem","title":"Projects using OpenFIBSEM","text":"<p>We are currently working on a number of projects using OpenFIBSEM. If you are using OpenFIBSEM in your research, please let us know!</p> <ul> <li>AutoLamella v2: Automated cryo-lamella preparation</li> <li>Salami: Volume Electron Microscopy</li> </ul>"},{"location":"openfibsem/#contributing","title":"Contributing","text":"<p>Contributions are welcome! Please open a pull request or issue.</p>"},{"location":"openfibsem/#docs","title":"Docs","text":"<p>OpenFIBSEM is a large package with many features. For more detailed documentation, please see the Documentation Website.</p>"},{"location":"openfibsem/#citation","title":"Citation","text":"<p>If you find this work useful, please cite:</p> <pre><code>@article{CLEEVE2023107967,\ntitle = {OpenFIBSEM: A universal API for FIBSEM control},\njournal = {Journal of Structural Biology},\nvolume = {215},\nnumber = {3},\npages = {107967},\nyear = {2023},\nissn = {1047-8477},\ndoi = {https://doi.org/10.1016/j.jsb.2023.107967},\nurl = {https://www.sciencedirect.com/science/article/pii/S1047847723000308},\nauthor = {Patrick Cleeve and David Dierickx and Lucile Naegele and Rohit Kannachel and Lachlan Burne and Genevieve Buckley and Sergey Gorelick and James C. Whisstock and Alex {de Marco}},\nkeywords = {Focused Ion Beam microscopy, Automation, Python, API, Microscopy, Controller},\nabstract = {This paper introduces OpenFIBSEM, a universal API to control Focused Ion Beam Scanning Electron Microscopes (FIBSEM). OpenFIBSEM aims to improve the programmability and automation of electron microscopy workflows in structural biology research. The API is designed to be cross-platform, composable, and extendable: allowing users to use any portion of OpenFIBSEM to develop or integrate with other software tools. The package provides core functionality such as imaging, movement, milling, and manipulator control, as well as system calibration, alignment, and image analysis modules. Further, a library of reusable user interface components integrated with napari is provided, ensuring easy and efficient application development. OpenFIBSEM currently supports ThermoFisher and TESCAN hardware, with support for other manufacturers planned. To demonstrate the improved automation capabilities enabled by OpenFIBSEM, several example applications that are compatible with multiple hardware manufacturers are discussed. We argue that OpenFIBSEM provides the foundation for a cross-platform operating system and development ecosystem for FIBSEM systems. The API and applications are open-source and available on GitHub (https://github.com/DeMarcoLab/fibsem).}\n}\n</code></pre> <p>enjoy :)</p>"},{"location":"openfibsem/concepts/","title":"Concepts","text":"<p>This page provides an overview of the OpenFIBSEM API and describes concepts and terminology used. </p> <p>The code examples on this page are provided in a notebook: Github Repo</p>"},{"location":"openfibsem/concepts/#microscope-connection","title":"Microscope Connection","text":"<p>OpenFIBSEM uses a client-server model for connecting to the microscope. The best way to connect to the microscope it to use the setup_session utility. This will handle reading the configuration file, setting up logging and connecting to the microscope. </p> <p>It returns two items:</p> <ul> <li>microscope: the microscope connection  </li> <li>settings:   the microscope settings</li> </ul> <p>The microscope connection is how we will communicate with the microscope, and will be passed to most funcitons. The microscope settings are a copy of the configuration settings, and contain the default imaging settings we will use in settings.image. </p> <pre><code># connecting to the microscope\nfrom fibsem import utils\n\n# connect, setup session use default configuration\nmicroscope, settings = utils.setup_session()\n\n# specify a configuration path\nmicroscope, settings = utils.setup_session(config_path=\"path/to/configuration.yaml\")\n</code></pre>"},{"location":"openfibsem/concepts/#microscope-configuration","title":"Microscope Configuration","text":"<p>Before we can connect to the microscope, there are a few values we need to configure the microscope, and connection.  For details about configuring your microscope, please see the Getting Started Page.</p> <p>If you used setup_session, your configuration is stored in the microscope connection as:</p> <pre><code># microscope configuration\nmicroscope.system\n</code></pre> <p>By default, the configuration is not automatically applied to the microscope to prevent accidently changing settings when connecting. To apply the specified configuration, use the following command.</p> <p>Please not that this might take some time, for example if you have specified a plasma gas this can take 10 minutes to change to a different gas. </p> <pre><code># apply current configuration\nmicroscope.apply_configuration()\n\n# or specify a new configuration\nmicroscope.apply_configuration(settings.system)\n</code></pre>"},{"location":"openfibsem/concepts/#turning-on-the-system","title":"Turning on the System","text":"<p>It is recommended to setup the system manually (e.g. pump the system, turn on the beams, focus and link the stage), but we also provide an api to do this. You will need to turn on the beams, and pump before you can apply the configuration. </p> <pre><code>from fibsem.structures import BeamType\n\n# pump the system\nmicroscope.pump()\n\n# turn on electron beam\nmicroscope.turn_on(BeamType.ELECTRON)\n\n# turn on ion beam \nmicroscope.turn_on(BeamType.ION)\n\n# home the stage\nmicroscope.home()\n</code></pre> <p>You change get / set these properties and more through the get / set api:</p> <pre><code># check if electron beam is on\nelectron_on = microscope.get(\"on\", BeamType.ELECTRON)\nprint(f\"Electron Beam: {electron_on}\")\n\n\n# check chamber state\nchamber_state = microscope.get(\"chamber_state\")\nprint(f\"Chamber State: {chamber_state}\")\n\n# get column tilt of ion\nion_column_tilt = microscope.get(\"column_tilt\", BeamType.ION)\nprint(f\"Ion Column Tilt: {ion_column_tilt}\")\n</code></pre> <pre><code>Electron Beam: True\nChamber State: Pumped\nIon Column Tilt: 52\n</code></pre>"},{"location":"openfibsem/concepts/#imaging","title":"Imaging","text":"<p>The imaging api is the core of the openfibsem api. It provides access to image acquistion, imaging parameters and tools. We currently support Electron and Ion Beam imaging.</p>"},{"location":"openfibsem/concepts/#imaging-parameters","title":"Imaging Parameters","text":"<p>To control the imaging acquistion, we use the ImageSettings. The image settings you defined in configuration are attached to the microscope settings, for use and editing.</p> <pre><code># print the image settings\nprint(settings.image)\n\n\n# change image settings\nsettings.image.dwell_time = 2e-6  # set the dwell time to 2us\nsettings.image.save = True        # automatically save the image (note: this overwrite existing data, check the filename!!)\n</code></pre> <pre><code>@dataclass\nclass ImageSettings:\n    \"\"\"A data class representing the settings for an image acquisition.\"\"\"\n\n\n    beam_type: BeamType = None\n    resolution: list = None               # imaging resolution      (pixels)\n    dwell_time: float = None              # imaging dwell time      (seconds)\n    hfw: float = None                     # imaging field of view   (metres )\n    autocontrast: bool = None             # use autocontrast method \n    autogamma: bool = None                # use autogamma method\n    save: bool = None                     # save the image\n    path: Path = None                     # the save path           (directory)\n    filename: str = None                  # the save filename       (str)\n    reduced_area: FibsemRectangle = None  # sub frame imaging coords       \n    line_integration: int = None          # integrate scan line     [TFS Only]\n    scan_interlacing: int = None          # scan interlacing        [TFS Only]\n    frame_integration: int = None         # integrate frames        [TFS Only]\n    drift_correction: bool = False        # req frame int           [TFS Only]\n</code></pre>"},{"location":"openfibsem/concepts/#acquiring-images","title":"Acquiring Images","text":"<p>To acquire images, we use the acquire module:</p> <pre><code>from fibsem import acquire\nfrom matplotlib.pyplot import plt\n\n# acquire image\neb_image = acquire.acquire_image(microscope, settings.image)\n\n# change settings, reacquire\nsettings.image.hfw = 400e-6             # set the hfov to 400um\nsettings.image.beam_type = BeamType.ION # set the imaging to ion beam\nib_image = acquire.acquire_image(microscope, settings.image)\n\n# plot\nfig, ax = plt.subplots(1, 2, figsize=(15, 7))\nax[0].imshow(eb_image.data, cmap=\"gray\")\nax[0].set_title(\"Electron Beam\")\nax[1].imshow(ib_image.data, cmap=\"gray\")\nax[1].set_title(\"Ion Beam\")\nplt.show()\n</code></pre>"},{"location":"openfibsem/concepts/#image-metadata-fibsemimage","title":"Image Metadata (FibsemImage)","text":"<p>When acquiring images, we also snapshot the state of the microscope. The state is stored in the metadata and can be accessed:</p> <pre><code>## Image Metadata\nfrom pprint import pprint\n\n# get the image settings used\nimage_settings = eb_image.metadata.image_settings\nprint(f\"Image Settings: {image_settings}\")\n\n# access the stage position\nstage_position = eb_image.metadata.microscope_state.stage_position\nprint(f\"Stage Position: {stage_position}\")\n\n# get the electron detector used for imaging\ndetector = eb_image.metadata.microscope_state.electron_detector\nprint(f\"Electron Detector: {detector}\")\n\n# pretty print the metadata (note: this is a lot of data)\npprint(eb_image.metadata.to_dict())\n</code></pre>"},{"location":"openfibsem/concepts/#save-load-fibsemimage","title":"Save / Load FibsemImage","text":"<p>You can save and load the images and metadata is retained. If you specify save=True in the imaging settings images will be automatically saved using the specified path and filename. Note: this save will automatically overwrite any existing image at that path/filename. Make sure you change this if you want to retain your data. </p> <pre><code>from fibsem.structures import FibsemImage\n\n# save the image\npath = \"data/test_electron_image.tif\"\neb_image.save(path)\n\n# load the image\nloaded_image = FibsemImage.load(path)\nprint(f\"metadata: {loaded_image.metadata}\")\n\n# plot both\nfig, ax = plt.subplots(1, 2, figsize=(15, 7))\nax[0].imshow(eb_image.data, cmap=\"gray\")\nax[0].set_title(\"Original Image\")\nax[1].imshow(loaded_image.data, cmap=\"gray\")\nax[1].set_title(\"Loaded Image\")\nplt.show()\n</code></pre>"},{"location":"openfibsem/concepts/#chamber-camera","title":"Chamber Camera","text":"<p>You can acquire an image from the chamber camera:</p> <pre><code># acquire chamber image\nimage = microscope.acquire_chamber_image()\n\nplt.imshow(image.data, cmap=\"gray\")\nplt.show()\n</code></pre>"},{"location":"openfibsem/concepts/#stage-movement","title":"Stage Movement","text":"<p>The stage is the central movable system for the microscope, on which the sample is mounted. Most systems have 5 degrees of freedom (DoF); x, y, z, rotation, tilt. Some systems also have an additional tilt axis (roll axis, or tilt_beta).  </p> <p>The sample is rigidly mounted onto the stage through the use of a sample holder (also called the shuttle), and the two move together. As far as I am aware, it is not possible to move the holder independently from the stage.</p> <p> Stage Definitions</p> <p>For cryo lamella preparation, the shuttle has a pre tilted face. This pre tilt is used to provide additional tilt than can be achieved by the stage alone. We will discuss the use of pre-tilted shuttles later. </p> <p> Pre-Tilted Shuttle</p> <p>In general, we want to move along the sample plane (along the sample grid) while maintain coincidence between the beams. We also need to provide a method for correcting the coincidence, as it often drifts after large rotations etc. </p>"},{"location":"openfibsem/concepts/#movement-concepts","title":"Movement Concepts","text":"<p>The following sections describe some core concepts, and terminology we use for the movement api. It is important to understand these terms for the next section.</p>"},{"location":"openfibsem/concepts/#axes-and-coordinate-systems","title":"Axes and Coordinate Systems","text":"<p>When describing the stage axes and positions, we always use a raw coordinate system. This is the raw position of the stage defined from a static reference position (by the manufacturer). We do not use the linked (specimen) coordinate on Thermo Fisher system, but in order to access some functionality the system needs to be linked. You do not need to unlink the system to access the raw coordinates, it can remain linked and the api specifies the coordinates are to be raw. </p> <p>Axes:</p> <p>X+: Towards Door</p> <p>Y+: Towards Load Position</p> <p>Z+: UP</p> <p> Stage Movement Axes - Thermo Fisher</p> <p>Depending on the manufacturer, the default stage axes may  be attached to the stage, or fixed in the chamber. For Thermo Fisher systems, the stage axes are attached to the stage, i.e. y-axis and z-axis tilts with stage tilt, while for Tescan it is not. Therefore, to provide consistent movement between systems we provide our own movement functions. </p>"},{"location":"openfibsem/concepts/#shuttle-pre-tilt","title":"Shuttle Pre-Tilt","text":"<p>The shuttle pre-tilt adds additional complexity to stage movement, as the sample plane is now tilted relative to the stage axes. The following diagram shows how shuttle pre-tilt changes the sample plane. </p> <p> Stage Flat with Pre-Tiled Shuttle</p> <p>We provide compensation for moving along the sample plane, and maintaining beam coincidence through the stable_move api. </p>"},{"location":"openfibsem/concepts/#stage-positions","title":"Stage Positions","text":"<p>You can get and move to stage positions with the api. We also provide utils to save stage positions to file (.yaml) for restoration later. </p> <p>By default these stage positions are saved to fibsem/config/positions.yaml, and are accessible through the user interface (Movement Tab).</p> <pre><code># get stage position\nstage_position = microscope.get_stage_position()\n\n\n# go to stage position\nmicroscope.safe_absolute_stage_movement(stage_position)\n\n# save stage position (saves to fibsem/config/positions.yaml by default, can be specified)\nstage_position.name = \"my-position-01\"\nutils.save_positions(stage_position)\n</code></pre>"},{"location":"openfibsem/concepts/#flat-to-beam","title":"Flat to Beam","text":"<p>It is common to move the stage so that the sample surface is perpendicular to the imaging axis of one of the beams. When the stage is in one of these positions, we refer to it as being 'Flat to the Beam', e.g. Flat to the Electron Beam.</p> <p> Flat to Electron - Flat Sample Holder</p> <p> Flat to Ion - Flat Sample Holder</p> <p>To move to these positions, we require some information which is defined in the configuration:</p> <pre><code>stage:\n  rotation_reference: 0         # the reference rotation (rotation when loading the stage usually)\n  rotation_180:       180       # 180 degrees offset from rotation reference\n  shuttle_pre_tilt:   45        # the pretilt of the shuttle\nelectron:\n  column_tilt:        0         # the tilt of the electron column\nion:\n  column_tilt:        52        # the tilt of the ion column\n</code></pre> <p>In order to move flat to the beam, we need to adjust for the pre-tilt and column tilts, and specify which rotation reference to use. By definition, the electron beam uses the rotation reference, and the ion beam use the rotation 180. These values aren't always 0 / 180 and are determined by how the stage is physically mounted in the system.</p> <p>Once these values are defined we can easily move flat to the beam as follows:</p> <pre><code># NOTE: this will move from the current position, and only change rotation and tilt. It is recommended you move under the beam before hand.\n\n# move flat to the electron\nmicroscope.move_flat_to_beam(BeamType.ELECTRON)\n\n# move flat to the ion\nmicroscope.move_flat_to_beam(BeamType.ION)\n</code></pre> <p> Flat to Electron - Shuttle Pre-Tilt</p> <p> Flat to Ion - Shuttle Pre-Tilt</p>"},{"location":"openfibsem/concepts/#beam-coincidence","title":"Beam Coincidence","text":"<p>Beam coincidence is defined as the positioning of the stage, such that both beams are centred on the same feature. We sometimes also discuss the eucentric position, which refers to being able to tilt the stage and have the feature stay centred in the image. </p> <p>We can easily find the coincidence point for the system by using the following algorithm:</p> <ol> <li>Centre a Feature in the Electron Beam</li> <li>Move the Stage vertically in the chamber, until the feature is also centred in the Ion Beam.</li> </ol> <p>The system is now at the coincidence point.</p> <p>The difficult part of the algorithm is two fold:</p> <ol> <li> <p>We need to detect the same feature in both beam. Detecting features automaticaly can be difficult, and their appearance can vary between beams due to imaging differences and perspective.</p> </li> <li> <p>The standard stage axes move with the tilt of the stage, meaning it has to be compensated depending on the tilt, and pre-tilt.</p> </li> </ol> <p>We provide a number of methods and tools for resolving these issues, which will be discussed shortly. </p>"},{"location":"openfibsem/concepts/#microscope-state","title":"Microscope State","text":"<p>As described in the imaging section, we can snapshot the microscope state. This allows us to restore the state of the microscope at any point.</p> <p>The state is defined as the stage position, and the beam and detector settings for both beams.</p> <pre><code>@dataclass\nclass MicroscopeState:\n\n    \"\"\"Data Class representing the state of a microscope with various parameters.\"\"\"\n\n    timestamp: float                            # timestamp of state\n    stage_position: FibsemStagePosition         # raw stage position\n    electron_beam: BeamSettings                 # electron beam settings\n    ion_beam: BeamSettings                      # ion beam settings\n    electron_detector: FibsemDetectorSettings   # electron detector settings\n    ion_detector: FibsemDetectorSettings        # ion detector settings\n</code></pre> <p>You can get and restore the state as follows: <pre><code># store microscope state\nstate = microscope.get_microscope_state()\n\n# restore microscope state\nmicroscope.set_microscope_state(state)\n</code></pre></p>"},{"location":"openfibsem/concepts/#movement-axes-and-types","title":"Movement Axes and Types","text":"<p>We provide the following movement modes, and describe their application.</p>"},{"location":"openfibsem/concepts/#relative-movement","title":"Relative Movement","text":"<p>A relative movement, moves the stage by the specified amount in the raw coordinate system. This movement uses the manufacturers definition of the coordinate system. For example, for Thermo Fisher systems this moves in axes attached to the stage position.</p> <p>If you are using ashuttle pre-tilt it is recommended to use stable movement instead.</p>"},{"location":"openfibsem/concepts/#absolute-movement","title":"Absolute Movement","text":"<p>Absolute movement moves the stage to specified position in the raw coordinate system. It is used to return the stage to a previous position, or a projected position (based on a stable movement)</p> <p>You can use absolute movements to return to previous positions with high accuracy. </p> <pre><code># get the initial position\nstart_position = microscope.get_stage_position()\n\n# relative move (dx=20e-6, y=20e-6)\nstage_position = FibsemStagePosition(x=20e-6, y=20e-6)\nmicroscope.move_stage_relative(stage_position)\n\n# absolute move\nmicroscope.safe_absolute_stage_movement(stage_position)\n</code></pre>"},{"location":"openfibsem/concepts/#stable-movement","title":"Stable Movement","text":"<p>Stable movements move the stage along the sample plane. The primary use of stable movement is maintaining coincidence as you move across the sample. Stable moves correct for the stage tilt, shuttle pre-tilt and imaging perspective, and therefore you specify a beam to calculate the perspective from. </p> <p>Once you find the coincidence point, you can use stable movements to move across the sample and maintain coincidence. This does degrade over larger distances, and we are working on making it more robust. </p> <pre><code># NOTE: it recommended that you make the beams coincident before this to see the effect\n# move flat to electron\nmicroscope.move_flat_to_beam(BeamType.ELECTRON)\n\n# stable move\nmicroscope.stable_move(dx=20e-6, dy=20e-6, beam_type=BeamType.ELECTRON)\n</code></pre> <p> Stable Movement - Flat to Electron</p> <p> Stable Movement - Flat to Ion</p>"},{"location":"openfibsem/concepts/#vertical-movement","title":"Vertical Movement","text":"<p>Vertical movements, move the stage vertically in the chamber, regardles of tilt. The primary use of vertical movement is to restore coincidence of the beams. As a result, vertical movements can only be specified from the Ion beam perspective. </p> <p>You can use vertical movement in the user interface by holding 'Alt' and double clicking in the Ion Beam.</p> <pre><code># vertical move\nmicroscope.vertical_move(dx=0, dy=10e-6)\n</code></pre> <p> Vertical Movement - Flat to Electron</p> <p> Vertical Movement - Flat to Ion</p>"},{"location":"openfibsem/concepts/#finding-beam-coincidence","title":"Finding Beam Coincidence","text":"<p>Using stable and verical movements, we now have the basic procedure for setting the coincidence point manually in the user interface.</p> <p>Assuming you have the user interface open, move the stage under the beams, and taken images with both beams:</p> <ol> <li>Double click in the Electron Beam on the feature you would like to centre. The stage will move to centre that features. This is a stable movement.</li> <li>Hold 'Alt' and Double click in the Ion Beam on the same feature (note: if you can't see the same feature try increasing the hfw then re-image to see if its out of view). This is a vertical move. The feature should stay centred in the Electron beam, and the feature should move to the centre of the Ion.</li> <li>You can now double click in either beam to move the stage and the system should stay relatively coincident. There will be some small degradation depending on sample quality / consistency. </li> </ol> <p> Finding Coincidence - Flat to Ion</p> <p>You can repeat this any time you lose the coincidence. We use this same procedure with automated feature detection methods to automatically restore coincidence. Please see the Automation Section for more information. </p>"},{"location":"openfibsem/concepts/#milling","title":"Milling","text":"<p>Overview</p> <p>Milling Patterns</p> <p>Milling Parameters</p> <p>Milling Stages and Protocols</p> <p>Running Milling Operations</p>"},{"location":"openfibsem/concepts/#manipulator","title":"Manipulator","text":"<p>The manipulator is an insertable system use for sample manipulation and transfer. It is most commonly used for liftout workflows to transfer a region of the sample to an external landing grid. Manipulators can be needles or grippers. We currently only support needle based manipulators, such as the TFS EasyLift. </p>"},{"location":"openfibsem/concepts/#axes-and-coordinate-systems_1","title":"Axes and Coordinate Systems","text":"<p>Similar to the stage, the manipulator can have multiple coordinate systems. We use the Raw coordinate system to define the manipulator positions. </p>"},{"location":"openfibsem/concepts/#raw-coordinate-system","title":"Raw Coordinate System","text":"<p>TODO: draw coordinate system axes</p>"},{"location":"openfibsem/concepts/#corrected-movement-axes","title":"Corrected Movement Axes","text":"<p>We also provide a corrected manipulator movement api which allows for isolated axis movements. This allows you to move each axis of the manipulator when viewing from the image perspective. That is you can move the manipulator vertically in the Ion beam without moving it in the Electron. This is particular useful for automation routines.</p> <p>axis: image direction (beam) desc x+: right (both) y+: up (electron) z+: up (ion)      -&gt; moves manipulator towards the stage</p> <p>TODO: draw coordinate system axes</p>"},{"location":"openfibsem/concepts/#manipulator-control","title":"Manipulator Control","text":"<p>We provide the following methods for controlling the manipulator.</p>"},{"location":"openfibsem/concepts/#insert-manipulator","title":"Insert Manipulator","text":"<p>To insert the manipulator</p> <pre><code># insert manipulator\n\nfrom fibsem import utils, acquire\nfrom fibsem.structures import BeamType\nfrom matplotlib import pyplot as plt\n\n# NOTE: recommend that you move your stage flat + down before running this script\n\n# conect to microscope\nmicroscope, settings = utils.setup_session()\n\n# insert manipulator\nmicroscope.insert_manipulator(name=\"PARK\")\n\n# take reference images\nsettings.image.hfw = 400e-6\neb_image, ib_image = acquire.take_reference_images(microscope, settings.image)\n\n# plot\nfig, ax = plt.subplots(1, 2, figsize=(10, 5))\nax[0].imshow(eb_image.data, cmap=\"gray\")\nax[1].imshow(ib_image.data, cmap=\"gray\")\nplt.show()\n</code></pre>"},{"location":"openfibsem/concepts/#retract-manipulator","title":"Retract Manipulator","text":"<p>To retract the manipulator</p> <pre><code># retract manipulator\nmicroscope.retract_manipulator()\n\n# take reference images\nsettings.image.hfw = 400e-6\neb_image, ib_image = acquire.take_reference_images(microscope, settings.image)\n\n# plot\nfig, ax = plt.subplots(1, 2, figsize=(10, 5))\nax[0].imshow(eb_image.data, cmap=\"gray\")\nax[1].imshow(ib_image.data, cmap=\"gray\")\nplt.show()\n</code></pre>"},{"location":"openfibsem/concepts/#manipulator-movement","title":"Manipulator Movement","text":"<p>It is recommended to use the corrected movements, as they will isolate the movements of the manipulator to in the imaging perspective. They are independent of stage tilt. </p> <pre><code># corrected manipulator movements\n\n# insert manipulator\nmicroscope.insert_manipulator(name=\"PARK\")\n\n# take reference images\nsettings.image.hfw = 400e-6\neb_image, ib_image = acquire.take_reference_images(microscope, settings.image)\n\n# plot\nfig, ax = plt.subplots(1, 2, figsize=(15, 5))\nplt.suptitle(f\"Manipulator Inserted\")\nax[0].imshow(eb_image.data, cmap=\"gray\")\nax[1].imshow(ib_image.data, cmap=\"gray\")\nplt.show()\n\n# move manipulator down (ION)\nmicroscope.move_manipulator_corrected(dx=0, dy=-20e-6, beam_type=BeamType.ION)\n\n# take reference images\nsettings.image.hfw = 400e-6\neb_image, ib_image = acquire.take_reference_images(microscope, settings.image)\n\n# plot\nfig, ax = plt.subplots(1, 2, figsize=(15, 5))\nplt.suptitle(f\"Manipulator Moved (ION)\")\nax[0].imshow(eb_image.data, cmap=\"gray\")\nax[1].imshow(ib_image.data, cmap=\"gray\")\nplt.show()\n\n# move manipulator in x, y (ELECTRON)\nmicroscope.move_manipulator_corrected(dx=10e-6, dy=-10e-6, beam_type=BeamType.ION)\n\n# take reference images\nsettings.image.hfw = 400e-6\neb_image, ib_image = acquire.take_reference_images(microscope, settings.image)\n\n# plot\nfig, ax = plt.subplots(1, 2, figsize=(15, 5))\nplt.suptitle(f\"Manipulator Moved (ELECTRON)\")\nax[0].imshow(eb_image.data, cmap=\"gray\")\nax[1].imshow(ib_image.data, cmap=\"gray\")\nplt.show()\n</code></pre> <p>You can also use relative and absolute movements, but they are not recommended unless you know what you are doing. </p> <pre><code># relative move\nposition = FibsemManipulatorPosition(x=10e-6, y=10e-6)\nmicroscope.move_manipulator_relative(position)\n\n# absolute move\nposition = FibsemManipulatorPosition(x=10e-6, y=10e-6)\nmicroscope.move_manipulator_absolute(position)\n</code></pre>"},{"location":"openfibsem/concepts/#saved-positions","title":"Saved Positions","text":"<p>When calibrating the manipulator, two positions are defined, PARK and EUCENTRIC. The PARK position is high above the sample (approx ~180um) and is the default insertion position. The EUCENTRIC position is determined when you calibrate the manipulator. It should be when the manipulator is centred in the Electron Beam, and centred vertically in the Ion Beam. This is the best way to judge depth and where the manipulator will make contact with the sample.</p> <p>You can access these saved positions:</p> <pre><code># move to saved position (note: manipulator needs to be inserted beforehand)\nposition = microscope._get_saved_manipulator_position(\"PARK\")\nmicroscope.move_manipulator_absolute(position)\n</code></pre>"},{"location":"openfibsem/concepts/#offset-positions","title":"Offset Positions","text":"<p>You can also move to an offset from a named position. The offset is defined in the raw coordinates, i.e real manipulator position. The following code will insert the manipulator to 10um above the eucentric position. T  </p> <pre><code># move to offset position\nfrom fibsem.structures import FibsemManipulatorPosition\n\n# set position offset\nposition_offset = FibsemManipulatorPosition(z=10e-6, coordinate_system=\"RAW\")\n\n# move manipulator to offset position (z=10e-6 above EUCENTRIC)\nmicroscope.move_manipulator_to_position_offset(position_offset, name=\"EUCENTRIC\")\n\n# take reference images\nsettings.image.hfw = 150e-6\neb_image, ib_image = acquire.take_reference_images(microscope, settings.image)\n\n# plot\nfig, ax = plt.subplots(1, 2, figsize=(15, 5))\nplt.suptitle(f\"Manipulator Moved To Offset\")\nax[0].imshow(eb_image.data, cmap=\"gray\")\nax[1].imshow(ib_image.data, cmap=\"gray\")\nplt.show()\n</code></pre>"},{"location":"openfibsem/concepts/#manipulator-calibration","title":"Manipulator Calibration","text":"<p>There are two supported calibration tools; ThermoFisher and TESCAN</p>"},{"location":"openfibsem/concepts/#thermo-fisher-easylift","title":"Thermo Fisher EasyLift","text":"<p>The manipulator calibration tool assists in calibrating the EasyLift. Due to API limitations, the user still has to activate the calibration procedure in xTUI and then can follow the instructions in the tool to calibrate their EasyLift each day.</p> <p>You can also run this as a script using the following:</p> <pre><code>python fibsem/tools/run_manipulator_calibration.py\n</code></pre>"},{"location":"openfibsem/concepts/#tescan-calibration","title":"TESCAN Calibration","text":"<p>The manipulator calibration tool will calibrate the TESCAN manipulator and map it to known coordinate systems. This allows it to follow the same convention used in the rest of the Manipulator API.</p>"},{"location":"openfibsem/concepts/#manipulator-preparation","title":"Manipulator Preparation","text":"<p>Often, liftout methods require the preparation of the manipulator before use, e.g. attaching the copper adaptor for Serial Liftout. Manipulator preparation procedures are available in AutoLamella for both the liftout and serial-liftout methods. To use the procedures, open AutoLiftout UI, connect to the microscope, create an experiment and corresponding protocol. Then the preparation procedures are availle through the Tools -&gt; Manipulator Preparation menu. Please not that you should calibrate the manipulator before hand.  </p>"},{"location":"openfibsem/concepts/#manipulator-exchange","title":"Manipulator Exchange","text":"<p>As the manipulator is used, it often becomes worn down through repeated milling or preparation. Eventually, it will become shortened and the motors will not have enough range to reach the sample. At this point, you need to exchange the manipulator. This can only be done when the system is vented, and will therefore required system downtime (especially for cryo operation). We do not currently have control over manipulator exchange, and it must be completed manually. The supported liftout method does not damage the manipulator and therefore it can be used for extended periods of time.  </p>"},{"location":"openfibsem/concepts/#gas-injection-and-sputter-coater","title":"Gas Injection and Sputter Coater","text":"<p>Gas Injection Systems are a broad category of systems that are used for depositing material on the sample. We split these into three categories; specific deposition, cryo deposition and sputter coating.</p>"},{"location":"openfibsem/concepts/#specific-deposition","title":"Specific Deposition","text":"<p>Specific deposition refers to using the using the beams to deposition in specific locations on the sample. A milling pattern is used to target and bake the area for deposition. </p> <p>Currently, OpenFIBSEM does not support targeted deposition (i.e. ion beam deposition). We would like to add this in the future. If you would like us to prioritise this, please get in contact, or submit a pull request. This will involve some changes to the milling api first. </p>"},{"location":"openfibsem/concepts/#cryogenic-deposition","title":"Cryogenic Deposition","text":"<p>In cryogenic conditions, it is not possible to specifically deposition as the material condenses immediately. Therefore, you can only deposition in a general way (i.e. over everything). </p> <p>We support cryogenic deposition (i.e non-specific) deposition. You can also access the controls through the Cryo Deposition tool in AutoLamella (Tools -&gt; Cryo Deposition).</p> <p>Note: The system we have tested this on uses a multi-chem, so it may not work correctly for non-multichem systems. If you have a standard gis and would like to test, please contact us. </p> <pre><code>from fibsem import gis, utils\n\n# connect to microscope\nmicroscope, settings = utils.setup_session()\n\n# save current position (optional)\nposition = microscope.get_stage_position()\nposition.name = \"cryo-deposition-grid-01\"\nutils.save_positions([position])\n\n# example cryo deposition protocol\ngis_protocol = {\n    \"application_file\": \"cryo_Pt_dep\",          # gis application file\n    \"gas\": \"Pt cryo\",                           # gis gas\n    \"position\": \"cryo\",                         # gis position \n    \"hfw\": 3.0e-05 ,                            # image field width\n    \"length\": 7.0e-06,                          # pattern length\n    \"beam_current\": 1.0e-8,                     # beam current\n    \"time\": 30.0,                               # deposition time\n}\n\n# run cryo deposition\ngis.cryo_deposition(microscope, \n                    protocol=gis_protocol, \n                    name=\"cryo-deposition-grid-01\")     # specifying name is optional\n                                                        # if not specified, current position is used\n</code></pre>"},{"location":"openfibsem/concepts/#sputter-coating","title":"Sputter Coating","text":"<p>Sputter coating refers to the integrated sputter coater (e.g. on the TFS Aquilos 2). It is usually a separate system than the standard GIS. </p> <p>Currently, OpenFIBSEM does not support sputter coating. We would like to add this in the future, but do not have access to a system with it. If you would like us to prioritise this, and have a system we could use to test, please get in contact.  </p>"},{"location":"openfibsem/concepts/#logging","title":"Logging","text":"<p>OpenFISBEM uses a structured event logging format. Operations are logged using a json format and can be parsed directly from the log file. By default, logs are saved in the session directory in logfile.log. For AutoLamella applications, logs are saved inside the Experiment directory in the logfile.log.  </p>"},{"location":"openfibsem/concepts/#log-parsing","title":"Log Parsing","text":"<p>AutoLamella contains a log parser for extracting statistical information from the logs, and a explorer application for analysing data. You could also use other log parsers to export this data. </p> <p>Log Parser:</p> <pre><code>autolamella/tools/data.py\n</code></pre> <p>To run the explorer app:</p> <pre><code>streamlit run autolamella/tools/stats.py\n</code></pre>"},{"location":"openfibsem/concepts/#automation","title":"Automation","text":""},{"location":"openfibsem/concepts/#alignment","title":"Alignment","text":""},{"location":"openfibsem/concepts/#image-registration","title":"Image Registration","text":""},{"location":"openfibsem/concepts/#segmentation-machine-learning","title":"Segmentation (Machine Learning)","text":"<p>We provide a standardised segmentation model interface, for loading models, running inference and visualisation.</p> <pre><code>from fibsem.segmentation.model import load_model\nfrom fibsem.segmentation.utils import plot_segmentations\nfrom fibsem.structures import FibsemImage\n\n\n# load model\nmodel = load_model(\"autolamella-mega-20240107.pt\")\n\n# load image (or acquire from microscope)\nimage = FibsemImage.load(\"data/test_image.tif\")\n\n# model inference (rgb = True to auto convert to rgb)\nmask = model.inference(image.data, rgb=False)\nmask = mask[0]\n\n# plot segmentation\nfig = plot_segmentations(image.data, mask, alpha=0.5)\n</code></pre> <p></p> <p>You can also plot multiple segmentations at once.</p> <pre><code>from fibsem.segmentation.model import load_model\nfrom fibsem.structures import FibsemImage\nfrom fibsem.segmentation.utils import plot_segmentations\nimport glob\n\n# load model\nmodel = load_model(\"autolamella-serial-liftout-20240107.pt\")\n\n# load data\nfilenames = sorted(glob.glob(\"data/example/0*.tif\"))\n\nmasks = []\nimages = []\n\nfor fname in filenames:\n    image = FibsemImage.load(fname)\n\n    mask = model.inference(image.data, rgb=False)\n    mask = mask[0]\n\n    masks.append(mask)\n    images.append(image)\n\nfig = plot_segmentations(images, masks, alpha=0.5)\n</code></pre> <p></p>"},{"location":"openfibsem/concepts/#feature-detection","title":"Feature Detection","text":"<p>We support a standardised feature detection interface. All standardised features are implemented as an abstract base class Feature, with standard properties and interfaces (.name, .color, .detect())</p> fibsem/detection/detection.py<pre><code>@dataclass\nclass Feature(ABC):\n    px: Point                 # the position of the feature in the image (pixels, image frame)\n    feature_m: Point          # the position of the feature in the image (metres, microscope frame)\n    color = \"white\"           # the display color \n    name: str = None          # the display name \n    class_id: int = None      # the class id    (ml based features only)\n    class_name: str = None    # the class name  (ml based features only)\n\n    @abstractmethod\n    def detect(self, img: np.ndarray, mask: np.ndarray=None, point:Point=None) -&gt; 'Feature':\n        pass\n\n    def to_dict(self):\n        return {\n            \"name\": self.name,\n            \"px\": self.px.to_dict(),\n            \"feature_m\": self.feature_m.to_dict()\n        }\n</code></pre> <p>This interface allows features to implement their own detect method, which can be as simple or as complex as needs be, while allowing them to be used with all the other tools. </p> fibsem/detection/detection.py<pre><code>## A simple feature for returning the centre of the image\n@dataclass\nclass ImageCentre(Feature):\n    feature_m: Point = None\n    px: Point = None\n    color = \"white\"\n    name: str = \"ImageCentre\"\n\n    def detect(self, img: np.ndarray, mask: np.ndarray=None, point:Point=None) -&gt; 'ImageCentre':\n        self.px = Point(x=img.shape[1] // 2, y=img.shape[0] // 2)\n        return self.px\n\n\n## A more complicated feature for detecting the tip of the manipulator, using a custom detect method\n@dataclass\nclass NeedleTip(Feature):\n    feature_m: Point = None\n    px: Point = None\n    color = \"green\"\n    name: str = \"NeedleTip\"\n    class_id: int = 2\n    class_name: str = \"manipulator\"\n\n    def detect(self, img: np.ndarray, mask: np.ndarray = None, point:Point=None) -&gt; 'NeedleTip':\n        self.px = detect_needle_v5(mask, idx=self.class_id, edge=\"right\")\n        return self.px\n\n# detect method\ndef detect_needle_v5(mask: np.ndarray, idx:int=2, edge: str =\"right\") -&gt; Point:\n    needle_mask = mask == idx\n    return detect_absolute_edge(needle_mask, edge=edge, \n        _filter=\"largest\", _mode=\"median\", threshold=150)\n</code></pre> <p>The list of available features is accessible here:</p> <p><pre><code>from fibsem.detection import detection\n\nprint(detection.__FEATURES__)\n</code></pre> We use the following api to detect features, and return them in a standard format. We also provide utilities for plotting. </p> <p><pre><code>from fibsem.detection import detection\nfrom fibsem.segmentation.model import load_model\nfrom fibsem.structures import FibsemImage\nfrom fibsem.detection.detection import DetectedFeatures\n\n# load model\nmodel = load_model(\"autolamella-mega-20240107.pt\")\n\n# load image (or acquire from microscope)\nimage = FibsemImage.load(\"test_image.tif\")\n\n\n# detect features (also runs segmentation inference)\ndet: DetectedFeatures = detection.detect_features(\n    image= image, \n    model= model, \n    features = features\n    pixelsize = image.metadata.pixelsize\n    filter = True,\n    point = None\n)\n\n# plot detections\nfig = detection.plot_detection(det)\n</code></pre>  Feature Detection Example</p> fibsem/detection/detection.py<pre><code>@dataclass\nclass DetectedFeatures:\n    features: list[Feature]             # list of detected features\n    image: np.ndarray                   # image data\n    mask: np.ndarray                    # class binary mask\n    rgb: np.ndarray                     # rgb mask\n    pixelsize: float                    # image pixelsize\n    _distance: Point = None             # distance between the first two features\n    _offset: Point = Point(0, 0)        # offset applied to distance\n    fibsem_image: FibsemImage = None    # the fibsem image \n    checkpoint: str = None              # model checkpoint \n\n    @property\n    def distance(self):\n        assert len(self.features) &gt;= 2, \"Need at least two features to calculate distance\"\n        return self.features[0].px.distance(self.features[1].px)._to_metres(self.pixelsize) + self._offset        \n\n    @distance.setter\n    def distance(self, value: Point) -&gt; None:\n        self._distance = value\n\n    def get_feature(self, ftype: Union[str, Feature]) -&gt; Feature:\n        for feature in self.features:\n            if feature.name == ftype or isinstance(feature, type(ftype)):\n                return feature\n\n    def to_dict(self):\n        return {\n            \"features\": [f.to_dict() for f in self.features],\n            \"pixelsize\": self.pixelsize,\n            \"offset\": self._offset.to_dict(),\n        }\n\n\ndef detect_features(\n    image: Union[np.ndarray, FibsemImage],          # the image to detect features in\n    model: SegmentationModel,                       # the segmentation model\n    features: tuple[Feature],                       # the list of features to detect  \n    pixelsize: float,                               # the pixel size of the image (used to calculate microscope coordinate conversion)\n    filter: bool = True,                            # filter to the best feature, best is determined by being closest to the point. \n                                                    # false will return multiple detections each feaature\n    point: Point = None                             # the point to use for the 'best' feature. defaults to the centre of the image if not specified\n) -&gt; DetectedFeatures:\n\n    if isinstance(image, FibsemImage):\n        fibsem_image = deepcopy(image)\n        image = image.data\n    else:\n        fibsem_image = None\n\n    # model inference\n    mask = model.inference(image, rgb=False)\n    rgb = model.postprocess(mask, model.num_classes)\n    mask = mask[0] # remove channel dim\n\n    # detect features\n    features = detect_features_v2(img=image, \n                                  mask=mask, \n                                  features=features, \n                                  filter=filter, point=point)\n\n    det = DetectedFeatures(\n        features=features, # type: ignore\n        image=image,\n        mask=mask,\n        rgb=rgb,\n        pixelsize=pixelsize,\n        fibsem_image=fibsem_image,\n        checkpoint=model.checkpoint\n    )\n\n    # distance in metres (from centre)\n    for feature in det.features:\n        feature.feature_m = conversions.image_to_microscope_image_coordinates(\n            feature.px, det.image.data, det.pixelsize\n        )\n\n    return det\n</code></pre> <p>You can also detect multiple instances of the same feature, and plot multiple detections at once.</p> <p><pre><code>%load_ext autoreload\n%autoreload 2\n\nfrom fibsem.detection import detection\nfrom fibsem.segmentation.model import load_model\nfrom fibsem.structures import FibsemImage\nfrom fibsem.detection.detection import DetectedFeatures, NeedleTip, LamellaRightEdge\nimport glob\n\n# load model\nmodel = load_model(\"autolamella-mega-20240107.pt\")\n\n# load data\nfilenames = glob.glob(\"data/example/ml*.tif\")\nfeatures = [detection.LamellaCentre()]\n\ndets = []\nfor fname in filenames:\n\n    image = FibsemImage.load(fname)\n\n    # detect features (also runs segmentation inference)\n    det: DetectedFeatures = detection.detect_features(\n        image= image, \n        model= model, \n        features = features,\n        pixelsize = 25e-9,      # note: this should be from image.metadata.pixelsize typically\n        filter=False, \n        point= None\n    )\n\n    dets.append(det)\n\n# plot detections\ndetection.plot_detections(dets)\n</code></pre> </p> <p>Multiple Feature Detection Examples</p>"},{"location":"openfibsem/concepts/#objects-api","title":"Objects API","text":"<p>For more generic features, such a bounding boxes, instance masks, and keypoints, you can use the generic get_objects method. This returns are list of detected objects with bboxes, instance masks, and keypoints for each. </p> <pre><code>## Example: Get Objects API\n\nfrom fibsem.detection import detection \nfrom fibsem.segmentation.model import load_model\nfrom fibsem.structures import FibsemImage \n\n# load image\nimage = FibsemImage.load(\"data/test_image.tif\")\n\n# load mega model\nmodel = load_model(\"autolamella-mega-20240107.pt\")\n\n# run model inference\nmask = model.inference(image.data, rgb=False)\nmask = mask[0]\n\n# get all objects\nobjects = detection.get_objects(mask)\n\n# plot bounding boxes\nfig = detection.plot_bounding_boxes(image.data, mask, objects)\n</code></pre> <p> Bounding Boxes Example</p>"},{"location":"openfibsem/concepts/#machine-learning-data-engine","title":"Machine Learning Data Engine","text":"<p>We have implemented a data engine into the AutoLamella program. This data engine enables efficient model improvement across a wide range of tasks by using human feedback, and a set of model enhanced tools. Moreover, the data engine allows the models to improve faster, and more efficiently as they improve in performance by using the models to label data and generate test sets.</p> <p>[DATA ENGINE IMAGE]</p>"},{"location":"openfibsem/concepts/#data-collection","title":"Data Collection","text":"<p>When running AutoLamella, we automatically save the images, masks and keypoint detections from the machine learning systems. In addition, any image can be manually added to the dataset, but will have to be manually pre-processed to conform. By default, machine learning data (images, masks, keypoints) are saved to the fibsem/log/data/ml directory.</p>"},{"location":"openfibsem/concepts/#data-curation","title":"Data Curation","text":"<p>In order to efficiently improve the model, as well as automatically generate test datasets we implemented an active learning system into the user interface. When running AutoLamella in Supervised Mode, the user has the opportunity to correct the keypoint detections produced by the model. We log this intervention, and flag that image to be added to the training dataset. Images that the model gets correct are also logged, and added to the test dataset.</p> <p>This form of active learning allows us to collect images that the model is currently failing on, and not feed it any more of images that it already succeeds at. This is crucical to balance the dataset, and efficiently improve when the dataset is relative small (~100s of images).</p> <p>For more details on this approach to data curation, please see AutoLamella Datasets and Models</p>"},{"location":"openfibsem/concepts/#data-labelling","title":"Data Labelling","text":"<p>We developed a napari plugin for labelling images for semantic segmentation. The plugin supports three complementary labelling modes; manual labelling, model assisted labelling and sam assisted labelling.</p> <p>Image Labelling Napari Plugin</p> <p>For details about how this was used, please see AutoLamella Datasets and Models</p>"},{"location":"openfibsem/concepts/#manual-labelling","title":"Manual Labelling","text":"<p>The default mode is manual labelling, which enables the use the napari paint tools to manually label images. The manual labelling mode is also used to edit or 'touch up' model generated labels.</p> <p>The user can define the segmentation labels and colors used by editing the fibsem/segementation/segmentation_config.yaml file.  </p>"},{"location":"openfibsem/concepts/#model-assisted-labelling","title":"Model Assisted Labelling","text":"<p>The model assisted labelling tool allows you to use a trained model to assist in the labelling of new data. This is useful for labelling large datasets. The model will make a prediction and the user can correct the prediction using the same drawing tools.</p> <p>To use, go to the Model tab and load your model, and then tick 'model assisted' to enable the model assisted labelling.</p>"},{"location":"openfibsem/concepts/#segmentanything-assisted-labelling","title":"SegmentAnything Assisted Labelling","text":"<p>We have implemented the Segment Anything Model from MetaAI. This model is trained to segment any object. Here we use it as part of the model assisted labelling. We currently support the huggingface transformers implementation for SAM. You can use any compatible SAM model.</p> <p>The recommended models are:</p> <ul> <li>Large GPU: facebook/sam-vit-base or facebook/sam-vit-large</li> <li>Small GPU / CPU: Zigeng/SlimSAM-uniform-50</li> </ul> <p>Instructions for using SAM assisted labelling are shown in the side panel.</p>"},{"location":"openfibsem/concepts/#model-training","title":"Model Training","text":"<p>Model training is relatively simple, and by default we use models from the segmentation-models-pytorch package for the implementation.</p>"},{"location":"openfibsem/concepts/#data-augmentation","title":"Data Augmentation","text":"<p>Data is augmented with standard data augmentation methods that are suitable for electron microscope data.</p> <p>We currently use; random rotation, random horizontal / vertical flip, random autocontrast, random equalize, gaussian blue and color jitter.</p>"},{"location":"openfibsem/concepts/#losses-optimiser","title":"Losses, Optimiser","text":"<p>We use a standard Adam optimiser, and multi-loss (cross-entropy, dice, and focal)</p>"},{"location":"openfibsem/concepts/#training-the-model","title":"Training the Model","text":"<p>To train the model:</p> <pre><code>python fibsem/segementation/train.py --config training-config.yaml\n</code></pre> <p>Example Model Training Config</p> training-config.yaml<pre><code># data\ndata_paths:  [/path/to/data, /path/to/second/data]                  # paths to image data (multiple supported)\nlabel_paths: [/path/to/data/labels, /path/to/second/data/labels]    # paths to label data (multiple supported)\nsave_path: /path/to/save/checkpoints                                # path to save checkpoints (checkpointed each epoch)\ncheckpoint: null                                                    # checkpoint to resume from\n\n# model\nencoder: \"resnet34\"                             # segmentation model encoder (imagenet)\nnum_classes: 6                                  # number of classes\n\n# training\nepochs: 50                                      # number of epochs\nsplit: 0.1                                      # train / val split\nbatch_size: 4                                   # batch size\nlr: 3.0e-4                                      # initial learning rate\n\n# logging\ntrain_log_freq: 32                              # frequency to log training images\nval_log_freq: 32                                # frequency to log validation images\n\n# wandb\nwandb: true                                     # enable wandb logging\nwandb_project: \"autolamella-mega\"               # wandb project\nwandb_entity: \"openfibsem\"                      # wandb user / org\nmodel_type: \"mega-model\"                        # model type note (descriptive only)\nnote: \"notes about this specific training run\"  # additional trianing note (descriptive only)\n</code></pre>"},{"location":"openfibsem/concepts/#external-integration-nnunet","title":"External Integration - NNUnet","text":"<p>NNUnet is a popular library for training segmentation models. We provide a set of converters for converting datasets to the nnunet format, and converting nnunet models to compatible openfibsem formats.</p> <p>Script to convert data labelled with OpenFIBSEM to NNUnet format.</p> <pre><code>python scripts/convert_to_nnunet_dataset.py -h\n--data_path: the path to the images directory (source)\n--label_path:  the path to the labels directory (source)\n--nnunet_data_path: the path to nnunet data directory (destination)\n--label_map : list of label names (text file)\n--filetype: the file extension of the images / labels (.tif for fibsem)\n</code></pre> <p>Script to convert nnunet trained model directory to checkpoint</p> <pre><code>python scripts/export_nnunet_checkpoint.py -h\n--path: path to nnunet model directory (source)\n--checkpoint_path: the path to save the output checkpoint\n--checkpoint_name: the filename of the output checkpoint \n</code></pre> <p>Make sure you save your checkpoint with 'nnunet' in the name so the load_model helper can automatically load it:</p> <pre><code>from fibsem.segementation.model import load_model\n\n# load nnunet model checkpoint\nmodel = load_model('my-nnunet-model-checkpoint.pt')\n</code></pre>"},{"location":"openfibsem/concepts/#external-integration-onnx","title":"External Integration - ONNX","text":"<p>ONNX (Open Neural Network Exchange) is standardised format for machine learning models. We provide a script to convert trained models to onnx format. ONNX models are much more portable, and don't require the dependency on pytorch to run.</p> <pre><code>python scripts/convert_to_onnx.py -h\n--checkpoint: path to openfibsem model checkpoint\n--output: path to save onnx checkpoint\n</code></pre> <p>Code to load onnx model in openfibsem</p> <pre><code>from fibsem.segmentation.model import load_model\n\n# load onnx model\nmodel = load_model(\"my-model-checkpoint.onnx\")\n</code></pre>"},{"location":"openfibsem/concepts/#model-evaluation","title":"Model Evaluation","text":""},{"location":"openfibsem/concepts/#keypoint-labelling","title":"Keypoint Labelling","text":"<p>We provide a Keypoint Labelling Napari Plugin that can be used to label or edit keypoint labels generated by openfibsem. You can start from an empty directory of images, or load a csv containing the keypoint detections. The keypoints are used to evaluate the model as if it were being used online.</p> <p>When you run AutoLamella, these keypoints used for detections are automatically logged, ready be used for evaluation.</p>"},{"location":"openfibsem/concepts/#keypoint-evaluation","title":"Keypoint Evaluation","text":"<p>We provide evaluation tools for evaluating the perform of a number of different models on the keypoint detection task.</p> <p>The evaluation will run each model checkpoint through the detection pipeline, save the results and compare them to the ground truth labels provided. Each indivudal image can be plotted, as well as the full evaluation statistics. This evaluation pipeline is useful for checking model improvement and preventing regressions on previously successful tasks.</p> <p>To run the evaluation:</p> <pre><code>python fibsem/detection/run_evaluation.py --config config.yaml\n</code></pre> <p>Example Evaluation Configuration</p> <pre><code>data_path: \"path/to/data/keypoints.csv\"     # test data csv (keypoints)\nimages_path: \"path/to/data\"                 # test data image directory\nsave_path: \"path/to/results\"                # save path for evaluation results\n\ncheckpoints: # list of checkpoints to evaluate\n  - checkpoint: \"checkpoint-01.pt\"\n  - checkpoint: \"checkpoint-02.pt\"\n\nthresholds: # pixel thresholds for 'matched' keypoints\n- 250\n- 100\n- 50\n- 25\n- 10\n\n# options\nrun_eval: True          # run the evaluation\nplot_eval: True         # plot the evaluation\n\nshow_det_plot: False    # show the individual keypoint detection plots\nsave_det_plot: True     # save the indivudial keypoint detection plots\nshow_eval_plot: False   # show the complete evaluation plots\nsave_eval_plot: True    # save the complete evaluation plots\n</code></pre>"},{"location":"openfibsem/concepts/#model-deployment","title":"Model Deployment","text":"<p>We provide a number of generic segmentation model interfaces. We currently support the following model backends: backend = \"smp\" (default), \"nnunet\", \"onnx\"</p> <p>The load model function will automatically check which backend to use based off the name of the checkpoint. The overall generality of this model interface will be improved in the future.</p> <p>Code</p> <pre><code>from fibsem.segmentation.model import load_model\n\n# load smp model\nmodel = load_model(\"my-model-checkpoint.pt\")\n\n# load onnx model\nmodel = load_model(\"my-model-checkpoint.onnx\")\n\n# load nnunet model\nmodel = load_model(\"my-nnunet-model-checkpoint.pt\")\n\n# explictly set backend\nmodel = load_model(\"my-nnunet-model-checkpoint.pt\", backend=\"nnunet\")\n</code></pre> <p>AutoLamella checkpoints are available via huggingface (patrickcleeve/autolamella), and can be selected in the protocol tab in AutoLamella. </p>"},{"location":"openfibsem/concepts/#user-interface","title":"User Interface","text":"<p>Each application has an associated user interface to allow the user to easily setup and monitor the workflow.</p> <p>Applications: </p> <ul> <li>OpenFIBSEM UI:  General FIBSEM control user interface.</li> <li>AutoLamella UI: On Grid lamella preparataion workflows</li> <li>AutoLiftout UI: Liftout based lamella preparation workflows (NB: this will be merged with AutoLamella UI in the near future)</li> </ul> <p>Each user interface is implemented in napari and pyqt5. To launch the applications and plugins through napari see napari plugins section.</p>"},{"location":"openfibsem/concepts/#user-interface-controls","title":"User Interface Controls","text":"<p>The following standard controls are used in all applications.</p>"},{"location":"openfibsem/concepts/#movement-controls","title":"Movement Controls","text":"<p>When interacting with the imaging displays, the follow controls are supported.</p> <ul> <li>Double Left Click: Move the stage to the selected position (Stable Move)</li> <li>Alt + Double Left Click: Move the stage to the selected position (Vertical Move). Only supported in Ion Beam.</li> <li>Shift + Left Click: Move the selected milling pattern to the position. Only supported in the Ion Beam.</li> <li>Ctrl + Shift + Left Click: Move all milling patterns to the position. Only supported in the Ion Beam.</li> </ul>"},{"location":"openfibsem/concepts/#keypoint-controls","title":"Keypoint Controls","text":"<p>The following controls are supported when interacting with keypoints.  Select Keypoint: Click on keypoint Move Keypoint: Select and drag keypoint</p>"},{"location":"openfibsem/concepts/#user-interface-widgets","title":"User Interface Widgets","text":"<p>We developed a set of ui widgets that are reused across applications.</p>"},{"location":"openfibsem/concepts/#microscope-connection-widget","title":"Microscope Connection Widget","text":"<p>This widget allows the user to connect to the microscope, and configure the system.</p>"},{"location":"openfibsem/concepts/#imaging-widget","title":"Imaging Widget","text":"<p>This widget allows the user to acquire images, adjust imaging parameters and use tools (e.g. ruler).</p>"},{"location":"openfibsem/concepts/#movement-widget","title":"Movement Widget","text":"<p>This widget allows the user to move the stage, and save positions.</p>"},{"location":"openfibsem/concepts/#milling-widget","title":"Milling Widget","text":"<p>This widget allows the user to draw milling patterns, adjust parameters, setup milling operations and run milling.</p>"},{"location":"openfibsem/concepts/#manipulator-widget","title":"Manipulator Widget","text":"<p>This widget allows the user to control the manipulator.</p>"},{"location":"openfibsem/concepts/#feature-detection-widget","title":"Feature Detection Widget","text":"<p>This widget allows the user to supervise the keypoint detections during a workflow, and correct them if required. </p>"},{"location":"openfibsem/concepts/#minimap-widget","title":"Minimap Widget","text":"<p>This widget allows the user to use the minimap, which supports tiled imaging, low magnifcation navigation and lamella position selection. </p>"},{"location":"openfibsem/concepts/#user-inferface-tools","title":"User Inferface Tools","text":""},{"location":"openfibsem/concepts/#cryo-deposition","title":"Cryo Deposition","text":"<p>You can access the cryo deposition tool via the Tools menu of AutoLamella / AutoLiftout.</p>"},{"location":"openfibsem/concepts/#sputter-coating_1","title":"Sputter Coating","text":"<p>Not Yet Available</p>"},{"location":"openfibsem/concepts/#manipulator-tools","title":"Manipulator Tools","text":"<p>You can access the manipulator calibration and preparation tools via the Tools menu of AutoLiftout. </p>"},{"location":"openfibsem/concepts/#supervised-mode","title":"Supervised Mode","text":"<p>Supervised mode can be enabled in AutoLamella. In the mode the software will pause and wait for user feedback / confirmation at specific points in the workflow. This enables the user to supervise the process, fix any mistakes, and have the software execute the rest of the workflow.  </p>"},{"location":"openfibsem/concepts/#feature-detection_1","title":"Feature Detection","text":"<p>In supervised mode, the software will pause after making a keypoint detection, and ask the user to confirm. The user can move the keypoint to the correct position, and continue with the workflow. The updated keypoint will be used in the workflow, and the correction data will be logged for later use in the data engine (see below).</p>"},{"location":"openfibsem/concepts/#milling-operations","title":"Milling Operations","text":"<p>In supervised mode, the software will pause before performing a milling operation, and ask the user to confirm the milling operations. The user can move the pattern, adjust the parameters and repeat the milling operations mulitple times. If not in supervised mode, milling operations are completed automatically.</p>"},{"location":"openfibsem/concepts/#additional","title":"Additional","text":"<p>In supervised mode, the software will also pause and ask for confirmation at other specific steps. For example, the when running liftout methods, the software will ask the user to confirm the lamella has made contact with the post. If they confirm, the software continues with the workflow, if not the final landing procedure is repeated until the lamella lands correctly. </p>"},{"location":"openfibsem/concepts/#napari-plugins","title":"Napari Plugins","text":"<p>To enable access to the user interfaces, and plugins directly through napari, please install the openfibsem napari plugin (napari-openfibsem).</p> <pre><code>pip install napari-openfibsem\n</code></pre> <p>This allows the user to access the Applications (OpenFIBSEM UI, AutoLamella UI, AutoLiftout UI) and Plugins (Imaging Labelling, Keypoint Labelling) directly through the plugin interface. </p>"},{"location":"openfibsem/examples/","title":"Examples","text":"<p>The example directory contains a few example code snippets to help you get started with OpenFIBSEM.</p> <p>The scripts are setup to run on the simulated microscope (manufactuer=\"Demo\") by default. You can run them on a real microscope by specifying the manufacturer and ip_address in setup_session. Please becareful and understand the code before running on a real microscope.</p> <p>Before running these scripts, make sure you have installed openfibsem, the manufacturers api, and activated your environment.</p> <p>To activate your environment</p> <pre><code>conda activate fibsem\n</code></pre>"},{"location":"openfibsem/examples/#basic-example","title":"Basic Example","text":"<p>This basic example script demonstrates how to connect to the microscope (setup_session), and take an image with both beams. The images are then displayed with matplotlib.</p> <p>To run the script:</p> <pre><code>python example/example.py\n</code></pre> example/example.py<pre><code>from fibsem import utils, acquire\n\nimport matplotlib.pyplot as plt\nimport matplotlib\nmatplotlib.use('TkAgg', force=True) # Activate 'agg' backend for off-screen plotting.\n\n\ndef main():\n\n    # connect to microscope\n    microscope, settings = utils.setup_session(manufacturer=\"Demo\", ip_address=\"localhost\")\n\n    # take image with both beams\n    eb_image, ib_image = acquire.take_reference_images(microscope, settings.image)\n\n    # show images\n    fig, ax = plt.subplots(1, 2, figsize=(10, 5))\n    ax[0].imshow(eb_image.data, cmap=\"gray\")\n    ax[0].set_title(\"Electron Beam Image\")\n    ax[0].axis(\"off\")\n    ax[1].imshow(ib_image.data, cmap=\"gray\")\n    ax[1].set_title(\"Ion Beam Image\")\n    ax[1].axis(\"off\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"openfibsem/examples/#imaging","title":"Imaging","text":"<p>The imaging example demonstrate how to take an image with both beams, and change the imaging settings.</p> <p>To run the script:</p> <pre><code>python example/example_imaging.py\n</code></pre> example/example_imaging.py<pre><code>import matplotlib\nimport matplotlib.pyplot as plt\n\nfrom fibsem import acquire, utils\nfrom fibsem.structures import BeamType\nimport logging\n\nmatplotlib.use('TkAgg', force=True) # Activate 'agg' backend for off-screen plotting.\n\n\n\"\"\"\nThis script will take an image with the electron beam, an image with the ion beam, and an image with both beams. \nThe images are then displayed in a matplotlib figure.\n\nThe settings for images are stored in the settings.image struct, and can be modified before taking an image.\n\nFor more detail on the settings, see the documentation for the ImageSettings class.\n\n\"\"\"\n\ndef main():\n\n    # connect to the microscope\n    microscope, settings = utils.setup_session(manufacturer=\"Demo\", ip_address=\"localhost\")\n\n    # info about ImageSettings\n    logging.info(f\"\\nAcquiring Images Example:\")\n    logging.info(f\"The current image settings are: \\n{settings.image}\")\n\n    # take an image with the electron beam\n    settings.image.beam_type = BeamType.ELECTRON\n    eb_image = acquire.new_image(microscope, settings.image)\n\n    # take an image with the ion beam\n    settings.image.beam_type = BeamType.ION\n    ib_image = acquire.new_image(microscope, settings.image)\n\n    # take an image with both beams with increased hfw\n    settings.image.hfw = 400e-6       \n    ref_eb_image, ref_ib_image = acquire.take_reference_images(microscope, settings.image)\n\n    # show images\n\n    fig, ax = plt.subplots(2, 2, figsize=(10, 7))\n    ax[0][0].imshow(eb_image.data, cmap=\"gray\")\n    ax[0][0].set_title(\"Electron Image 01\")\n    ax[0][1].imshow(ib_image.data, cmap=\"gray\")\n    ax[0][1].set_title(\"Ion Image 01\")\n    ax[1][0].imshow(ref_eb_image.data, cmap=\"gray\")\n    ax[1][0].set_title(\"Electron Image 02 (Reference)\")\n    ax[1][1].imshow(ref_ib_image.data, cmap=\"gray\")\n    ax[1][1].set_title(\"Ion Image 02 (Reference)\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"openfibsem/examples/#movement","title":"Movement","text":"<p>The movement example</p> <p>To run the script</p> <pre><code>python example/example_movement.py\n</code></pre> example/example_movement.py<pre><code>from fibsem import utils\nfrom fibsem.structures import  FibsemStagePosition\nimport numpy as np\nimport logging\n\n\n\"\"\"\nThis script demonstrates how to get the current stage position, and how to move the stage to a new position.\n\nThe basic movement methods are absolute_move and relative_move. \n- Relative move moves the stage by a certain amount in the current coordinate system.\n- Absolute move moves the stage to a new position in the absolute coordinate system. \n\nThis script will move the stage by 20um in the x direction (relative move), and then move back to the original position (absolute move).\n\nAdditional movement methods are available in the core api:\n- Stable Move: the stage moves along the sample plane, accounting for stage tilt, and shuttle pre-tilt\n- Vertical Move: the stage moves vertically in the chamber, regardless of tilt orientation\n\n\"\"\"\n\ndef main():\n\n    # connect to microscope\n    microscope, settings = utils.setup_session(manufacturer=\"Demo\", ip_address=\"localhost\")\n\n        # info about ImageSettings\n    logging.info(\"---------------------------------- Current Position ----------------------------------\\n\")\n\n    # get current position\n    intial_position = microscope.get_stage_position()\n    logging.info(f\"\\nStage Movement Example:\")\n    logging.info(f\"Current stage position: {intial_position}\")\n\n\n    logging.info(\"\\n---------------------------------- Relative Movement ----------------------------------\\n\")\n\n    #### Moving to a relative position ####\n    relative_move = FibsemStagePosition(x=20e-6,            # metres\n                                        y=0,                # metres\n                                        z=0.0,              # metres\n                                        r=np.deg2rad(0),    # radians\n                                        t=np.deg2rad(0))    # radians\n\n    input(f\"Press Enter to move by: {relative_move} (Relative)\")\n\n    # move by relative position    \n    microscope.move_stage_relative(relative_move)\n    current_position = microscope.get_stage_position()\n    logging.info(f\"After move stage position: {current_position}\")\n\n\n    logging.info(\"\\n---------------------------------- Absolute Movement ----------------------------------\\n\")\n\n    #### Moving to an absolute position ####\n    stage_position = intial_position # move back to initial position\n\n    # uncomment this if you want to move to a different position \n    # be careful to define a safe position to move too\n    # relative_move = FibsemStagePosition(x=0,                # metres\n    #                                     y=0,                # metres\n    #                                 z=0.0,                  # metres\n    #                                     r=np.deg2rad(0),    # radians\n    #                                     t=np.deg2rad(0))    # radians\n\n    input(f\"Press Enter to move to: {stage_position} (Absolute)\")\n\n    # move to absolute position\n    microscope.move_stage_absolute(stage_position) \n    current_position = microscope.get_stage_position()\n    logging.info(f\"After move stage position: {current_position}\")\n\n\n    logging.info(\"---------------------------------- End Example ----------------------------------\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"openfibsem/examples/#milling","title":"Milling","text":"<p>The milling example demonstrates how the define milling patterns, and run ion beam milling. Note: at the moment only ion beam milling is supported, we hope to add electron beam patterning in the future.</p> <pre><code>python example/example_milling_.py\n</code></pre> example/example_milling.py<pre><code>from fibsem import utils\nfrom fibsem.structures import FibsemMillingSettings, FibsemRectangeSettings, FibsemLineSettings\nfrom fibsem import milling\nimport logging\n\n\"\"\"\nThis script demonstrates how to use the milling module to mill a rectangle and two lines.\n\nThe script will:\n    - connect to the microscope\n    - setup milling\n    - draw a rectangle and two lines\n    - run milling\n    - finish milling (restore ion beam current)\n\n\"\"\"\n\ndef main():\n\n    # connect to microscope\n    microscope, settings = utils.setup_session(manufacturer=\"Demo\", ip_address=\"localhost\")\n\n    # rectangle pattern\n    rectangle_pattern = FibsemRectangeSettings(\n        width = 10.0e-6,\n        height = 10.0e-6,\n        depth = 2.0e-6,\n        rotation = 0.0,\n        center_x = 0.0,\n        center_y = 0.0,\n    )\n\n    # line pattern one\n    line_pattern_01 = FibsemLineSettings(\n        start_x = 0.0,\n        start_y = 0.0,\n        end_x = 10.0e-6,\n        end_y = 10.0e-6,\n        depth = 2.0e-6,\n    )\n\n    # line pattern two (mirror of line pattern one)\n    line_pattern_02 = line_pattern_01\n    line_pattern_02.end_y = -line_pattern_01.end_y\n\n    logging.info(f\"\"\"\\nMilling Pattern Example:\"\"\")\n\n    logging.info(f\"The current milling settings are: \\n{settings.milling}\")\n    logging.info(f\"The current rectangle pattern is \\n{rectangle_pattern}\")\n    logging.info(f\"The current line pattern one is \\n{line_pattern_01}\")\n    logging.info(f\"The current line pattern two is \\n{line_pattern_02}\")\n    logging.info(\"---------------------------------- Milling ----------------------------------\\n\")\n    # setup patterns in a list\n    patterns = [rectangle_pattern, line_pattern_01, line_pattern_02]\n\n    # setup milling\n    milling.setup_milling(microscope, settings.milling)\n\n    # draw patterns\n    for pattern in patterns:\n        milling.draw_pattern(microscope, pattern)\n\n    # run milling\n    milling.run_milling(microscope, settings.milling.milling_current, milling_voltage=settings.milling.milling_voltage)\n\n    # finish milling\n    milling.finish_milling(microscope, microscope.system.ion.beam.beam_current)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"openfibsem/examples/#autolamella","title":"AutoLamella","text":"<p>The autolamella script is a minimal recreation of the original autolamella program in ~150 lines of code using OpenFIBSEM. For the original paper please see AutoLamella V1 Paper</p> <p>To run the script:</p> <pre><code>python example/autolamella.py\n</code></pre> example/autolamella.py<pre><code>import logging\nimport os\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom pprint import pprint\n\nimport numpy as np\nfrom fibsem import acquire, alignment, milling, patterning, utils\nfrom fibsem.structures import BeamType, MicroscopeState,  FibsemImage, FibsemStagePosition\n\n\n@dataclass\nclass Lamella:\n    state: MicroscopeState\n    reference_image: FibsemImage\n    path: Path\n\ndef main():\n\n    PROTOCOL_PATH = os.path.join(os.path.dirname(__file__), \"protocol_autolamella.yaml\")\n    microscope, settings = utils.setup_session(protocol_path=PROTOCOL_PATH)\n\n    # move to the milling angle\n    stage_position = FibsemStagePosition(\n        r=np.deg2rad(settings.protocol[\"stage_rotation\"]),\n        t=np.deg2rad(settings.protocol[\"stage_tilt\"])\n    )\n    microscope.move_stage_absolute(stage_position) # do need a safe version?\n\n    # take a reference image    \n    settings.image.filename = \"grid_reference\"\n    settings.image.beam_type = BeamType.ION\n    settings.image.hfw = 900e-6\n    settings.image.save = True\n    acquire.take_reference_images(microscope, settings.image)\n\n    # select positions\n    experiment: list[Lamella] = []\n    lamella_no = 1\n    settings.image.hfw = 80e-6\n    base_path = settings.image.path\n\n    while True:\n        response = input(f\"\"\"Move to the desired position. \n        Do you want to select another lamella? [y]/n {len(experiment)} selected so far.\"\"\")\n\n        # store lamella information\n        if response.lower() in [\"\", \"y\", \"yes\"]:\n\n            # set filepaths\n            path = os.path.join(base_path, f\"{lamella_no:02d}\")\n            settings.image.path = path\n            settings.image.filename = f\"ref_lamella\"\n            acquire.take_reference_images(microscope, settings.image)\n\n            lamella = Lamella(\n                state=microscope.get_microscope_state(),\n                reference_image=acquire.new_image(microscope, settings.image),\n                path = path\n            )\n            experiment.append(lamella)\n            lamella_no += 1\n        else:\n            break\n\n    # sanity check\n    if len(experiment) == 0:\n        logging.info(f\"No lamella positions selected. Exiting.\")\n        return\n\n    # mill (rough, thin, polish)\n    workflow_stages = [\"rough\", \"thin\", \"polish\"]\n    for stage_no, stage_name in enumerate(workflow_stages):\n\n        logging.info(f\"Starting milling stage {stage_no}\")\n\n        lamella: Lamella\n        for lamella_no, lamella in enumerate(experiment):\n\n            logging.info(f\"Starting lamella {lamella_no:02d}\")\n\n            # return to lamella\n            microscope.set_microscope_state(lamella.state)\n\n            # realign\n            alignment.beam_shift_alignment(microscope, settings.image, lamella.reference_image)\n\n            if stage_no == 0:\n                microexpansion_stage = patterning.get_milling_stages(\"microexpansion\", settings.protocol)\n                milling.mill_stage(microscope, microexpansion_stage[0])\n\n            # get trench milling pattern, and mill\n            trench_stage = patterning.get_milling_stages(\"lamella\", settings.protocol)[stage_no]\n            milling.mill_stage(microscope, trench_stage)\n\n            # retake reference image\n            settings.image.path = lamella.path\n            settings.image.filename = f\"ref_mill_stage_{stage_no:02d}\"\n            lamella.reference_image = acquire.new_image(microscope, settings.image)\n\n            if stage_no == 3:\n                # take final reference images\n                settings.image.filename = f\"ref_final\"\n                acquire.take_reference_images(microscope, settings.image)\n\n    logging.info(f\"Finished autolamella: {settings.protocol['name']}\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"openfibsem/getting_started/","title":"Getting Started","text":""},{"location":"openfibsem/getting_started/#install-openfibsem","title":"Install OpenFIBSEM","text":"<p>Install Package</p> <pre><code>conda create -n fibsem python=3.9 pip\nconda activate fibsem\npip install fibsem \n</code></pre>"},{"location":"openfibsem/getting_started/#additional-installation-information","title":"Additional Installation Information","text":"<p>For detailed instructions on installation, and installing the commercial microscope APIs, see Installation Guide.</p>"},{"location":"openfibsem/getting_started/#configuring-your-microscope","title":"Configuring your Microscope","text":"<p>To get started you only need a few values to configure your microscope. See below for a explanation of some these values.</p> <pre><code>name:                           monash-tfs-hydra-pfib-01    # a descriptive name for your configuration \nip_address:                     192.168.0.1                 # the ip address of the microscope PC\nmanufacturer:                   Thermo                      # the microscope manufactuer, Thermo, Tescan or Demo                       \nrotation-reference:             49                          # the reference rotation value (rotation when loading)  [degrees]\nshuttle-pre-tilt:               35                          # the pre-tilt of the shuttle                           [degrees]\nelectron-beam-eucentric-height: 4.0e-3                      # the eucentric height of the electron beam             [metres]\nion-beam-eucentric-height:      16.5e-3                     # the eucentric height of the ion beam                  [metres]\n</code></pre>"},{"location":"openfibsem/getting_started/#generating-an-intial-configuration","title":"Generating an intial configuration","text":"<p>To generate an initial configuration for your microscope, run the cli:</p> <pre><code>fibsem-generate-config --path path/to/save/configuration.yaml\n</code></pre> <p>This will walk you through generating your configuration, and use derived and default values for the rest of the configuration to get you started.</p> <p>You can edit the rest of the configuration values once it has been generated. The full configuration is below.</p>"},{"location":"openfibsem/getting_started/#full-microscope-configuration","title":"Full Microscope Configuration","text":"<p>The full microscope configuration after generation is as follows. See below for an explanation of some specific values.</p> microscope-configuration.yaml<pre><code># configuration\n# Please don't edit or delete this file, it is the default configuration for the microscope\n# configuration \ninfo:\n    name: openfibsem-microscope-configuration               # a descriptive name for your configuration                     [SPECIFIED]\n    ip_address: 192.168.0.1                                 # the ip address of the microscope PC                           [SPECIFIED]\n    manufacturer: Thermo                                    # the microscope manufactuer                                    [SPECIFIED]        \nstage:\n    enabled:                    true                        # the stage is enabled                                          [USER]\n    rotation:                   true                        # the stage is able to rotate                                   [USER]\n    tilt:                       true                        # the stage is able to tilt                                     [USER]\n    rotation_reference:         0                           # the reference rotation value                                  [SPECIFIED] \n    rotation_180:               180                         # the reference rotation + 180 degrees                          [DERIVED - rotation-reference]\n    shuttle_pre_tilt:           35.0                        # the pre-tilt of the shuttle                                   [SPECIFIED]\n    manipulator_height_limit:   0.0037                      # the linked height limit for manipulator (Thermo Only)         [DERIVED - manufactuer]\nelectron:                                              \n    enabled:                    true                        # the electron beam is enabled                                  [USER]\n    column_tilt:                0                           # the column tilt of the electron beam                          [DERIVED - manufactuer]\n    eucentric_height:           7.0e-3                      # the eucentric height of the electron beam                     [SPECIFIED]\n    voltage:                    2000                        # the voltage of the electron beam                              [USER]\n    current:                    50.0e-12                    # the current of the electron beam                              [USER]\n    resolution:                 [1536, 1024]                # the default electron resolution                       [pixel] [USER]\n    hfw:                        150.0e-6                    # the default electron hfw                              [metres][USER]\n    dwell_time:                 1.0e-06                     # the default electron dwell time\n    detector_mode:              SecondaryElectrons          # the detector mode of the electron beam                        [USER]\n    detector_type:              ETD                         # the detector type of the electron beam                        [USER]\nion:\n    enabled:                    true                        # the ion beam is enabled                                       [USER]\n    column_tilt:                52                          # the column tilt of the electron beam                          [SPECIFIED]\n    eucentric_height:           16.5e-3                     # the eucentric height of the ion beam                          [SPECIFIED]\n    plasma:                     false                       # ion beam is a plasma column                                   [USER]\n    plasma_gas:                 None                        # the plasma gas for the ion beam (plasma fib only)             [USER]\n    voltage:                    30000                       # the voltage of the ion beam                                   [USER]\n    current:                    2.0e-11                     # the current of the ion beam                                   [USER]\n    resolution:                 [1536, 1024]                # the default ion resolution                            [pixel] [USER]\n    hfw:                        150.0e-6                    # the default ion hfw                                   [metres][USER]\n    dwell_time:                 1.0e-06                     # the default ion dwell time\n    detector_mode:              SecondaryElectrons          # the detector mode of the ion beam                             [USER]\n    detector_type:              ETD                         # the detector type of the ion beam                             [USER]\nmanipulator:\n    enabled:                    true                        # manipulator is enabled                                        [USER]\n    rotation:                   false                       # manipulator is able to rotate                                 [USER]\n    tilt:                       false                       # manipulator is able to tilt                                   [USER]\ngis:\n    enabled:                    true                        # gis is enabled                                                [USER]\n    multichem:                  true                        # multichem is enabled                                          [USER]\n    sputter_coater:             false                       # sputter coater is enabled                                     [USER]                        \nimaging:\n    beam_type:                  ELECTRON                    # the default imaging beam type (ELECTRON, or ION)              [USER]\n    resolution:                 [1536, 1024]                # the default imaging resolution                        [pixel] [USER]\n    hfw:                        150.0e-6                    # the default imaging hfw                               [metres][USER]\n    dwell_time:                 1.0e-06                     # the default imaging dwell time                        [second][USER]\n    imaging_current:            2.0e-11                     # the default imaging current                           [amp]   [USER]\n    autocontrast:               true                        # use autocontrast                                              [USER]\n    autogamma:                  false                       # use autogamma                                                 [USER]\n    save:                       false                       # auto save images                                              [USER]\nmilling:\n    milling_voltage:            30000                       # the default milling voltage       (Thermo)            [volt]  [USER]\n    milling_current:            2.0e-09                     # the default milling current       (Thermo)            [amp]   [USER]   \n    dwell_time:                 1.0e-06                     # the default milling dwell time    (TESCAN)            [second][USER]\n    rate:                       3.4e-09                     # the default milling spuuter rate  (TESCAN)            [um3/s] [USER]\n    spot_size:                  5.4e-08                     # the default milling spot size     (TESCAN)            [metres][USER]\n    preset:                     \"30 keV; 20 nA\"             # the default milling preset        (TESCAN)                    [USER]                      \n</code></pre>"},{"location":"openfibsem/getting_started/#ip-address","title":"IP Address","text":"<p>To find the local ip address of the microscope PC, you can use ipconfig. If you have a standard setup, and have installed openfibsem on the Support PC, this ip address is usually 192.168.0.1. But this might not be the case, so check with ipconfig</p>"},{"location":"openfibsem/getting_started/#rotation-reference","title":"Rotation Reference","text":"<p>The rotation reference is the reference point for stage rotation. For standard ThermoFisher systems it is the rotation when initially loading the stage. It is also the rotation used when you tilt perpendicular to the Electron Beam. The rotation_180 value is 180 degrees offset from the reference rotation, and is the rotation used to tilt perpendicular to the Ion Beam.</p> <p> Rotation Reference Position</p> <p> Rotation 180 Reference Position</p>"},{"location":"openfibsem/getting_started/#column-tilt","title":"Column Tilt","text":"<p>The column tilt angle for each beam. This is standardised for each manufactuer.</p> Manufacturer Electron Beam Ion Beam Thermo Fisher 0 deg 52 deg Tescan 0 deg 55 deg"},{"location":"openfibsem/getting_started/#eucentric-height","title":"Eucentric Height","text":"<p>The pre-defined working distance for each beam, that defines the eucentric point of the system. This is standard for each different model. I will add more to the table below as I confirm them.</p> Model Electron Beam Ion Beam TFS - Helios (Hydra) 4.0 mm 16.5 mm TFS - Aquilos 7.0 mm 19 mm TESCAN - Amber"},{"location":"openfibsem/getting_started/#thermo-fisher-microscopes","title":"Thermo Fisher Microscopes","text":"<p>If you are using a Thermo Fisher FIBSEM, I would recommend loading our application files; autolamella and cryo_Pt_dep. You don't have to use them, but you may need to setup application files to work with our milling conventions. </p> <p>They are found in fibsem/external/application_files. You can load them using xTUI. </p>"},{"location":"openfibsem/getting_started/#system-fingerprint","title":"System Fingerprint","text":"<p>BETA: Not Yet Available</p> <p>Connect to the microscope, read the configuration directly from it.</p>"},{"location":"openfibsem/getting_started/#connecting-to-the-microscope","title":"Connecting to the Microscope","text":"<p>Once you have configured you microscope, you should be able to connect to the microscope.</p>"},{"location":"openfibsem/getting_started/#before-you-start","title":"Before You Start","text":"<p>Before you start it is recommended that you setup the microscope in the same way you would normally. This includes:</p> <ul> <li>Pumping the System</li> <li>Loading a Sample  </li> <li>Turning on the Beams</li> <li>Linking the Stage (Thermo Fisher)</li> <li>Anything else</li> </ul> <p>We are working on controlling these aspects of the systems, but for now consider them pre-requistes for using openfibsem (and applications)</p>"},{"location":"openfibsem/getting_started/#try-out-examples","title":"Try out Examples","text":"<p>To get familiar with the API, you can try out the example scripts.</p>"},{"location":"openfibsem/getting_started/#run-the-user-interface","title":"Run the User Interface","text":"<p>You can run the general microscope user interface with the following command:</p> <pre><code>fibsem_ui\n</code></pre> <p>Or if you installed the napari plugin, you can launch it through the plugin menu.</p> <p> OpenFIBSEM UI - Start Up</p>"},{"location":"openfibsem/getting_started/#select-your-configuration","title":"Select Your Configuration","text":"<p>From here, you can select your configuration using the \"...\" button. Select your configuration, add it to the user configurations, and make it the default.</p> <p> OpenFIBSEM UI - Select Configuration</p>"},{"location":"openfibsem/getting_started/#connect-to-the-microscope","title":"Connect to the Microscope","text":"<p>Once you have selected your configuration, you can connect to the microscope. From here you have full control over the microscope systems.</p> <p> OpenFIBSEM UI - Microscope Connected</p>"},{"location":"openfibsem/getting_started/#acquire-images","title":"Acquire Images","text":"<p>Change to the Image tab, and try to take an image.</p> <p> OpenFIBSEM UI - Images Acquired</p>"},{"location":"openfibsem/getting_started/#congratulations","title":"Congratulations","text":"<p>If you made it this far, congratulations! Your system is setup and should be ready to use. We have only scratched the surface of concepts and the api, so please check out the Concepts page to learn more about the OpenFIBSEM API, and how it can best help you.</p> <p>If you have any questions feel free to reach out to Patrick on Twitter or via email.</p>"},{"location":"openfibsem/installation/","title":"Installation Guide","text":""},{"location":"openfibsem/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.9+</li> <li>FIB/SEM microscope (a commercial product by ThermoFisher FEI or TESACN)</li> <li>Autoscript software (a commercial product by ThermoFisher FEI) OR</li> <li>tescanautomation software (a commercial product by TESCAN)</li> </ul>"},{"location":"openfibsem/installation/#python","title":"Python","text":"<p>Python 3.9 is required. The Anaconda distribution of python is recommended.</p> <p>It is also highly recommended to use virtual environments for development, see Managing Conda Environments for more information. (Optionally, you could use <code>virtualenv</code> if you prefer.)</p>"},{"location":"openfibsem/installation/#install","title":"Install","text":""},{"location":"openfibsem/installation/#install-openfibsem","title":"Install OpenFIBSEM","text":"<p>There are several ways to install OpenFIBSEM depending on your application and needs. These will also install required dependencies.</p>"},{"location":"openfibsem/installation/#pypi-for-users","title":"PyPI (For Users)","text":"<pre><code>pip install fibsem \n</code></pre>"},{"location":"openfibsem/installation/#github-for-development","title":"Github (For Development)","text":"<p>Clone this repository, and checkout main:</p> <pre><code>git clone https://github.com/DeMarcoLab/fibsem.git\n</code></pre> <p>Install dependencies and package</p> <pre><code>cd fibsem\nconda create -n fibsem python=3.9 pip\nconda activate fibsem\npip install -e .\n</code></pre>"},{"location":"openfibsem/installation/#napari-plugin","title":"Napari Plugin","text":"<p>The OpenFIBSEM tools and user interface are also available as a napari plugin:</p> <pre><code>pip install napari-openfibsem\n</code></pre> <p>Or use napari plugin manager</p> <p> Napari Plugin Manager</p>"},{"location":"openfibsem/installation/#testing-your-installation","title":"Testing your installation","text":"<p>You can test your installation by running the following script: </p> <pre><code>python scripts/test_installation.py\n</code></pre> <p>This will tell you the status of the openfibsem API, applications and installed hardware APIs.</p>"},{"location":"openfibsem/installation/#installing-microscope-hardware-apis","title":"Installing Microscope Hardware APIs","text":""},{"location":"openfibsem/installation/#installing-autoscript","title":"Installing Autoscript","text":"<p>Autoscript provides an API (application programming interface) for scripting control of compatible FEI microscope systems. This is a commercial product by Thermo Fisher FEI, please visit their website at https://www.thermofisher.com/au/en/home/electron-microscopy.html for information on pricing and installation.</p>"},{"location":"openfibsem/installation/#before-you-start","title":"Before you start","text":"<p>AutoScript is usually installed on the Support PC for ThermoFisher Instruments. OpenFIBSEM will automatically find this installation and use it, if it is installed in the standard location. If you fail to connect to the microscope, and see a message \"Autoscript (ThermoFisher) not installed.\" these steps might help diagnose and solve the problem.</p>"},{"location":"openfibsem/installation/#autoscript-versions","title":"AutoScript Versions","text":"<p>We use Autoscript version 4.7.+. Contact ThermoFisher support to upgrade your AutoScript version.</p> <p>The version numbers of the python packages Autoscript installs were:</p> <ul> <li>autoscript-core 5.12.0</li> <li>autoscript-sdb-microscope-client 4.7.0</li> <li>autoscript-sdb-microscope-client-tests 4.7.0</li> <li>autoscript-toolkit 4.7.0</li> <li>thermoscientific-logging 5.12.0</li> </ul>"},{"location":"openfibsem/installation/#add-the-autoscript-python-packages-to-your-site-packages","title":"Add the autoscript python packages to your <code>site-packages</code>","text":"<p>To add the AutoScript python packages to your new conda environment, follow these three steps:</p> <ol> <li>Find the python environment that was created with your AutoScript installation. Typically, you can expect the environment is named 'Autoscript', and its installed packages should be found at: <code>C:\\Program Files\\Python36\\envs\\AutoScript\\Lib\\site-packages\\</code></li> </ol> <p>Troubleshooting: If you're having trouble finding the location AutoScript chose to install its python packages into, you can open the default terminal on your machine (eg: <code>cmd</code> for Windows) and type <code>where python</code> (Windows) or <code>which python</code> (Unix). The result will be something like <code>C:\\Program Files\\Python36\\envs\\AutoScript\\python.exe</code>. Navigate to the environment location (in the example here, that's <code>C:\\Program Files\\Python36\\envs\\AutoScript\\</code> then change directories into <code>Lib</code>, and then the <code>site-packages</code> directory. This is where the python packages live.</p> <ol> <li>Find the conda environment location you just made called <code>fibsem</code>. <code>...conda/envs/fibsem/Lib/site-packages/</code></li> </ol> <p>Note: if you used python virtual env to create a virtual environment, the location of the fibsem/Lib/site-packages will be where the virtual environment was created. Where this document mentions the site-packages directory, it is referring to the site-packages directory of the virtual environment.</p> <p>Troubleshooting: If you're having trouble finding the conda environment location for <code>fibsem</code> you can open the Anaconda terminal on your machine and type <code>where python</code> (Windows) or <code>which python</code> (Unix). The result will be something like <code>C:\\Users\\yourusername\\.conda\\envs\\fibsem\\python.exe</code> Navigate to the environment location (in the example here, that's <code>C:\\Users\\yourusername\\.conda\\envs\\fibsem\\</code> then change directories into <code>Lib</code>, and then the <code>site-packages</code> directory. This is where you want to add copies of the AutoScript python packages.</p> <ol> <li> <p>Make a copy of the relevant AutoScript python packages into the conda environment. You will need to copy:</p> </li> <li> <p>autoscript_core</p> </li> <li>autoscript_core-5.12.0.dist-info</li> <li>autoscript_sdb_microscope_client</li> <li>autoscript_sdb_microscope_client_tests</li> <li>autoscript_sdb_microscope_client_tests-4.7.0.dist-info</li> <li>autoscript_sdb_microscope_client-4.7.0.dist-info</li> <li>autoscript_toolkit</li> <li>autoscript_toolkit-4.7.0.dist-info</li> <li>thermoscientific_logging</li> <li>thermoscientific_logging-5.12.1.dist-info</li> </ol>"},{"location":"openfibsem/installation/#having-problems","title":"Having problems?","text":"<ul> <li>Check to see if Autoscript is correctly installed and configured.</li> <li>Check to see if your python environment contains all packages listed in the requirements.txt</li> <li>Check that when you call python from the terminal, you get the python environment containing the dependencies listed above (i.e. you are not using a different python environment)</li> <li>Try cloning the repository and running the unit tests, you may want to try installing from the source code.</li> </ul>"},{"location":"openfibsem/installation/#installing-tescanautomation","title":"Installing Tescanautomation","text":"<p>Tescanautomation is a hardware API for controlling TESCAN microscopes. This is a commercially available product from TESCAN. The SDK is available in an .exe file format</p>"},{"location":"openfibsem/installation/#prerequisites","title":"Prerequisites","text":"<p>Before beginning this install, please ensure the following</p> <ul> <li>fibsem conda/virtualenv environment is installed and setup</li> <li>tescan-automation-sdk-install exe file is ready to go</li> </ul>"},{"location":"openfibsem/installation/#installing-the-sdk","title":"Installing the SDK","text":"<p>Run the installer exe file. When it asks for the python interpreter, select the one that that matches your fibsem environment and proceed with the install.</p> <p>The package should now be installed successfully</p>"},{"location":"openfibsem/installation/#common-issue-with-python-interpreter","title":"Common Issue with Python Interpreter","text":"<p>If the conda python interpreter cannot be selected from the drop down options, proceed with the install and take note of the path of installed python interpreter.</p> <p>(If no python interpreter can be found in the drop down, install python 3.9+ seperately and run the installation exe again)</p> <p>Once the installation has been completed, navigate to where python is installed on which the SDK has been installed.</p> <p>In there, navigate to</p> <p><code>...\\python\\lib\\site-packages</code></p> <p>from this folder, find and copy the following folders:</p> <ul> <li>All folders beginning with <code>PySide6</code></li> <li>All folders beginning with <code>shiboken</code></li> <li>All folders beginning with <code>tescan</code></li> </ul> <p>Copy these into the python folder that is set up in the conda environment</p> <p><code>...\\Anaconda3\\envs\\fibsem\\lib\\site-packages</code></p> <p>The package should now be installed successfully</p>"},{"location":"openfibsem/installation/#checking-install","title":"Checking Install","text":"<p>To check if the module has been installed properly and can be imported, run the following python code in FIBSEM:</p> <pre><code>import sys\nfrom tescanautomation import Automation\n\nprint(\"Tescan Imported Successfully\") if \"tescanautomation\" in sys.modules else print(\"Tescan Import was unsuccessful\")\n</code></pre> <p>If the import or install is unsuccessful, check to see if all the packages have been copied to the right directory.</p>"},{"location":"openfibsem/reference/","title":"API Reference","text":"<p>[Under Construction]</p>"},{"location":"openfibsem/roadmap/","title":"Roadmap","text":""},{"location":"openfibsem/roadmap/#version-10","title":"Version 1.0","text":"<p>[Under Construction]</p> <p>Release</p> <p>Core:</p> <p>API</p> <p>Database</p> <p>Server</p> <p>Backend</p> <p>AutoLamella:</p> <p>Validation:</p> <p>Dataset:</p> <p>Models:</p> <p>Evaluation</p>"}]}